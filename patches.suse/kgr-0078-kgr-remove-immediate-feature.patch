From: Miroslav Benes <mbenes@suse.cz>
Date: Wed, 3 Jun 2015 13:44:18 +0200
Subject: kgr: remove immediate feature
Patch-mainline: submitted for review
References: fate#313296

kGraft supports immediate feature which, if set for a patch, bypass a
consistency model and the patch is applied immediately as is. It can be
used for number of fixes which does not require special approach. The
patching is finished in an instant and there is no need to handle
blocking tasks.

It has one major drawback though. If an immediate patch is reverted or
an immediate replace-all patch is applied it is done right away and a
reference to a module with the patch is put. Thus the module can be
removed. However there is no guarantee that there is no task running or
sleeping in the removed code. This could easily cause serious problems.
For this reason the immediate feature cannot be used anymore and we can
remove it.

The consistency model is now the only way how to apply a patch. It
guarantees that when the patching is finished there is no task in old
code which can then be safely removed. The problem of blocking tasks is
substantially alleviated with the introduction of the fake signal.

Signed-off-by: Miroslav Benes <mbenes@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 include/linux/kgraft.h |    2 --
 kernel/kgraft.c        |   29 +++++++++--------------------
 2 files changed, 9 insertions(+), 22 deletions(-)

--- a/include/linux/kgraft.h
+++ b/include/linux/kgraft.h
@@ -79,7 +79,6 @@ struct kgr_patch_fun {
  * @name: name of the patch (to appear in sysfs)
  * @owner: module to refcount on patching
  * @replace_all: revert everything applied before and apply this one instead
- * @immediate: avoid the lazy-switching mechanism and flip the switch ASAP
  * @patches: array of @kgr_patch_fun structures
  */
 struct kgr_patch {
@@ -93,7 +92,6 @@ struct kgr_patch {
 	const char *name;
 	struct module *owner;
 	bool replace_all;
-	bool immediate;
 	struct kgr_patch_fun patches[];
 };
 
--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -914,14 +914,8 @@ int kgr_modify_kernel(struct kgr_patch *
 		goto err_unlock;
 	}
 
-	/*
-	 * If the patch has immediate flag set, avoid the lazy-switching
-	 * between universes completely.
-	 */
-	if (!patch->immediate) {
-		set_bit(0, kgr_immutable);
-		wmb(); /* set_bit before kgr_handle_processes */
-	}
+	set_bit(0, kgr_immutable);
+	wmb(); /* set_bit before kgr_handle_processes */
 
 	/*
 	 * Set kgr_patch before it can be used in kgr_patching_failed if
@@ -959,18 +953,13 @@ int kgr_modify_kernel(struct kgr_patch *
 	mutex_unlock(&kgr_in_progress_lock);
 
 	kgr_handle_irqs();
-
-	if (patch->immediate) {
-		kgr_finalize();
-	} else {
-		kgr_handle_processes();
-		wmb(); /* clear_bit after kgr_handle_processes */
-		clear_bit(0, kgr_immutable);
-		/*
-		 * give everyone time to exit kernel, and check after a while
-		 */
-		queue_delayed_work(kgr_wq, &kgr_work, KGR_TIMEOUT * HZ);
-	}
+	kgr_handle_processes();
+	wmb(); /* clear_bit after kgr_handle_processes */
+	clear_bit(0, kgr_immutable);
+	/*
+	 * give everyone time to exit kernel, and check after a while
+	 */
+	queue_delayed_work(kgr_wq, &kgr_work, KGR_TIMEOUT * HZ);
 
 	return 0;
 err_free:
