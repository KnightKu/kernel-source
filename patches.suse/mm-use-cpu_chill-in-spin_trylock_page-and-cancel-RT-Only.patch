From 196c055f529ecb56c0fe843257b7a14699a2fa97 Mon Sep 17 00:00:00 2001
From: Mel Gorman <mgorman@suse.de>
Date: Tue, 10 Jul 2012 16:31:42 +0100
Subject: [PATCH] mm: use cpu_chill() in spin_trylock_page() and cancel
 (RT-Only)

References: VM performance, lock page scalability (bnc#436953, bnc#629170)
Patch-mainline: No (Never, no compelling use case other than boot times on very large machines)

Should a SCHED_FIFO task preempt the task which should modify any of
the loop conditions, we can spin forever. This is because need_resched()
never becomes true. This patch handles the problem depending differently
depending on the kernel.

For RT kernels, it will call cpu_chill() once to msleep(1) before retrying
	to lock the page. If it fails to get access it will abort, call
	sleep_on_page() which calls io_schedule() to unplug any pending IO.

For Non-RT kernels it will use cpu_relax() until it needs to reschedule
	or at least 1 lock tick has passed before going to sleep and
	unplugging IO.

Signed-off-by: Mike Galbraith <mgalbraith@suse.de>
Signed-off-by: Mel Gorman <mgorman@suse.de>
---
 mm/filemap.c | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/mm/filemap.c b/mm/filemap.c
index 89e0852..eacccad 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -676,12 +676,20 @@ enum trylock_page_status {
 	TRYLOCK_PAGE_SCHEDULE
 };
 
-/* Returns true if spin_trylock_page should continue */
+#ifndef CONFIG_PREEMPT_RT_FULL
+/* Returns true if spinning should continue */
 static bool continue_trylock_relax(unsigned long expires)
 {
 	cpu_relax();
 	return !(need_resched() || time_after(jiffies, expires));
 }
+#else
+static bool continue_trylock_relax(unsigned long expires)
+{
+	cpu_chill();
+	return false;
+}
+#endif
 
 /*
  * If a page is locked, clean and uptodate then in many cases the hold time
