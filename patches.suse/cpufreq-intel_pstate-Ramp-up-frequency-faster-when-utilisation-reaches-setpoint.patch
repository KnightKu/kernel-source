From 27b6c65ce9c8e851c771137d12eca8d97bb5ce4b Mon Sep 17 00:00:00 2001
From: Mel Gorman <mgorman@suse.de>
Date: Mon, 20 Nov 2017 16:11:53 +0000
Subject: [PATCH] cpufreq, intel_pstate: Ramp up frequency faster when
 utilisation reaches setpoint

References: bnc#1068680 Update schedutil and intel_pstate to default to load-based policy
Patch-mainline: No, upstream favours power consumption over performance

SLE carried an out-of-tree patch for intel-pstate PID policy to decrease
the setpoint at which the CPU frequency was increased. This was necessary as
low-utilisation workloads would often be stuck at the lowest frequency and
hurt overall throughput. setpoint does not exist for the load-based policy
so this patch introduces equivalent logic to obey the setpoint used by PID.

Signed-off-by: Mel Gorman <mgorman@suse.de>
---
 drivers/cpufreq/intel_pstate.c | 21 +++++++++++++++++----
 1 file changed, 17 insertions(+), 4 deletions(-)

diff --git a/drivers/cpufreq/intel_pstate.c b/drivers/cpufreq/intel_pstate.c
index f42a897fb450..0ee949ec8f6b 100644
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@ -1628,7 +1628,7 @@ static inline int32_t get_target_pstate_use_cpu_load(struct cpudata *cpu)
 {
 	struct sample *sample = &cpu->sample;
 	int32_t busy_frac, boost;
-	int target, avg_pstate;
+	int target, avg_pstate, max_target;
 
 	busy_frac = div_fp(sample->mperf << cpu->aperf_mperf_shift,
 			   sample->tsc);
@@ -1641,10 +1641,10 @@ static inline int32_t get_target_pstate_use_cpu_load(struct cpudata *cpu)
 
 	sample->busy_scaled = busy_frac * 100;
 
-	target = global.no_turbo || global.turbo_disabled ?
+	max_target = global.no_turbo || global.turbo_disabled ?
 			cpu->pstate.max_pstate : cpu->pstate.turbo_pstate;
-	target += target >> 2;
-	target = mul_fp(target, busy_frac);
+	max_target += max_target >> 2;
+	target = mul_fp(max_target, busy_frac);
 	if (target < cpu->pstate.min_pstate)
 		target = cpu->pstate.min_pstate;
 
@@ -1659,6 +1659,19 @@ static inline int32_t get_target_pstate_use_cpu_load(struct cpudata *cpu)
 	if (avg_pstate > target)
 		target += (avg_pstate - target) >> 1;
 
+	/*
+	 * If the policy is the Server Enterprise policy then ramp up faster
+	 * once utilisation hits CPUFREQ_SERVER_DEFAULT_SETPOINT similar to
+	 * the setpoint for the PID policy.
+	 */
+	if (sample->busy_scaled >= CPUFREQ_SERVER_DEFAULT_SETPOINT &&
+	    pid_params.setpoint == CPUFREQ_SERVER_DEFAULT_SETPOINT) {
+		int delta = max(0, max_target - target);
+
+		target += delta >> 1;
+		target = min(max_target, target);
+	}
+
 	return target;
 }
 
