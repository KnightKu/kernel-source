From: Vojtech Pavlik <vojtech@suse.cz>
Date: Mon, 7 Jul 2014 13:25:53 +0200
Subject: s390: kgr, add support
Patch-mainline: submitted for review
References: fate#313296

Now, when s390 has support for DYNAMIC_FTRACE_WITH_REGS, it is easy to
add a support for kGraft. We just add HAVE_KGRAFT to S390, add the
needed bits in kgraft.h, and handle the syscall path in entry64.S.

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 arch/s390/Kconfig                   |    3 +++
 arch/s390/include/asm/kgraft.h      |   33 +++++++++++++++++++++++++++++++++
 arch/s390/include/asm/thread_info.h |    2 ++
 arch/s390/kernel/entry64.S          |    2 ++
 4 files changed, 40 insertions(+)
 create mode 100644 arch/s390/include/asm/kgraft.h

--- a/arch/s390/Kconfig
+++ b/arch/s390/Kconfig
@@ -124,6 +124,7 @@ config S390
 	select HAVE_KERNEL_LZMA
 	select HAVE_KERNEL_LZO
 	select HAVE_KERNEL_XZ
+	select HAVE_KGRAFT
 	select HAVE_KPROBES
 	select HAVE_KRETPROBES
 	select HAVE_KVM if 64BIT
@@ -152,6 +153,8 @@ source "init/Kconfig"
 
 source "kernel/Kconfig.freezer"
 
+source "kernel/Kconfig.kgraft"
+
 menu "Processor type and features"
 
 config HAVE_MARCH_Z900_FEATURES
--- /dev/null
+++ b/arch/s390/include/asm/kgraft.h
@@ -0,0 +1,33 @@
+/*
+ * kGraft Online Kernel Patching
+ *
+ *  Copyright (c) 2013-2014 SUSE
+ *   Authors: Jiri Kosina
+ *	      Vojtech Pavlik
+ *	      Jiri Slaby
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+#ifndef ASM_KGR_H
+#define ASM_KGR_H
+
+#include <asm/ptrace.h>
+#include <linux/stacktrace.h>
+
+static inline void kgr_set_regs_ip(struct pt_regs *regs, unsigned long ip)
+{
+	regs->psw.addr = ip;
+}
+
+static inline bool kgr_needs_lazy_migration(struct task_struct *p)
+{
+	return true;
+}
+
+#endif
--- a/arch/s390/include/asm/thread_info.h
+++ b/arch/s390/include/asm/thread_info.h
@@ -92,6 +92,7 @@ static inline struct thread_info *curren
 #define TIF_MEMDIE		18	/* is terminating due to OOM killer */
 #define TIF_RESTORE_SIGMASK	19	/* restore signal mask in do_signal() */
 #define TIF_SINGLE_STEP		20	/* This task is single stepped */
+#define TIF_KGR_IN_PROGRESS	21	/* This task has not finished patching */
 
 #define _TIF_SYSCALL		(1<<TIF_SYSCALL)
 #define _TIF_NOTIFY_RESUME	(1<<TIF_NOTIFY_RESUME)
@@ -106,6 +107,7 @@ static inline struct thread_info *curren
 #define _TIF_SYSCALL_TRACEPOINT	(1<<TIF_SYSCALL_TRACEPOINT)
 #define _TIF_31BIT		(1<<TIF_31BIT)
 #define _TIF_SINGLE_STEP	(1<<TIF_SINGLE_STEP)
+#define _TIF_KGR_IN_PROGRESS	(1<<TIF_KGR_IN_PROGRESS)
 
 #ifdef CONFIG_64BIT
 #define is_32bit_task()		(test_thread_flag(TIF_31BIT))
--- a/arch/s390/kernel/entry64.S
+++ b/arch/s390/kernel/entry64.S
@@ -220,6 +220,7 @@ sysc_vtime:
 	mvc	__PT_INT_CODE(4,%r11),__LC_SVC_ILC
 sysc_do_svc:
 	oi	__TI_flags+7(%r12),_TIF_SYSCALL
+	ni	__TI_flags+5(%r12),255 - (_TIF_KGR_IN_PROGRESS >> 16)
 	lg	%r10,__TI_sysc_table(%r12)	# address of system call table
 	llgh	%r8,__PT_INT_CODE+2(%r11)
 	slag	%r8,%r8,2			# shift and test for svc 0
@@ -248,6 +249,7 @@ sysc_tif:
 	tm	__TI_flags+7(%r12),_TIF_WORK_SVC
 	jnz	sysc_work			# check for work
 	ni	__TI_flags+7(%r12),255-_TIF_SYSCALL
+	ni	__TI_flags+5(%r12),255 - (_TIF_KGR_IN_PROGRESS >> 16)
 sysc_restore:
 	lg	%r14,__LC_VDSO_PER_CPU
 	lmg	%r0,%r10,__PT_R0(%r11)
