From: Jiri Slaby <jslaby@suse.cz>
Date: Tue, 1 Jul 2014 10:59:12 +0200
Subject: kgr: add patch information into sysfs
Patch-mainline: submitted for review
References: fate#313296

Expose information about patch state machine in sysfs. This will be
later extended to contain a file for patch revert and possibly more.

js: add owner link
js: fix build for !MODULE

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 include/linux/kgraft.h          | 10 +++++
 kernel/kgraft.c                 | 15 +++++++
 kernel/kgraft_files.c           | 92 +++++++++++++++++++++++++++++++++++++++++
 samples/kgraft/kgraft_patcher.c |  2 +
 4 files changed, 119 insertions(+)

diff --git a/include/linux/kgraft.h b/include/linux/kgraft.h
index 386f12d13dff..7c533f570e2f 100644
--- a/include/linux/kgraft.h
+++ b/include/linux/kgraft.h
@@ -19,6 +19,7 @@
 
 #include <linux/bitops.h>
 #include <linux/compiler.h>
+#include <linux/kobject.h>
 #include <linux/ftrace.h>
 #include <linux/sched.h>
 
@@ -65,15 +66,21 @@ struct kgr_patch_fun {
 /**
  * struct kgr_patch -- a kGraft patch
  *
+ * @kobj: object representing the sysfs entry
+ * @finish: waiting till it is safe to remove the module with the patch
  * @irq_use_new: per-cpu array to remember kGraft state for interrupts
+ * @name: name of the patch (to appear in sysfs)
  * @owner: module to refcount on patching
  * @patches: array of @kgr_patch_fun structures
  */
 struct kgr_patch {
 	/* internal state information */
+	struct kobject kobj;
+	struct completion finish;
 	bool __percpu *irq_use_new;
 
 	/* a patch shall set these */
+	const char *name;
 	struct module *owner;
 	struct kgr_patch_fun patches[];
 };
@@ -91,6 +98,9 @@ struct kgr_patch {
 extern bool kgr_in_progress;
 
 extern int kgr_patch_kernel(struct kgr_patch *);
+extern void kgr_patch_remove(struct kgr_patch *);
+extern int kgr_patch_dir_add(struct kgr_patch *patch);
+extern void kgr_patch_dir_del(struct kgr_patch *patch);
 extern int kgr_add_files(void);
 extern void kgr_remove_files(void);
 
diff --git a/kernel/kgraft.c b/kernel/kgraft.c
index 2f8f2fea177f..17d259d3a5ce 100644
--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -372,6 +372,8 @@ int kgr_patch_kernel(struct kgr_patch *patch)
 		goto err_unlock;
 	}
 
+	init_completion(&patch->finish);
+
 	kgr_mark_processes();
 
 	kgr_for_each_patch_fun(patch, patch_fun) {
@@ -396,6 +398,8 @@ int kgr_patch_kernel(struct kgr_patch *patch)
 	kgr_patch = patch;
 	mutex_unlock(&kgr_in_progress_lock);
 
+	kgr_patch_dir_add(patch);
+
 	kgr_handle_irqs();
 	kgr_handle_processes();
 
@@ -415,6 +419,17 @@ err_unlock:
 }
 EXPORT_SYMBOL_GPL(kgr_patch_kernel);
 
+/**
+ * kgr_patch_remove -- module with this patch is leaving
+ *
+ * @patch: this patch is going away
+ */
+void kgr_patch_remove(struct kgr_patch *patch)
+{
+	kgr_patch_dir_del(patch);
+}
+EXPORT_SYMBOL_GPL(kgr_patch_remove);
+
 static int __init kgr_init(void)
 {
 	int ret;
diff --git a/kernel/kgraft_files.c b/kernel/kgraft_files.c
index 40c6cb76b386..d9ae43f07f06 100644
--- a/kernel/kgraft_files.c
+++ b/kernel/kgraft_files.c
@@ -17,10 +17,102 @@
 #include <linux/kernel.h>
 #include <linux/kgraft.h>
 #include <linux/kobject.h>
+#include <linux/module.h>
 #include <linux/sysfs.h>
 
 static struct kobject *kgr_sysfs_dir;
 
+static inline struct kgr_patch *kobj_to_patch(struct kobject *kobj)
+{
+	return container_of(kobj, struct kgr_patch, kobj);
+}
+
+static void kgr_patch_kobj_release(struct kobject *kobj)
+{
+	struct kgr_patch *p = kobj_to_patch(kobj);
+
+	complete(&p->finish);
+}
+
+static struct kobj_type kgr_patch_kobj_ktype = {
+	.release	= kgr_patch_kobj_release,
+	.sysfs_ops	= &kobj_sysfs_ops,
+};
+
+static ssize_t state_show(struct kobject *kobj, struct kobj_attribute *attr,
+		char *buf)
+{
+	struct kgr_patch *p = kobj_to_patch(kobj);
+	const struct kgr_patch_fun *pf;
+	ssize_t size;
+
+	size = snprintf(buf, PAGE_SIZE, "%-20s  State  Fatal\n", "Function");
+
+	kgr_for_each_patch_fun(p, pf) {
+		size += snprintf(buf + size, PAGE_SIZE - size,
+				"%-20s  %5d  %5d\n",
+				pf->name, pf->state, pf->abort_if_missing);
+	}
+	return size;
+}
+
+static struct kobj_attribute kgr_attr_state = __ATTR_RO(state);
+
+static struct attribute *kgr_patch_sysfs_entries[] = {
+	&kgr_attr_state.attr,
+	NULL
+};
+
+static struct attribute_group kgr_patch_sysfs_group = {
+	.attrs = kgr_patch_sysfs_entries,
+};
+
+int kgr_patch_dir_add(struct kgr_patch *patch)
+{
+	int ret;
+
+	ret = kobject_init_and_add(&patch->kobj, &kgr_patch_kobj_ktype,
+			kgr_sysfs_dir, patch->name);
+	if (ret)
+		return ret;
+
+#ifdef CONFIG_MODULES
+	if (patch->owner) {
+		ret = sysfs_create_link(&patch->kobj, &patch->owner->mkobj.kobj,
+				"owner");
+		if (ret)
+			goto err_put;
+	}
+#endif
+
+	ret = sysfs_create_group(&patch->kobj, &kgr_patch_sysfs_group);
+	if (ret)
+		goto err_del_link;
+
+	return 0;
+err_del_link:
+#ifdef CONFIG_MODULES
+	if (patch->owner)
+		sysfs_delete_link(&patch->kobj, &patch->owner->mkobj.kobj,
+				"owner");
+err_put:
+#endif
+	kobject_put(&patch->kobj);
+	return ret;
+}
+
+void kgr_patch_dir_del(struct kgr_patch *patch)
+{
+	sysfs_remove_group(&patch->kobj, &kgr_patch_sysfs_group);
+#ifdef CONFIG_MODULES
+	if (patch->owner)
+		sysfs_delete_link(&patch->kobj, &patch->owner->mkobj.kobj,
+				"owner");
+#endif
+	kobject_put(&patch->kobj);
+	wait_for_completion(&patch->finish);
+}
+
 static ssize_t in_progress_show(struct kobject *kobj,
 		struct kobj_attribute *attr, char *buf)
 {
diff --git a/samples/kgraft/kgraft_patcher.c b/samples/kgraft/kgraft_patcher.c
index 4e3806ecdce5..1358ac6d1399 100644
--- a/samples/kgraft/kgraft_patcher.c
+++ b/samples/kgraft/kgraft_patcher.c
@@ -68,6 +68,7 @@ static void kgr_new_function(unsigned long data)
 }
 
 static struct kgr_patch patch = {
+	.name = "sample_patcher",
 	.owner = THIS_MODULE,
 	.patches = {
 #if defined(CONFIG_X86)
@@ -86,6 +87,7 @@ static int __init kgr_patcher_init(void)
 
 static void __exit kgr_patcher_cleanup(void)
 {
+	kgr_patch_remove(&patch);
 	pr_err("removing now buggy!\n");
 }
 
-- 
2.0.4

