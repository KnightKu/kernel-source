From: Petr Mladek <pmladek@suse.cz>
Date: Wed, 30 Jul 2014 11:34:12 +0200
Subject: kgr: try to apply skipped patches when a module is loaded
Patch-mainline: submitted for review
References: fate#313296

kGraft patches might modify both core kernel functions and modules. To
make the life easier, new functions for modules have the
"abort_if_missing" flag disabled. The result is that such patch could
be loaded even before the affected module.

This commit adds kgr_module_init() function that is called when the
module is being loaded but before the code is used. It allows to apply
the fast path from the pending patches.

The support for handling the patch in progress will be added later. It
will need more tweaking.

Also the support for more patches against the same function will be
added later.

js: fix !MODULES configs

Signed-off-by: Petr Mladek <pmladek@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 include/linux/kgraft.h |    1 
 kernel/kgraft.c        |   66 +++++++++++++++++++++++++++++++++++++++++++++++++
 kernel/module.c        |   10 +++++++
 3 files changed, 77 insertions(+)

--- a/include/linux/kgraft.h
+++ b/include/linux/kgraft.h
@@ -111,6 +111,7 @@ extern int kgr_patch_kernel(struct kgr_p
 extern void kgr_patch_remove(struct kgr_patch *);
 
 extern int kgr_modify_kernel(struct kgr_patch *patch, bool revert);
+extern void kgr_module_init(const struct module *mod);
 extern int kgr_patch_dir_add(struct kgr_patch *patch);
 extern void kgr_patch_dir_del(struct kgr_patch *patch);
 extern int kgr_add_files(void);
--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -565,6 +565,72 @@ void kgr_patch_remove(struct kgr_patch *
 }
 EXPORT_SYMBOL_GPL(kgr_patch_remove);
 
+#ifdef CONFIG_MODULES
+
+/*
+ * This function is called when new module is loaded but before it is used.
+ * Therefore it could set the fast path directly.
+ */
+static void kgr_handle_patch_for_loaded_module(struct kgr_patch *patch,
+					       const struct module *mod)
+{
+	struct kgr_patch_fun *patch_fun;
+	unsigned long addr;
+	int err;
+
+	kgr_for_each_patch_fun(patch, patch_fun) {
+		if (patch_fun->state != KGR_PATCH_SKIPPED)
+			continue;
+
+		addr =  kallsyms_lookup_name(patch_fun->name);
+		if (!within_module(addr, mod))
+			continue;
+
+		err = kgr_init_ftrace_ops(patch_fun);
+		if (err)
+			continue;
+
+		err = kgr_ftrace_enable(patch_fun, &patch_fun->ftrace_ops_fast);
+		if (err) {
+			pr_err("kgr: cannot enable ftrace function for the originally skipped %lx (%s)\n",
+			       patch_fun->loc_old, patch_fun->name);
+			continue;
+		}
+
+		patch_fun->state = KGR_PATCH_APPLIED;
+		pr_debug("kgr: fast redirection for %s done\n", patch_fun->name);
+	}
+}
+
+/**
+ * kgr_module_init -- apply skipped patches for newly loaded modules
+ *
+ * It must be called when symbols are visible to kallsyms but before the module
+ * init is called. Otherwise, it would not be able to use the fast stub.
+ */
+void kgr_module_init(const struct module *mod)
+{
+	struct kgr_patch *p;
+
+	/* early modules will be patched once KGraft is initialized */
+	if (!kgr_initialized)
+		return;
+
+	mutex_lock(&kgr_in_progress_lock);
+
+	/*
+	 * Check already applied patches for skipped functions. If there are
+	 * more patches we want to set them all. They need to be in place when
+	 * we remove some patch.
+	 */
+	list_for_each_entry(p, &kgr_patches, list)
+		kgr_handle_patch_for_loaded_module(p, mod);
+
+	mutex_unlock(&kgr_in_progress_lock);
+}
+
+#endif /* CONFIG_MODULES */
+
 static int __init kgr_init(void)
 {
 	int ret;
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -19,6 +19,7 @@
 #include <linux/export.h>
 #include <linux/moduleloader.h>
 #include <linux/ftrace_event.h>
+#include <linux/kgraft.h>
 #include <linux/init.h>
 #include <linux/kallsyms.h>
 #include <linux/file.h>
@@ -3386,6 +3387,15 @@ static int load_module(struct load_info
 	if (err)
 		goto ddebug_cleanup;
 
+#if IS_ENABLED(CONFIG_KGRAFT)
+	/*
+	 * kGraft patches should to be applied after symbols are visible
+	 * to kallsyms but before the module init is called. Then the
+	 * changes can be applied immediately.
+	 */
+	kgr_module_init(mod);
+#endif
+
 	/* Module is ready to execute: parsing args may do that. */
 	err = parse_args(mod->name, mod->args, mod->kp, mod->num_kp,
 			 -32768, 32767, unknown_module_param_cb);
