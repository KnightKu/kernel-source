From: Jiri Slaby <jslaby@suse.cz>
Date: Thu, 26 Jun 2014 13:39:37 +0200
Subject: kgr: add state machine to a patch
Patch-mainline: submitted for review
References: fate#313296

Switch 'applied' flag to an explicit state information. This will
make our life easier when adding support for reverts.

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 include/linux/kgraft.h |  8 +++++++-
 kernel/kgraft.c        | 27 +++++++++++++++++++++------
 2 files changed, 28 insertions(+), 7 deletions(-)

diff --git a/include/linux/kgraft.h b/include/linux/kgraft.h
index f2aeaa0f9c24..386f12d13dff 100644
--- a/include/linux/kgraft.h
+++ b/include/linux/kgraft.h
@@ -47,7 +47,13 @@ struct kgr_patch_fun {
 	void *new_fun;
 
 	bool abort_if_missing;
-	bool applied;
+	enum kgr_patch_state {
+		KGR_PATCH_INIT,
+		KGR_PATCH_SLOW,
+		KGR_PATCH_APPLIED,
+
+		KGR_PATCH_SKIPPED,
+	} state;
 
 	unsigned long loc_old;
 	unsigned long loc_new;
diff --git a/kernel/kgraft.c b/kernel/kgraft.c
index 4fae8da10e86..ca998c240159 100644
--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -274,21 +274,35 @@ static int kgr_init_ftrace_ops(struct kgr_patch_fun *patch_fun)
 static int kgr_patch_code(struct kgr_patch_fun *patch_fun, bool final)
 {
 	struct ftrace_ops *new_ops;
+	enum kgr_patch_state next_state;
 	int err;
 
+	switch (patch_fun->state) {
+	case KGR_PATCH_INIT:
+		next_state = KGR_PATCH_SLOW;
+		break;
+	case KGR_PATCH_SLOW:
+		next_state = KGR_PATCH_APPLIED;
+		break;
+	case KGR_PATCH_SKIPPED:
+		return 0;
+	default:
+		return -EINVAL;
+	}
+
 	/* Choose between slow and fast stub */
 	if (!final) {
 		err = kgr_init_ftrace_ops(patch_fun);
 		if (err) {
-			if (err == -ENOENT && !patch_fun->abort_if_missing)
+			if (err == -ENOENT && !patch_fun->abort_if_missing) {
+				patch_fun->state = KGR_PATCH_SKIPPED;
 				return 0;
+			}
 			return err;
 		}
 		pr_debug("kgr: patching %s to slow stub\n", patch_fun->name);
 		new_ops = &patch_fun->ftrace_ops_slow;
 	} else {
-		if (!patch_fun->applied)
-			return 0;
 		pr_debug("kgr: patching %s to fast stub\n", patch_fun->name);
 		new_ops = &patch_fun->ftrace_ops_fast;
 	}
@@ -314,8 +328,9 @@ static int kgr_patch_code(struct kgr_patch_fun *patch_fun, bool final)
 					patch_fun->name, err);
 			/* don't fail: we are only slower */
 		}
-	} else
-		patch_fun->applied = true;
+	}
+
+	patch_fun->state = next_state;
 
 	pr_debug("kgr: redirection for %s done\n", patch_fun->name);
 
@@ -371,7 +386,7 @@ int kgr_patch_kernel(struct kgr_patch *patch)
 		if (ret < 0) {
 			for (patch_fun--; patch_fun >= patch->patches;
 					patch_fun--)
-				if (patch_fun->applied)
+				if (patch_fun->state == KGR_PATCH_SLOW)
 					kgr_ftrace_disable(patch_fun,
 						&patch_fun->ftrace_ops_slow);
 			goto err_free;
-- 
2.0.4

