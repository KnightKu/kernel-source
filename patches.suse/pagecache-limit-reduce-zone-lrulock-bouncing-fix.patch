From: Michal Hocko <mhocko@suse.cz>
Subject: pagecachelimit: reduce lru_lock congestion for heavy parallel reclaim fix
References: bnc#895680
Patch-mainline: never

"pagecachelimit: reduce lru_lock contention for heavy parallel reclaim" has
introduced a memory corruption because the reclaim_state is not restored
properly when we break out from the page cache reclaim early (either due to
pending signals or nothing the reclaim on retry). This means that a stack
address leaks and at least slab might write to this address because it is not
NULL anymore and potentially corrupt a stack.

We have seen this happen when kmem_freepages (kfree slow path) triggered from
an IRQ context and clobbered user stack between mem_cgroup_cache_charge and
__mem_cgroup_try_charge when the provided memcg got overwritten from NULL to 1.

Signed-off-by: Michal Hocko <mhocko@suse.cz>

---
 mm/vmscan.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -3673,7 +3673,7 @@ retry:
 	 */
 	if (nr_pages <= 0 || fatal_signal_pending(current)) {
 		wake_up_interruptible(&pagecache_reclaim_wq);
-		return;
+		goto out;
 	}
 
 	/* But do a few at least */
