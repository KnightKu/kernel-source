From: "K. Y. Srinivasan" <kys@microsoft.com>
Date: Sat, 1 Dec 2012 06:46:47 -0800
Patch-mainline: v3.9-rc1
Subject: Drivers: hv: Setup a mapping for Hyper-V's notion cpu ID
Git-commit: 917ea427c78670958488f7f304e4629c325969a4
References: fate#314665

On win8 (ws2012), incoming vmbus interrupt load can be spread across all
available VCPUs in the guest. On a per-channel basis, the interrupts can
be bound to specific CPUs. The Linux notion of cpu ID may be different
from that of the hypervisor's. Setup a mapping structure.

Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Acked-by: <ohering@suse.de>
---
 drivers/hv/hv.c           | 11 +++++++++++
 drivers/hv/hyperv_vmbus.h | 10 ++++++++++
 2 files changed, 21 insertions(+)

diff --git a/drivers/hv/hv.c b/drivers/hv/hv.c
index dd0af89..76304a6 100644
--- a/drivers/hv/hv.c
+++ b/drivers/hv/hv.c
@@ -137,6 +137,8 @@ int hv_init(void)
 	memset(hv_context.synic_event_page, 0, sizeof(void *) * NR_CPUS);
 	memset(hv_context.synic_message_page, 0,
 	       sizeof(void *) * NR_CPUS);
+	memset(hv_context.vp_index, 0,
+	       sizeof(int) * NR_CPUS);
 
 	max_leaf = query_hypervisor_info();
 
@@ -296,6 +298,7 @@ void hv_synic_init(void *irqarg)
 	union hv_synic_siefp siefp;
 	union hv_synic_sint shared_sint;
 	union hv_synic_scontrol sctrl;
+	u64 vp_index;
 
 	u32 irq_vector = *((u32 *)(irqarg));
 	int cpu = smp_processor_id();
@@ -355,6 +358,14 @@ void hv_synic_init(void *irqarg)
 	wrmsrl(HV_X64_MSR_SCONTROL, sctrl.as_uint64);
 
 	hv_context.synic_initialized = true;
+
+	/*
+	 * Setup the mapping between Hyper-V's notion
+	 * of cpuid and Linux' notion of cpuid.
+	 * This array will be indexed using Linux cpuid.
+	 */
+	rdmsrl(HV_X64_MSR_VP_INDEX, vp_index);
+	hv_context.vp_index[cpu] = (u32)vp_index;
 	return;
 
 cleanup:
diff --git a/drivers/hv/hyperv_vmbus.h b/drivers/hv/hyperv_vmbus.h
index 1bc7500..6bbc197 100644
--- a/drivers/hv/hyperv_vmbus.h
+++ b/drivers/hv/hyperv_vmbus.h
@@ -502,6 +502,16 @@ struct hv_context {
 
 	void *synic_message_page[NR_CPUS];
 	void *synic_event_page[NR_CPUS];
+	/*
+	 * Hypervisor's notion of virtual processor ID is different from
+	 * Linux' notion of CPU ID. This information can only be retrieved
+	 * in the context of the calling CPU. Setup a map for easy access
+	 * to this information:
+	 *
+	 * vp_index[a] is the Hyper-V's processor ID corresponding to
+	 * Linux cpuid 'a'.
+	 */
+	u32 vp_index[NR_CPUS];
 };
 
 extern struct hv_context hv_context;
