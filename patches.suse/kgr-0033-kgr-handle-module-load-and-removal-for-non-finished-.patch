From: Petr Mladek <pmladek@suse.cz>
Date: Wed, 30 Jul 2014 11:34:14 +0200
Subject: kgr: handle module load and removal for non-finished patches
Patch-mainline: submitted for review
References: fate#313296

We need to be more careful when a module is modified by a patch in progress.
kgr_finalize() still needs to be called and it expects the slow stub.

This commit solves the module load by introducing another state
KGR_PATCH_APPLIED_NON_FINALIZED. It means that the fast stub is already
in place but the finalize has not been called for the entire patch yet.

Note that the patch is progress is not be applied when it is being removed.
There is nothing to add in this situation :-)

The module removal is easy. The target state is "KGR_PATCH_SKIPPED" and
it is ignored by kgr_finalize().

pm: do not mess error codes when patching modules (remove "err |=")

Signed-off-by: Petr Mladek <pmladek@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 include/linux/kgraft.h |  1 +
 kernel/kgraft.c        | 21 ++++++++++++++++++++-
 2 files changed, 21 insertions(+), 1 deletion(-)

diff --git a/include/linux/kgraft.h b/include/linux/kgraft.h
index 3ba1d0f439fa..178928b12108 100644
--- a/include/linux/kgraft.h
+++ b/include/linux/kgraft.h
@@ -59,6 +59,7 @@ struct kgr_patch_fun {
 		KGR_PATCH_REVERTED,
 
 		KGR_PATCH_SKIPPED,
+		KGR_PATCH_APPLIED_NON_FINALIZED,
 	} state;
 
 	unsigned long loc_name;
diff --git a/kernel/kgraft.c b/kernel/kgraft.c
index 13bb0a274b4f..f20c1b98a4f7 100644
--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -410,6 +410,12 @@ static int kgr_patch_code(struct kgr_patch_fun *patch_fun, bool final,
 		break;
 	case KGR_PATCH_SKIPPED:
 		return 0;
+	case KGR_PATCH_APPLIED_NON_FINALIZED:
+		/* like KGR_PATCH_SLOW but ops changes are already in place */
+		if (revert || !final)
+			return -EINVAL;
+		next_state = KGR_PATCH_APPLIED;
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -597,7 +603,11 @@ static void kgr_handle_patch_for_loaded_module(struct kgr_patch *patch,
 			continue;
 		}
 
-		patch_fun->state = KGR_PATCH_APPLIED;
+		if (patch == kgr_patch)
+			patch_fun->state = KGR_PATCH_APPLIED_NON_FINALIZED;
+		else
+			patch_fun->state = KGR_PATCH_APPLIED;
+
 		pr_debug("kgr: fast redirection for %s done\n", patch_fun->name);
 	}
 }
@@ -626,6 +636,10 @@ void kgr_module_init(const struct module *mod)
 	list_for_each_entry(p, &kgr_patches, list)
 		kgr_handle_patch_for_loaded_module(p, mod);
 
+	/* also check the patch in progress that is being applied */
+	if (kgr_patch && !kgr_revert)
+		kgr_handle_patch_for_loaded_module(kgr_patch, mod);
+
 	mutex_unlock(&kgr_in_progress_lock);
 }
 
@@ -649,6 +663,7 @@ static int kgr_forced_code_patch_removal(struct kgr_patch_fun *patch_fun)
 		ops = &patch_fun->ftrace_ops_slow;
 		break;
 	case KGR_PATCH_APPLIED:
+	case KGR_PATCH_APPLIED_NON_FINALIZED:
 		ops = &patch_fun->ftrace_ops_fast;
 		break;
 	default:
@@ -714,6 +729,10 @@ static void kgr_handle_going_module(const struct module *mod)
 	list_for_each_entry(p, &kgr_patches, list)
 		kgr_handle_patch_for_going_module(p, mod);
 
+	/* also check the patch in progress for removed functions */
+	if (kgr_patch)
+		kgr_handle_patch_for_going_module(kgr_patch, mod);
+
 	mutex_unlock(&kgr_in_progress_lock);
 }
 
-- 
2.1.0

