From: Borislav Petkov <bp@suse.de>
Date: Fri, 15 Dec 2017 19:56:13 +0100
Subject: x86/entry: Use IBRS on entry to kernel space
Patch-mainline: submitted on 2018/1/9
References: bsc#1068032

Toggle IBRS on entry to kernel space: enable *after* CR3 write and
disable *before* CR3 write.

Originally-by: Tim Chen <tim.c.chen@linux.intel.com>
Signed-off-by: Borislav Petkov <bp@suse.de>
---
 arch/x86/ia32/ia32entry.S  |   17 ++++++++++++++++-
 arch/x86/kernel/entry_64.S |   30 +++++++++++++++++++++++++++++-
 2 files changed, 45 insertions(+), 2 deletions(-)

--- a/arch/x86/ia32/ia32entry.S
+++ b/arch/x86/ia32/ia32entry.S
@@ -13,11 +13,11 @@
 #include <asm/thread_info.h>	
 #include <asm/segment.h>
 #include <asm/pgtable_types.h>
-#include <asm/alternative-asm.h>
 #include <asm/cpufeature.h>
 #include <asm/kaiser.h>
 #include <asm/irqflags.h>
 #include <linux/linkage.h>
+#include <asm/spec_ctrl.h>
 
 /* Avoid __ASSEMBLER__'ifying <linux/audit.h> just for this.  */
 #include <linux/elf-em.h>
@@ -148,6 +148,9 @@ ENTRY(ia32_sysenter_target)
 	CFI_REL_OFFSET rip,0
 	pushq_cfi %rax
 	cld
+
+	ENABLE_IBRS
+
 	SAVE_ARGS 0,0,1
  	/* no need to do an access_ok check here because rbp has been
  	   32bit zero extended */ 
@@ -190,6 +193,9 @@ sysexit_from_sys_call:
 	popq_cfi %rcx				/* User %esp */
 	CFI_REGISTER rsp,rcx
 	TRACE_IRQS_ON
+
+	DISABLE_IBRS
+
 	SWITCH_USER_CR3
 	ENABLE_INTERRUPTS_SYSEXIT32
 
@@ -313,6 +319,9 @@ ENTRY(ia32_cstar_target)
 	/*CFI_REL_OFFSET rflags,EFLAGS-ARGOFFSET*/
 	movq	%r8,RSP-ARGOFFSET(%rsp)	
 	CFI_REL_OFFSET rsp,RSP-ARGOFFSET
+
+	ENABLE_IBRS
+
 	/* no need to do an access_ok check here because r8 has been
 	   32bit zero extended */ 
 	/* hardware stack frame is complete now */	
@@ -350,6 +359,9 @@ sysretl_from_sys_call:
 	xorq	%r9,%r9
 	xorq	%r8,%r8
 	TRACE_IRQS_ON
+
+	DISABLE_IBRS
+
 	SWITCH_USER_CR3
 	movl RSP-ARGOFFSET(%rsp),%esp
 	CFI_RESTORE rsp
@@ -438,6 +450,9 @@ ENTRY(ia32_syscall)
 	GET_THREAD_INFO(%r10)
 	orl   $TS_COMPAT,TI_status(%r10)
 	testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%r10)
+
+	ENABLE_IBRS
+
 	jnz ia32_tracesys
 	cmpq $IA32_NR_syscalls,%rax
 	jae ia32_badsys
--- a/arch/x86/kernel/entry_64.S
+++ b/arch/x86/kernel/entry_64.S
@@ -55,9 +55,9 @@
 #include <asm/percpu.h>
 #include <asm/asm.h>
 #include <asm/pgtable_types.h>
-#include <asm/alternative-asm.h>
 #include <asm/cpufeature.h>
 #include <asm/kaiser.h>
+#include <asm/spec_ctrl.h>
 
 /* Avoid __ASSEMBLER__'ifying <linux/audit.h> just for this.  */
 #include <linux/elf-em.h>
@@ -332,6 +332,7 @@ ENTRY(save_args)
 	je 1f
 	SWAPGS
 	SWITCH_KERNEL_CR3
+	ENABLE_IBRS
 	/*
 	 * irq_count is used to check if a CPU is already on an interrupt stack
 	 * or not. While this is essentially redundant with preempt_count it is
@@ -421,6 +422,8 @@ ENTRY(save_paranoid)
 	movq	%rax, %cr3
 2:
 #endif
+
+	ENABLE_IBRS
 	ret
 	CFI_ENDPROC
 END(save_paranoid)
@@ -518,6 +521,9 @@ ENTRY(system_call_after_swapgs)
 	movq  %rcx,RIP-ARGOFFSET(%rsp)
 	CFI_REL_OFFSET rip,RIP-ARGOFFSET
 	GET_THREAD_INFO(%rcx)
+
+	ENABLE_IBRS
+
 	testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%rcx)
 	jnz tracesys
 system_call_fastpath:
@@ -552,6 +558,8 @@ sysret_check:
 	CFI_REGISTER	rip,rcx
 	RESTORE_ARGS 1,-ARG_SKIP,0
 	/*CFI_REGISTER	rflags,r11*/
+
+	DISABLE_IBRS
 	/*
 	 * This opens a window where we have a user CR3, but are
 	 * running in the kernel.  This makes using the CS
@@ -908,6 +916,9 @@ retint_swapgs:		/* return to user-space
 	 * switch CR3 in NMIs.  Normal interrupts are OK because
 	 * they are off here.
 	 */
+
+	DISABLE_IBRS
+
 	SWITCH_USER_CR3
 	SWAPGS
 	jmp restore_args
@@ -950,6 +961,9 @@ native_irq_return_ldt:
 	pushq_cfi %rdi
 	SWAPGS
 	SWITCH_KERNEL_CR3
+
+	ENABLE_IBRS
+
 	movq PER_CPU_VAR(espfix_waddr),%rdi
 	movq %rax,(0*8)(%rdi)	/* RAX */
 	movq (2*8)(%rsp),%rax	/* RIP */
@@ -965,6 +979,9 @@ native_irq_return_ldt:
 	andl $0xffff0000,%eax
 	popq_cfi %rdi
 	orq PER_CPU_VAR(espfix_stack),%rax
+
+	DISABLE_IBRS
+
 	SWITCH_USER_CR3
 	SWAPGS
 	movq %rax,%rsp
@@ -1516,6 +1533,9 @@ ENTRY(paranoid_exit)
 paranoid_kernel:
 	movq	%r12, %rbx		/* restore after paranoid_userspace */
 	TRACE_IRQS_IRETQ 0
+
+	DISABLE_IBRS
+
 #ifdef CONFIG_KAISER
 	/* No ALTERNATIVE for X86_FEATURE_KAISER: save_paranoid sets %ebx */
 	testl	$2, %ebx		/* SWITCH_USER_CR3 needed? */
@@ -1589,6 +1609,9 @@ ENTRY(error_entry)
 	 * the kernel CR3 here.
 	 */
 	SWITCH_KERNEL_CR3
+
+	ENABLE_IBRS
+
 	xorl %ebx,%ebx
 	testl $3,CS+8(%rsp)
 	je error_kernelspace
@@ -1736,6 +1759,7 @@ ENTRY(nmi)
 
 	SWAPGS_UNSAFE_STACK
 	SWITCH_KERNEL_CR3_NO_STACK
+
 	cld
 	movq	%rsp, %rdx
 	movq	PER_CPU_VAR(kernel_stack), %rsp
@@ -1762,6 +1786,8 @@ ENTRY(nmi)
 	pushq	%r14		/* pt_regs->r14 */
 	pushq	%r15		/* pt_regs->r15 */
 
+	ENABLE_IBRS
+
 	/*
 	 * At this point we no longer need to worry about stack damage
 	 * due to nesting -- we're on the normal thread stack and we're
@@ -1772,6 +1798,8 @@ ENTRY(nmi)
 	movq	$-1, %rsi
 	call	do_nmi
 
+	DISABLE_IBRS
+
 	/*
 	 * Return back to user mode.  We must *not* do the normal exit
 	 * work, because we don't want to enable interrupts.  Fortunately,
