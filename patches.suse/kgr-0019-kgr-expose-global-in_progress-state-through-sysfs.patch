From: Jiri Kosina <jkosina@suse.cz>
Date: Tue, 20 May 2014 15:32:04 +0200
Subject: kgr: expose global 'in_progress' state through sysfs
Patch-mainline: submitted for review
References: fate#313296

In addition to having a per-process flag that shows which processess have
already been "migrated", it's useful to have a global-wide flag that will
show whether the patching operation is currently undergoing without having
to traverse all /proc entries.

[v2]
Switch from procfs to sysfs as we want to have more entries there
later. So we create a one-entry attribute group and register it under
/sys/kernel/kgraft.

js: handle error
js: move to kgraft_files.c, there will be more of them, do not mess
    kgraft.c, i.e. the core

Reported-by: Libor Pechacek <lpechacek@suse.cz>
Signed-off-by: Jiri Kosina <jkosina@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 include/linux/kgraft.h |    4 ++
 kernel/Makefile        |    2 -
 kernel/kgraft.c        |   15 +++++++++-
 kernel/kgraft_files.c  |   67 +++++++++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 85 insertions(+), 3 deletions(-)
 create mode 100644 kernel/kgraft_files.c

--- a/include/linux/kgraft.h
+++ b/include/linux/kgraft.h
@@ -82,7 +82,11 @@ struct kgr_patch {
 	}
 #define KGR_PATCH_END				{ }
 
+extern bool kgr_in_progress;
+
 extern int kgr_patch_kernel(struct kgr_patch *);
+extern int kgr_add_files(void);
+extern void kgr_remove_files(void);
 
 static inline void kgr_mark_task_in_progress(struct task_struct *p)
 {
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -25,7 +25,7 @@ obj-y += printk/
 obj-y += cpu/
 obj-y += irq/
 
-obj-$(CONFIG_KGRAFT) += kgraft.o
+obj-$(CONFIG_KGRAFT) += kgraft.o kgraft_files.o
 obj-$(CONFIG_CHECKPOINT_RESTORE) += kcmp.o
 obj-$(CONFIG_FREEZER) += freezer.o
 obj-$(CONFIG_PROFILING) += profile.o
--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -33,7 +33,7 @@ static void kgr_work_fn(struct work_stru
 static struct workqueue_struct *kgr_wq;
 static DECLARE_DELAYED_WORK(kgr_work, kgr_work_fn);
 static DEFINE_MUTEX(kgr_in_progress_lock);
-static bool kgr_in_progress;
+bool kgr_in_progress;
 static bool kgr_initialized;
 static struct kgr_patch *kgr_patch;
 
@@ -399,20 +399,31 @@ EXPORT_SYMBOL_GPL(kgr_patch_kernel);
 
 static int __init kgr_init(void)
 {
+	int ret;
+
 	if (ftrace_is_dead()) {
 		pr_warn("kgr: enabled, but no fentry locations found ... aborting\n");
 		return -ENODEV;
 	}
 
+	ret = kgr_add_files();
+	if (ret)
+		return ret;
+
 	kgr_wq = create_singlethread_workqueue("kgraft");
 	if (!kgr_wq) {
 		pr_err("kgr: cannot allocate a work queue, aborting!\n");
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto err_remove_files;
 	}
 
 	kgr_initialized = true;
 	pr_info("kgr: successfully initialized\n");
 
 	return 0;
+err_remove_files:
+	kgr_remove_files();
+
+	return ret;
 }
 module_init(kgr_init);
--- /dev/null
+++ b/kernel/kgraft_files.c
@@ -0,0 +1,67 @@
+/*
+ * kGraft Online Kernel Patching
+ *
+ *  Copyright (c) 2013-2014 SUSE
+ *   Authors: Jiri Kosina
+ *	      Vojtech Pavlik
+ *	      Jiri Slaby
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/kgraft.h>
+#include <linux/kobject.h>
+#include <linux/sysfs.h>
+
+static struct kobject *kgr_sysfs_dir;
+
+static ssize_t in_progress_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", kgr_in_progress);
+}
+
+static struct kobj_attribute kgr_attr_in_progress = __ATTR_RO(in_progress);
+
+static struct attribute *kgr_sysfs_entries[] = {
+	&kgr_attr_in_progress.attr,
+	NULL
+};
+
+static struct attribute_group kgr_sysfs_group = {
+	.attrs = kgr_sysfs_entries,
+};
+
+int kgr_add_files(void)
+{
+	int ret;
+
+	kgr_sysfs_dir = kobject_create_and_add("kgraft", kernel_kobj);
+	if (!kgr_sysfs_dir) {
+		pr_err("kgr: cannot create kfraft directory in sysfs!\n");
+		return -EIO;
+	}
+
+	ret = sysfs_create_group(kgr_sysfs_dir, &kgr_sysfs_group);
+	if (ret) {
+		pr_err("kgr: cannot create attributes in sysfs\n");
+		goto err_put_sysfs;
+	}
+
+	return 0;
+err_put_sysfs:
+	kobject_put(kgr_sysfs_dir);
+	return ret;
+}
+
+void kgr_remove_files(void)
+{
+	sysfs_remove_group(kgr_sysfs_dir, &kgr_sysfs_group);
+	kobject_put(kgr_sysfs_dir);
+}
