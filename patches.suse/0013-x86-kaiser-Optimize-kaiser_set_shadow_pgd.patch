From 85e849efa6b3e2b0ccdc552718cc8f2969bfba0f Mon Sep 17 00:00:00 2001
From: Joerg Roedel <jroedel@suse.de>
Date: Tue, 13 Mar 2018 15:47:00 +0100
Subject: [PATCH 13/17] x86/kaiser: Optimize kaiser_set_shadow_pgd()
References: bsc#1068032 CVE-2017-5754
Patch-mainline: No, different upstream implementation

Rewrite the logic in a way that it also works on 32 bit.

Signed-off-by: Joerg Roedel <jroedel@suse.de>
---
 arch/x86/mm/kaiser.c | 42 +++++++++++++++++++++++++++---------------
 1 file changed, 27 insertions(+), 15 deletions(-)

diff --git a/arch/x86/mm/kaiser.c b/arch/x86/mm/kaiser.c
index a547ea9..00f2d41 100644
--- a/arch/x86/mm/kaiser.c
+++ b/arch/x86/mm/kaiser.c
@@ -404,38 +404,50 @@ void kaiser_remove_mapping(unsigned long start, unsigned long size)
  */
 static inline bool is_userspace_pgd(pgd_t *pgdp)
 {
-	return ((unsigned long)pgdp % PAGE_SIZE) < (PAGE_SIZE / 2);
+	unsigned long ptr = (unsigned long)pgdp;
+
+	return (((ptr % PAGE_SIZE) / sizeof(pgd_t)) < KERNEL_PGD_BOUNDARY);
+}
+
+static void kaiser_set_pgd(pgd_t *pgdp, pgd_t pgd)
+{
+#ifdef CONFIG_X86_PAE
+	set_64bit((unsigned long long *)(pgdp), native_pgd_val(pgd));
+#else
+	pgdp->pgd = pgd.pgd;
+#endif
 }
 
 pgd_t kaiser_set_shadow_pgd(pgd_t *pgdp, pgd_t pgd)
 {
 	if (!kaiser_enabled)
 		return pgd;
+
+	if (!is_userspace_pgd(pgdp))
+		return pgd;
+
+	kaiser_set_pgd(native_get_shadow_pgd(pgdp), pgd);
+
 	/*
 	 * Do we need to also populate the shadow pgd?  Check _PAGE_USER to
 	 * skip cases like kexec and EFI which make temporary low mappings.
 	 */
 	if (pgd.pgd & _PAGE_USER) {
-		if (is_userspace_pgd(pgdp)) {
-			native_get_shadow_pgd(pgdp)->pgd = pgd.pgd;
-			/*
-			 * Even if the entry is *mapping* userspace, ensure
-			 * that userspace can not use it.  This way, if we
-			 * get out to userspace running on the kernel CR3,
-			 * userspace will crash instead of running.
-			 */
-			if (__supported_pte_mask & _PAGE_NX)
-				pgd.pgd |= _PAGE_NX;
-		}
+		/*
+		 * Even if the entry is *mapping* userspace, ensure
+		 * that userspace can not use it.  This way, if we
+		 * get out to userspace running on the kernel CR3,
+		 * userspace will crash instead of running.
+		 */
+		if (__supported_pte_mask & _PAGE_NX)
+			pgd.pgd |= _PAGE_NX;
 	} else if (!pgd.pgd) {
 		/*
 		 * pgd_clear() cannot check _PAGE_USER, and is even used to
 		 * clear corrupted pgd entries: so just rely on cases like
 		 * kexec and EFI never to be using pgd_clear().
 		 */
-		if (!WARN_ON_ONCE((unsigned long)pgdp & PAGE_SIZE) &&
-		    is_userspace_pgd(pgdp))
-			native_get_shadow_pgd(pgdp)->pgd = pgd.pgd;
+		WARN_ON_ONCE((unsigned long)pgdp & PAGE_SIZE);
 	}
 	return pgd;
 }
-- 
1.8.5.6

