From: Jiri Slaby <jslaby@suse.cz>
Date: Tue, 13 May 2014 18:02:52 +0200
Subject: kgr: add support for missing functions
Patch-mainline: submitted for review
References: fate#313296

Sometimes we want to patch a function which is in a module that is not
currently loaded. In that case, patching would fail completely. So let
the user decide whether it is fatal when the function to be patched is
not found. If it is not, it is just skipped.  Other functions in the
patch (if any) are still patched in that case.

Note that this approach expects newly loaded modules to be fixed
already. No "deferred" patching happens on the module load.

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 include/linux/kgraft.h          |  6 +++++-
 kernel/kgraft.c                 | 14 +++++++++++---
 samples/kgraft/kgraft_patcher.c |  4 ++--
 3 files changed, 18 insertions(+), 6 deletions(-)

diff --git a/include/linux/kgraft.h b/include/linux/kgraft.h
index 987a1cd7f07e..bcd4ffa3076e 100644
--- a/include/linux/kgraft.h
+++ b/include/linux/kgraft.h
@@ -46,6 +46,9 @@ struct kgr_patch_fun {
 	const char *name;
 	void *new_fun;
 
+	bool abort_if_missing;
+	bool applied;
+
 	unsigned long loc_old;
 	unsigned long loc_new;
 
@@ -72,9 +75,10 @@ struct kgr_patch {
 #define kgr_for_each_patch_fun(p, pf)	\
 	for (pf = p->patches; pf->name; pf++)
 
-#define KGR_PATCH(_name, _new_function)		{			\
+#define KGR_PATCH(_name, _new_function, abort)	{			\
 		.name = #_name,						\
 		.new_fun = _new_function,				\
+		.abort_if_missing = abort,				\
 	}
 #define KGR_PATCH_END				{ }
 
diff --git a/kernel/kgraft.c b/kernel/kgraft.c
index 79340e9c3aab..ce52cf62e129 100644
--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -268,11 +268,16 @@ static int kgr_patch_code(struct kgr_patch_fun *patch_fun, bool final)
 	/* Choose between slow and fast stub */
 	if (!final) {
 		err = kgr_init_ftrace_ops(patch_fun);
-		if (err)
+		if (err) {
+			if (err == -ENOENT && !patch_fun->abort_if_missing)
+				return 0;
 			return err;
+		}
 		pr_debug("kgr: patching %s to slow stub\n", patch_fun->name);
 		new_ops = &patch_fun->ftrace_ops_slow;
 	} else {
+		if (!patch_fun->applied)
+			return 0;
 		pr_debug("kgr: patching %s to fast stub\n", patch_fun->name);
 		new_ops = &patch_fun->ftrace_ops_fast;
 	}
@@ -298,7 +303,9 @@ static int kgr_patch_code(struct kgr_patch_fun *patch_fun, bool final)
 					patch_fun->name, err);
 			/* don't fail: we are only slower */
 		}
-	}
+	} else
+		patch_fun->applied = true;
+
 	pr_debug("kgr: redirection for %s done\n", patch_fun->name);
 
 	return 0;
@@ -351,7 +358,8 @@ int kgr_patch_kernel(struct kgr_patch *patch)
 		if (ret < 0) {
 			for (patch_fun--; patch_fun >= patch->patches;
 					patch_fun--)
-				kgr_ftrace_disable(patch_fun,
+				if (patch_fun->applied)
+					kgr_ftrace_disable(patch_fun,
 						&patch_fun->ftrace_ops_slow);
 			goto err_free;
 		}
diff --git a/samples/kgraft/kgraft_patcher.c b/samples/kgraft/kgraft_patcher.c
index 5a0ff97ee773..4a7070344f4e 100644
--- a/samples/kgraft/kgraft_patcher.c
+++ b/samples/kgraft/kgraft_patcher.c
@@ -66,9 +66,9 @@ static struct kgr_patch patch = {
 	.owner = THIS_MODULE,
 	.patches = {
 #if defined(CONFIG_X86)
-		KGR_PATCH(SyS_iopl, kgr_new_sys_iopl),
+		KGR_PATCH(SyS_iopl, kgr_new_sys_iopl, true),
 #endif
-		KGR_PATCH(capable, kgr_new_capable),
+		KGR_PATCH(capable, kgr_new_capable, true),
 		KGR_PATCH_END
 	}
 };
-- 
2.0.1

