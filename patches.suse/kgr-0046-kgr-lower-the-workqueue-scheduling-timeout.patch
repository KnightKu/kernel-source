From: Jiri Kosina <jkosina@suse.cz>
Date: Wed, 12 Nov 2014 15:43:16 +0100
Subject: kgr: lower the workqueue scheduling timeout
Patch-mainline: submitted for review
References: fate#313296 bnc#905087

After a 'kgr poke', one has to wait 30s before the next patch can be
applied. The tools do not take that into account. As a workaround, I'm
going to add a busy wait to the %pre script, but the timeout should be
reduced to something more reasonable.

This use case uis quite realistic:
1) Admin applies patch1, forgets to check the progress
2) Admin applies patch2, this fails, because some tasks are still sleeping in
   the old universe
3) Admin does 'kgr poke' to wake them up
4) Admin applies patch2, this takes 30 more seconds to actually start doing
   anything (currently, it fails)

(quote from bsc#905087)

Fix this by lowering the timeout to 2 seconds. The overhead this adds
should be negligible -- we are scheduling the workqueue only if the
patching is still in progress, and the only thing that workqueue handler
does is that it walks the list of existing processess.

While at it, make the "still patching" message appear only once per
patching (it will be followed by "succeeded" message later, so the fact
that the patching hasn't been finalized yet will be obvious from dmesg
anyway) to avoid excessive spamming of the kernel log.

Signed-off-by: Jiri Kosina <jkosina@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 include/linux/kgraft.h |  2 +-
 kernel/kgraft.c        | 13 ++++++++++---
 2 files changed, 11 insertions(+), 4 deletions(-)

diff --git a/include/linux/kgraft.h b/include/linux/kgraft.h
index f9f88e4c2134..9250abd74a3d 100644
--- a/include/linux/kgraft.h
+++ b/include/linux/kgraft.h
@@ -28,7 +28,7 @@
 
 #include <asm/kgraft.h>
 
-#define KGR_TIMEOUT 30
+#define KGR_TIMEOUT 2
 
 struct kgr_patch;
 
diff --git a/kernel/kgraft.c b/kernel/kgraft.c
index ccb497946abe..957078ea426d 100644
--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -277,9 +277,15 @@ static void kgr_finalize(void)
 
 static void kgr_work_fn(struct work_struct *work)
 {
+	static bool printed = false;
+
 	if (kgr_still_patching()) {
-		pr_info("kgr still in progress after timeout (%d)\n",
-			KGR_TIMEOUT);
+		if (!printed) {
+			pr_info("kgr still in progress after timeout, will keep"
+					" trying every %d seconds\n",
+				KGR_TIMEOUT);
+			printed = true;
+		}
 		/* recheck again later */
 		queue_delayed_work(kgr_wq, &kgr_work, KGR_TIMEOUT * HZ);
 		return;
@@ -290,6 +296,7 @@ static void kgr_work_fn(struct work_struct *work)
 	 * with as less performance impact as possible again
 	 */
 	kgr_finalize();
+	printed = false;
 }
 
 void kgr_unmark_processes(void)
@@ -649,7 +656,7 @@ int kgr_modify_kernel(struct kgr_patch *patch, bool revert, bool force)
 		/*
 		 * give everyone time to exit kernel, and check after a while
 		 */
-		queue_delayed_work(kgr_wq, &kgr_work, 10 * HZ);
+		queue_delayed_work(kgr_wq, &kgr_work, KGR_TIMEOUT * HZ);
 	}
 
 	return 0;
-- 
2.1.3

