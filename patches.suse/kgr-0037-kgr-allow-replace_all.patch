From: Jiri Slaby <jslaby@suse.cz>
Date: Wed, 9 Jul 2014 10:12:40 +0200
Subject: kgr: allow replace_all
Patch-mainline: submitted for review
References: fate#313296

We may want load a single patch on the top of others which will
replace all of them atomically. As a result we have only a single
patch applied and all previous modules can be unloaded.

It works as follows:
* all patches and its patch_funs are walked
* if a patch_fun's function is contained in the new patch, it is
  moved to the new one, using the slow stub
* if it is not, the patch_fun is reverted

This way, all patch_funs are reverted sequentially. After parallel
patching is implemented, we can get rid of the kgr_to_revert list and
dump all the previous patches to be reverted just to the running
patching.

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 include/linux/kgraft.h |  4 ++-
 kernel/kgraft.c        | 83 +++++++++++++++++++++++++++++++++++++++++++++++---
 kernel/kgraft_files.c  | 12 +++++++-
 3 files changed, 92 insertions(+), 7 deletions(-)

diff --git a/include/linux/kgraft.h b/include/linux/kgraft.h
index 178928b12108..30701157cd4b 100644
--- a/include/linux/kgraft.h
+++ b/include/linux/kgraft.h
@@ -80,6 +80,7 @@ struct kgr_patch_fun {
  * @refs: how many patches need to be reverted before this one
  * @name: name of the patch (to appear in sysfs)
  * @owner: module to refcount on patching
+ * @replace_all: revert everything applied before and apply this one instead
  * @patches: array of @kgr_patch_fun structures
  */
 struct kgr_patch {
@@ -93,6 +94,7 @@ struct kgr_patch {
 	/* a patch shall set these */
 	const char *name;
 	struct module *owner;
+	bool replace_all;
 	struct kgr_patch_fun patches[];
 };
 
@@ -111,7 +113,7 @@ extern bool kgr_in_progress;
 extern int kgr_patch_kernel(struct kgr_patch *);
 extern void kgr_patch_remove(struct kgr_patch *);
 
-extern int kgr_modify_kernel(struct kgr_patch *patch, bool revert);
+extern int kgr_modify_kernel(struct kgr_patch *patch, bool revert, bool force);
 extern void kgr_module_init(const struct module *mod);
 extern int kgr_patch_dir_add(struct kgr_patch *patch);
 extern void kgr_patch_dir_del(struct kgr_patch *patch);
diff --git a/kernel/kgraft.c b/kernel/kgraft.c
index 090ba05ee49c..64603d7ee487 100644
--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -36,6 +36,7 @@ static struct workqueue_struct *kgr_wq;
 static DECLARE_DELAYED_WORK(kgr_work, kgr_work_fn);
 static DEFINE_MUTEX(kgr_in_progress_lock);
 static LIST_HEAD(kgr_patches);
+static LIST_HEAD(kgr_to_revert);
 bool kgr_in_progress;
 static bool kgr_initialized;
 static struct kgr_patch *kgr_patch;
@@ -141,9 +142,52 @@ static bool kgr_still_patching(void)
 	return failed;
 }
 
+static bool kgr_patch_contains(const struct kgr_patch *p, const char *name)
+{
+	const struct kgr_patch_fun *pf;
+
+	kgr_for_each_patch_fun(p, pf)
+		if (!strcmp(pf->name, name))
+			return true;
+
+	return false;
+}
+
+static void kgr_replace_all(void)
+{
+	struct kgr_patch_fun *pf;
+	struct kgr_patch *p, *tmp;
+
+	list_for_each_entry_safe(p, tmp, &kgr_patches, list) {
+		bool needs_revert = false;
+
+		kgr_for_each_patch_fun(p, pf) {
+			if (pf->state != KGR_PATCH_APPLIED)
+				continue;
+
+			if (!kgr_patch_contains(kgr_patch, pf->name)) {
+				needs_revert = true;
+				continue;
+			}
+
+			/* the fast ftrace fops were disabled during patching */
+			pf->state = KGR_PATCH_REVERTED;
+		}
+
+		/* decrease the reference this patch increased earlier */
+		p->refs--;
+
+		if (needs_revert)
+			list_move(&p->list, &kgr_to_revert);
+		else
+			module_put(p->owner);
+	}
+}
+
 static void kgr_finalize(void)
 {
 	struct kgr_patch_fun *patch_fun;
+	struct kgr_patch *p_to_revert = NULL;
 
 	mutex_lock(&kgr_in_progress_lock);
 
@@ -160,13 +204,32 @@ static void kgr_finalize(void)
 	if (kgr_revert) {
 		kgr_refs_dec();
 		module_put(kgr_patch->owner);
-	} else
+	} else {
+		if (kgr_patch->replace_all)
+			kgr_replace_all();
 		list_add_tail(&kgr_patch->list, &kgr_patches);
+	}
 
 	kgr_patch = NULL;
-	kgr_in_progress = false;
+	if (list_empty(&kgr_to_revert)) {
+		kgr_in_progress = false;
+	} else {
+		/*
+		 * kgr_in_progress is not cleared to avoid races after the
+		 * unlock below. The force flag is set instead.
+		 */
+		p_to_revert = list_first_entry(&kgr_to_revert, struct kgr_patch,
+				list);
+	}
 
 	mutex_unlock(&kgr_in_progress_lock);
+
+	if (p_to_revert) {
+		int ret = kgr_modify_kernel(p_to_revert, true, true);
+		if (ret)
+			pr_err("kgr: continual revert of %s failedwith %d, but continuing\n",
+					p_to_revert->name, ret);
+	}
 }
 
 static void kgr_work_fn(struct work_struct *work)
@@ -407,6 +470,10 @@ static int kgr_patch_code(struct kgr_patch_fun *patch_fun, bool final,
 		 */
 		new_ops = kgr_get_old_fops(patch_fun);
 		break;
+	case KGR_PATCH_REVERTED:
+		if (!revert || final)
+			return -EINVAL;
+		return 0;
 	case KGR_PATCH_SKIPPED:
 		return 0;
 	case KGR_PATCH_APPLIED_NON_FINALIZED:
@@ -450,7 +517,13 @@ static int kgr_patch_code(struct kgr_patch_fun *patch_fun, bool final,
 	return 0;
 }
 
-int kgr_modify_kernel(struct kgr_patch *patch, bool revert)
+/**
+ * kgr_modify_kernel -- apply or revert a patch
+ * @patch: patch to deal with
+ * @revert: if @patch should be reverted, set to true
+ * @force: if kgr_in_progress should be ignored, set to true (internal use)
+ */
+int kgr_modify_kernel(struct kgr_patch *patch, bool revert, bool force)
 {
 	struct kgr_patch_fun *patch_fun;
 	int ret;
@@ -467,7 +540,7 @@ int kgr_modify_kernel(struct kgr_patch *patch, bool revert)
 		goto err_unlock;
 	}
 
-	if (kgr_in_progress) {
+	if (!force && (kgr_in_progress || !list_empty(&kgr_to_revert))) {
 		pr_err("kgr: can't patch, another patching not yet finalized\n");
 		ret = -EAGAIN;
 		goto err_unlock;
@@ -547,7 +620,7 @@ int kgr_patch_kernel(struct kgr_patch *patch)
 	if (ret)
 		goto err_put;
 
-	ret = kgr_modify_kernel(patch, false);
+	ret = kgr_modify_kernel(patch, false, false);
 	if (ret)
 		goto err_dir_del;
 
diff --git a/kernel/kgraft_files.c b/kernel/kgraft_files.c
index 5e2da03d3a1f..0a39c2434d70 100644
--- a/kernel/kgraft_files.c
+++ b/kernel/kgraft_files.c
@@ -65,24 +65,34 @@ static ssize_t refs_show(struct kobject *kobj, struct kobj_attribute *attr,
 	return snprintf(buf, PAGE_SIZE, "%d\n", p->refs);
 }
 
+static ssize_t replace_all_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	struct kgr_patch *p = kobj_to_patch(kobj);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", p->replace_all);
+}
+
 static ssize_t revert_store(struct kobject *kobj,
 		struct kobj_attribute *attr, const char *buf, size_t count)
 {
 	struct kgr_patch *p = kobj_to_patch(kobj);
 	int ret;
 
-	ret = kgr_modify_kernel(p, true);
+	ret = kgr_modify_kernel(p, true, false);
 
 	return ret < 0 ? ret : count;
 }
 
 static struct kobj_attribute kgr_attr_state = __ATTR_RO(state);
 static struct kobj_attribute kgr_attr_refs = __ATTR_RO(refs);
+static struct kobj_attribute kgr_attr_replace_all = __ATTR_RO(replace_all);
 static struct kobj_attribute kgr_attr_revert = __ATTR_WO(revert);
 
 static struct attribute *kgr_patch_sysfs_entries[] = {
 	&kgr_attr_state.attr,
 	&kgr_attr_refs.attr,
+	&kgr_attr_replace_all.attr,
 	&kgr_attr_revert.attr,
 	NULL
 };
-- 
2.1.0

