From: Miroslav Benes <mbenes@suse.cz>
Date: Mon, 30 Mar 2015 15:47:35 +0200
Subject: kgr: take switching of the fops out of kgr_patch_code to new function
Patch-mainline: submitted for review
References: fate#313296

There is switching of the ftrace_ops in kgr_patch_code. New_ops are
enabled and the old ones disabled afterwards. Lets put it into the new
function kgr_switch_fops.

Also we change the error handling a bit. Currently we do not return
error if unregistration of the ftrace stub fails in kgr_patch_code
function. The process proceeds and the user is warned. However the
system gets to very suspicious state, because the ftrace stub could
still be there or not at all. There is nothing we can do about it, so we
better BUG here.

Signed-off-by: Miroslav Benes <mbenes@suse.cz>
Reviewed-by: Petr Mladek <pmladek@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 kernel/kgraft.c |   64 +++++++++++++++++++++++++++++++++++++-------------------
 1 file changed, 43 insertions(+), 21 deletions(-)

--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -28,6 +28,7 @@
 #include <linux/spinlock.h>
 #include <linux/types.h>
 #include <linux/workqueue.h>
+#include <linux/bug.h>
 
 static int kgr_patch_code(struct kgr_patch_fun *patch_fun, bool final,
 		bool revert, bool replace_revert);
@@ -473,6 +474,43 @@ kgr_get_old_fops(const struct kgr_patch_
 	return pf ? &pf->ftrace_ops_fast : NULL;
 }
 
+static int kgr_switch_fops(struct kgr_patch_fun *patch_fun,
+		struct ftrace_ops *new_fops, struct ftrace_ops *unreg_fops)
+{
+	int err;
+
+	if (new_fops) {
+		err = kgr_ftrace_enable(patch_fun, new_fops);
+		if (err) {
+			pr_err("kgr: cannot enable ftrace function for %s (%lx, %d)\n",
+				patch_fun->name, patch_fun->loc_old, err);
+			return err;
+		}
+	}
+
+	/*
+	 * Get rid of the other stub. Having two stubs in the interim is fine.
+	 * The first one registered always "wins", as it'll be dragged last from
+	 * the ftrace hashtable. The redirected RIP however currently points to
+	 * the same function in both stubs.
+	 */
+	if (unreg_fops) {
+		err = kgr_ftrace_disable(patch_fun, unreg_fops);
+		if (err) {
+			pr_err("kgr: disabling ftrace function for %s failed (%d)\n",
+				patch_fun->name, err);
+			/*
+			 * In case of failure we do not know which state we are
+			 * in. There is something wrong going on in kGraft of
+			 * ftrace, so better BUG.
+			 */
+			BUG();
+		}
+	}
+
+	return 0;
+}
+
 static int kgr_init_ftrace_ops(struct kgr_patch_fun *patch_fun)
 {
 	struct ftrace_ops *fops;
@@ -603,29 +641,13 @@ static int kgr_patch_code(struct kgr_pat
 		return -EINVAL;
 	}
 
-	if (new_ops) {
-		/* Flip the switch */
-		err = kgr_ftrace_enable(patch_fun, new_ops);
-		if (err) {
-			pr_err("kgr: cannot enable ftrace function for %lx (%s)\n",
-					patch_fun->loc_old, patch_fun->name);
-			return err;
-		}
-	}
-
 	/*
-	 * Get rid of the slow stub. Having two stubs in the interim is fine,
-	 * the last one always "wins", as it'll be dragged earlier from the
-	 * ftrace hashtable
+	 * In case of error the caller can still have a chance to restore the
+	 * previous consistent state.
 	 */
-	if (unreg_ops) {
-		err = kgr_ftrace_disable(patch_fun, unreg_ops);
-		if (err) {
-			pr_warning("kgr: disabling ftrace function for %s failed with %d\n",
-					patch_fun->name, err);
-			/* don't fail: we are only slower */
-		}
-	}
+	err = kgr_switch_fops(patch_fun, new_ops, unreg_ops);
+	if (err)
+		return err;
 
 	patch_fun->state = next_state;
 
