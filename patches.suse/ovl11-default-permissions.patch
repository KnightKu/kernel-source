From: Miklos Szeredi <mszeredi@suse.cz>
Date: Thu, 2 Jul 2015 15:36:33 +0200
Subject: ovl: default permissions
Patch-mainline: no
References: bsc#924071

Add mount option "default_permissions" to alter the way permissions are
calculated.

Without this option and prior to this patch permissions were calculated by
underlying lower or upper filesystem.

With this option the permissions are calculated by overlayfs based on the
file owner, group and mode bits.

This has significance for example when a read-only exported NFS filesystem
is used as a lower layer.  In this case the underlying NFS filesystem will
reply with EROFS, in which case all we know is that the filesystem is
read-only.  But that's not what we are interested in, we are interested in
whether the access would be allowed if the filesystem wasn't read-only; the
server doesn't tell us that, and would need updating at various levels,
which doesn't seem practicable.

Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
---
 fs/overlayfs-old/inode.c     |   23 +++++++++++++++++++++++
 fs/overlayfs-old/overlayfs.h |    3 +++
 fs/overlayfs-old/super.c     |   24 ++++++++++++++++++++++++
 3 files changed, 50 insertions(+)
--- a/fs/overlayfs-old/inode.c
+++ b/fs/overlayfs-old/inode.c
@@ -74,6 +74,29 @@ int ovl_permission(struct inode *inode,
 
 	realdentry = ovl_entry_real(oe, &is_upper);
 
+	if (ovl_is_default_permissions(inode)) {
+		struct kstat stat;
+		struct path realpath = { .dentry = realdentry };
+
+		if (mask & MAY_NOT_BLOCK)
+			return -ECHILD;
+
+		realpath.mnt = ovl_entry_mnt_real(oe, inode, is_upper);
+
+		err = vfs_getattr(&realpath, &stat);
+		if (err)
+			return err;
+
+		if ((stat.mode ^ inode->i_mode) & S_IFMT)
+			return -ESTALE;
+
+		inode->i_mode = stat.mode;
+		inode->i_uid = stat.uid;
+		inode->i_gid = stat.gid;
+
+		return generic_permission(inode, mask);
+	}
+
 	/* Careful in RCU walk mode */
 	realinode = ACCESS_ONCE(realdentry->d_inode);
 	if (!realinode) {
--- a/fs/overlayfs-old/overlayfs.h
+++ b/fs/overlayfs-old/overlayfs.h
@@ -29,6 +29,9 @@ struct dentry *ovl_dentry_upper(struct d
 struct dentry *ovl_dentry_lower(struct dentry *dentry);
 struct dentry *ovl_dentry_real(struct dentry *dentry);
 struct dentry *ovl_entry_real(struct ovl_entry *oe, bool *is_upper);
+struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,
+				    bool is_upper);
+bool ovl_is_default_permissions(struct inode *inode);
 bool ovl_dentry_is_opaque(struct dentry *dentry);
 void ovl_dentry_set_opaque(struct dentry *dentry, bool opaque);
 bool ovl_is_whiteout(struct dentry *dentry);
--- a/fs/overlayfs-old/super.c
+++ b/fs/overlayfs-old/super.c
@@ -30,6 +30,7 @@ MODULE_LICENSE("GPL");
 struct ovl_config {
 	char *lowerdir;
 	char *upperdir;
+	bool default_permissions;
 };
 
 /* private information held for overlayfs's superblock */
@@ -154,6 +155,21 @@ struct dentry *ovl_entry_real(struct ovl
 	return realdentry;
 }
 
+struct vfsmount *ovl_entry_mnt_real(struct ovl_entry *oe, struct inode *inode,
+				    bool is_upper)
+{
+	struct ovl_fs *ofs = inode->i_sb->s_fs_info;
+
+	return is_upper ? ofs->upper_mnt : ofs->lower_mnt;
+}
+
+bool ovl_is_default_permissions(struct inode *inode)
+{
+	struct ovl_fs *ofs = inode->i_sb->s_fs_info;
+
+	return ofs->config.default_permissions;
+}
+
 bool ovl_dentry_is_opaque(struct dentry *dentry)
 {
 	struct ovl_entry *oe = dentry->d_fsdata;
@@ -461,6 +477,8 @@ static int ovl_show_options(struct seq_f
 
 	seq_printf(m, ",lowerdir=%s", ufs->config.lowerdir);
 	seq_printf(m, ",upperdir=%s", ufs->config.upperdir);
+	if (ufs->config.default_permissions)
+		seq_puts(m, ",default_permissions");
 	return 0;
 }
 
@@ -474,12 +492,14 @@ static const struct super_operations ovl
 enum {
 	OPT_LOWERDIR,
 	OPT_UPPERDIR,
+	OPT_DEFAULT_PERMISSIONS,
 	OPT_ERR,
 };
 
 static const match_table_t ovl_tokens = {
 	{OPT_LOWERDIR,			"lowerdir=%s"},
 	{OPT_UPPERDIR,			"upperdir=%s"},
+	{OPT_DEFAULT_PERMISSIONS,	"default_permissions"},
 	{OPT_ERR,			NULL}
 };
 
@@ -513,6 +533,10 @@ static int ovl_parse_opt(char *opt, stru
 				return -ENOMEM;
 			break;
 
+		case OPT_DEFAULT_PERMISSIONS:
+			config->default_permissions = true;
+			break;
+
 		default:
 			return -EINVAL;
 		}
