From: Petr Mladek <pmladek@suse.cz>
Date: Thu, 18 Dec 2014 17:15:38 +0100
Subject: kgr: unregister only the used ftrace ops when removing a patched
 module
Patch-mainline: submitted for review
References: fate#313296

The module going handling is broken. It tries to remove ftrace
ops from all patches that are in KGR_PATCH_APPLIED state.
But we need to do it only for the last patch that has the ftrace
ops registered.

Signed-off-by: Petr Mladek <pmladek@suse.cz>
Reviewed-by: Jiri Kosina <jkosina@suse.cz>
Reviewed-by: Miroslav Benes <mbenes@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 kernel/kgraft.c | 20 ++++++++++++--------
 1 file changed, 12 insertions(+), 8 deletions(-)

diff --git a/kernel/kgraft.c b/kernel/kgraft.c
index d126f210c22e..e4e5f1939371 100644
--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -907,7 +907,7 @@ void kgr_module_init(const struct module *mod)
  */
 static int kgr_forced_code_patch_removal(struct kgr_patch_fun *patch_fun)
 {
-	struct ftrace_ops *ops;
+	struct ftrace_ops *ops = NULL;
 	int err;
 
 	switch (patch_fun->state) {
@@ -916,20 +916,24 @@ static int kgr_forced_code_patch_removal(struct kgr_patch_fun *patch_fun)
 		return 0;
 	case KGR_PATCH_SLOW:
 	case KGR_PATCH_REVERT_SLOW:
-		ops = &patch_fun->ftrace_ops_slow;
+		if (kgr_is_patch_fun(patch_fun, KGR_LAST_EXISTING))
+			ops = &patch_fun->ftrace_ops_slow;
 		break;
 	case KGR_PATCH_APPLIED:
-		ops = &patch_fun->ftrace_ops_fast;
+		if (kgr_is_patch_fun(patch_fun, KGR_LAST_EXISTING))
+			ops = &patch_fun->ftrace_ops_fast;
 		break;
 	default:
 		return -EINVAL;
 	}
 
-	err = kgr_ftrace_disable(patch_fun, ops);
-	if (err) {
-		pr_warn("kgr: forced disabling of ftrace function for %s failed with %d\n",
-			patch_fun->name, err);
-		return err;
+	if (ops) {
+		err = kgr_ftrace_disable(patch_fun, ops);
+		if (err) {
+			pr_warn("kgr: forced disabling of ftrace function for %s failed with %d\n",
+				patch_fun->name, err);
+			return err;
+		}
 	}
 
 	patch_fun->state = KGR_PATCH_SKIPPED;
-- 
2.2.1

