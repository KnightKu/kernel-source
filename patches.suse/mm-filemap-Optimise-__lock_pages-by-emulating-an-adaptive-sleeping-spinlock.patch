From 85565bbf715fa8a9f0cb4b6e3d0c4ed113a69f66 Mon Sep 17 00:00:00 2001
From: Jack Steiner <steiner@sgi.com>
Date: Wed, 31 Aug 2011 12:00:53 +0100
Subject: [PATCH] mm: filemap: Optimise __lock_pages() by emulating an adaptive
 sleeping spinlock

References: VM performance, lock page scalability (bnc#436953, bnc#629170)
Patch-mainline: No (Never, no compelling use case other than boot times on very large machines)

The patch attempts to recognize the case where the lock is held for a
page that is up-to-date in the page cache and is locked for a brief
time by a thread running on another cpu. The patch avoids linking
the task to the page wait queue until it determines that a sleep is
really needed. This avoid hot locks and hot cache lines in many cases.

There are both boot time & run time improvements. Jack Steiner reported
that on tests with aim7 for large machines showed dramatic improvements.

The following tests were run on UVSW :
	768p Westmere
	 128 nodes

Boot times - greater than 2X reduction in boot time:
	2286s PTF #8
	1899s PTF #8
	 975s new algorithm
	 962s new algorithm

Boot messages referring to udev timeouts - eliminated:
	(After the udevadm settle timeout, the events queue contains):

	7174 PTF #8
	9435 PTF #8
	   0 new algorithm
	   0 new algorithm

AIM7 results - no difference at low numbers of tasks. Improvements at high counts:
	Jobs/Min at 2000 users
		 5100 PTF #8
		17750 new algorithm

	Wallclock seconds to run test at 2000 users
		2250s PTF #8
	 	 650s new algorithm

	CPU Seconds at 2000 users
		1300000 PTF #8
		  14000 new algorithm

Test of large parallel app faulting for text.

	Text resident in page cache (10000 pages):
		REAL	USER		SYS
		22.830s	23m5.567s	 85m59.042s	PTF #8 run1
		26.267s	34m3.536s	104m20.035s	PTF #8 run2
		10.890s	19m27.305s	 39m50.949s	new algorithm run1
		10.860s	20m42.698s	 40m48.889s	new algorithm run2

	Text on Disk (1000 pages)
		REAL	USER		SYS
		31.658s	9m25.379s	71m11.967s	PTF #8
		24.348s	6m15.323s	45m27.578s	new algorithm

_________________________________________________________________________________
The following tests were run on UV48:
	    4 racks
	  256 sockets
	2452p westmere

Boot time:
	4562 sec PTF#8
	1965 sec new

MPI "helloworld" with 1024 ranks
	35 sec PTF #8
	22 sec new

Test of large parallel app faulting for text.
	Text resident in page cache (10000 pages):
		REAL	USER		SYS
		46.394s	141m19s		366m53s		PTF #8
		38.986s	137m36		264m52s		PTF #8
		 7.987s	 34m50s		 42m36s		new algorithm
		10.550s	 43m31s		 59m45s		new algorithm

AIM7 Results (this is the original AIM7 - not the recent opensource version)
	------------------------------
	Jobs/Min
	 TASKS      PTF #8         new
	     1       487.8       486.6
	    10      4405.8      4940.6
	   100     18570.5     18198.9
	  1000     17262.3     17167.1
	  2000      4879.3     18163.9
	  4000        **       18846.2
	------------------------------
	Real Seconds
	 TASKS      PTF #8         new
	     1        11.9        12.0
	    10        13.2        11.8
	   100        31.3        32.0
	  1000       337.2       339.0
	  2000      2385.6       640.8
	  4000        **        1235.3
	------------------------------
	CPU Seconds
	 TASKS      PTF #8         new
	     1         1.6         1.6
	    10        11.5        12.9
	   100       132.2       137.2
	  1000      4486.5      6586.3
	  2000   1758419.7     27845.7
	  4000        **       65619.5

           ** Timed out

[sivanich@sgi.com: Priority inversion fix]
Signed-off-by: Jack Steiner <steiner@sgi.com>
Signed-off-by: Mel Gorman <mgorman@suse.de>
_________________________________________________________________________________________________
---
 mm/filemap.c | 13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

diff --git a/mm/filemap.c b/mm/filemap.c
index d60a7b8..97de177 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -33,6 +33,7 @@
 #include <linux/hardirq.h> /* for BUG_ON(!in_atomic()) only */
 #include <linux/memcontrol.h>
 #include <linux/cleancache.h>
+#include <linux/sched/rt.h>
 #include "internal.h"
 
 #define CREATE_TRACE_POINTS
@@ -679,12 +680,22 @@ void __lock_page(struct page *page)
 	DEFINE_WAIT_BIT(wait, &page->flags, PG_locked);
 
 	do {
+		if (!rt_task(current)) {
+			while (PageUptodate(page) && !PageWriteback(page) &&
+					!need_resched()) {
+				cpu_relax();
+				if (!PageLocked(page) && trylock_page(page))
+					goto done;
+			}
+		}
+
 		prepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);
 		if (!PageWaiters(page))
 			SetPageWaiters(page);
 		if (likely(PageLocked(page)))
 			sleep_on_page(page);
-	} while (!trylock_page(page));
+	} while (PageLocked(page) || !trylock_page(page));
+done:
 	finish_wait(wq, &wait.wait);
 }
 EXPORT_SYMBOL(__lock_page);
