From: Miroslav Benes <mbenes@suse.cz>
Date: Wed, 3 Jun 2015 16:31:17 +0200
Subject: s390/kgr: reorganize kgr infrastructure in entry64.S
Patch-mainline: submitted for review
References: fate#313296

Currently we directly clear TIF_KGR_IN_PROGRESS in several places of
s390 entry64.S. Let's move the TIF to a different bit and take
advantage of _TIF_WORK_SVC and _TIF_WORK_INT masks which define the
work to be done during the returns from a syscall or an
interrupt/exception. Task migration is now done in a C function called
from assembly.

Since there are two ways how the syscall can be restarted on return
from a signal handling process, it is important to clear the flag
before do_signal() is called. Otherwise we could miss the migration if
we used SIGSTOP/SIGCONT procedure or fake signal to migrate patching
blocking tasks. If we place our hook to sysc_work label in entry
before TIF_SIGPENDING is evaluated we kill two birds with one stone.
The task is correctly migrated in all return paths from a syscall.

KGraft infrastructure corresponds to x86 implementation now. Our TIF
can be cleared on syscall entry/exit or on interrupt/exception return
to userspace.

Signed-off-by: Miroslav Benes <mbenes@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 arch/s390/include/asm/thread_info.h |    4 ++--
 arch/s390/kernel/Makefile           |    1 +
 arch/s390/kernel/entry64.S          |   24 ++++++++++++++++--------
 arch/s390/kernel/kgraft.c           |   19 +++++++++++++++++++
 4 files changed, 38 insertions(+), 10 deletions(-)
 create mode 100644 arch/s390/kernel/kgraft.c

--- a/arch/s390/include/asm/thread_info.h
+++ b/arch/s390/include/asm/thread_info.h
@@ -81,6 +81,7 @@ static inline struct thread_info *curren
 #define TIF_NOTIFY_RESUME	1	/* callback before returning to user */
 #define TIF_SIGPENDING		2	/* signal pending */
 #define TIF_NEED_RESCHED	3	/* rescheduling necessary */
+#define TIF_KGR_IN_PROGRESS	4	/* This task has not finished patching */
 #define TIF_ASCE		5	/* primary asce needs fixup / uaccess */
 #define TIF_PER_TRAP		6	/* deliver sigtrap on return to user */
 #define TIF_MCCK_PENDING	7	/* machine check handling is pending */
@@ -92,12 +93,12 @@ static inline struct thread_info *curren
 #define TIF_MEMDIE		18	/* is terminating due to OOM killer */
 #define TIF_RESTORE_SIGMASK	19	/* restore signal mask in do_signal() */
 #define TIF_SINGLE_STEP		20	/* This task is single stepped */
-#define TIF_KGR_IN_PROGRESS	21	/* This task has not finished patching */
 
 #define _TIF_SYSCALL		(1<<TIF_SYSCALL)
 #define _TIF_NOTIFY_RESUME	(1<<TIF_NOTIFY_RESUME)
 #define _TIF_SIGPENDING		(1<<TIF_SIGPENDING)
 #define _TIF_NEED_RESCHED	(1<<TIF_NEED_RESCHED)
+#define _TIF_KGR_IN_PROGRESS	(1<<TIF_KGR_IN_PROGRESS)
 #define _TIF_ASCE		(1<<TIF_ASCE)
 #define _TIF_PER_TRAP		(1<<TIF_PER_TRAP)
 #define _TIF_MCCK_PENDING	(1<<TIF_MCCK_PENDING)
@@ -107,7 +108,6 @@ static inline struct thread_info *curren
 #define _TIF_SYSCALL_TRACEPOINT	(1<<TIF_SYSCALL_TRACEPOINT)
 #define _TIF_31BIT		(1<<TIF_31BIT)
 #define _TIF_SINGLE_STEP	(1<<TIF_SINGLE_STEP)
-#define _TIF_KGR_IN_PROGRESS	(1<<TIF_KGR_IN_PROGRESS)
 
 #ifdef CONFIG_64BIT
 #define is_32bit_task()		(test_thread_flag(TIF_31BIT))
--- a/arch/s390/kernel/Makefile
+++ b/arch/s390/kernel/Makefile
@@ -50,6 +50,7 @@ compat-obj-$(CONFIG_AUDIT)	+= compat_aud
 obj-$(CONFIG_COMPAT)		+= compat_linux.o compat_signal.o \
 					compat_wrapper.o compat_exec_domain.o \
 					$(compat-obj-y)
+obj-$(CONFIG_KGRAFT)		+= kgraft.o
 
 obj-$(CONFIG_STACKTRACE)	+= stacktrace.o
 obj-$(CONFIG_KPROBES)		+= kprobes.o
--- a/arch/s390/kernel/entry64.S
+++ b/arch/s390/kernel/entry64.S
@@ -43,9 +43,10 @@ STACK_SIZE  = 1 << STACK_SHIFT
 STACK_INIT = STACK_SIZE - STACK_FRAME_OVERHEAD - __PT_SIZE
 
 _TIF_WORK_SVC = (_TIF_SIGPENDING | _TIF_NOTIFY_RESUME | _TIF_NEED_RESCHED | \
-		 _TIF_MCCK_PENDING | _TIF_PER_TRAP | _TIF_ASCE)
+		 _TIF_MCCK_PENDING | _TIF_PER_TRAP | _TIF_ASCE | \
+		 _TIF_KGR_IN_PROGRESS)
 _TIF_WORK_INT = (_TIF_SIGPENDING | _TIF_NOTIFY_RESUME | _TIF_NEED_RESCHED | \
-		 _TIF_MCCK_PENDING | _TIF_ASCE)
+		 _TIF_MCCK_PENDING | _TIF_ASCE | _TIF_KGR_IN_PROGRESS)
 _TIF_TRACE    = (_TIF_SYSCALL_TRACE | _TIF_SYSCALL_AUDIT | _TIF_SECCOMP | \
 		 _TIF_SYSCALL_TRACEPOINT)
 
@@ -73,6 +74,15 @@ _TIF_TRACE    = (_TIF_SYSCALL_TRACE | _T
 #endif
 	.endm
 
+	.macro	HANDLE_KGRAFT TI_reg
+#if IS_ENABLED(CONFIG_KGRAFT)
+	tm	__TI_flags+7(\TI_reg),_TIF_KGR_IN_PROGRESS
+	jz	0f
+	brasl	%r14,s390_handle_kgraft
+0:
+#endif
+	.endm
+
 	.macro LPP newpp
 #if IS_ENABLED(CONFIG_KVM)
 	tm	__LC_MACHINE_FLAGS+6,0x20	# MACHINE_FLAG_LPP
@@ -220,9 +230,7 @@ sysc_vtime:
 	mvc	__PT_INT_CODE(4,%r11),__LC_SVC_ILC
 sysc_do_svc:
 	oi	__TI_flags+7(%r12),_TIF_SYSCALL
-#if IS_ENABLED(CONFIG_KGRAFT)
-	ni	__TI_flags+5(%r12),255 - (_TIF_KGR_IN_PROGRESS >> 16)
-#endif
+	HANDLE_KGRAFT %r12
 	lg	%r10,__TI_sysc_table(%r12)	# address of system call table
 	llgh	%r8,__PT_INT_CODE+2(%r11)
 	slag	%r8,%r8,2			# shift and test for svc 0
@@ -251,9 +259,6 @@ sysc_tif:
 	tm	__TI_flags+7(%r12),_TIF_WORK_SVC
 	jnz	sysc_work			# check for work
 	ni	__TI_flags+7(%r12),255-_TIF_SYSCALL
-#if IS_ENABLED(CONFIG_KGRAFT)
-	ni	__TI_flags+5(%r12),255 - (_TIF_KGR_IN_PROGRESS >> 16)
-#endif
 sysc_restore:
 	lg	%r14,__LC_VDSO_PER_CPU
 	lmg	%r0,%r10,__PT_R0(%r11)
@@ -274,6 +279,8 @@ sysc_work:
 	jo	sysc_reschedule
 	tm	__TI_flags+7(%r12),_TIF_PER_TRAP
 	jo	sysc_singlestep
+	HANDLE_KGRAFT %r12		# handle kGraft just before signals and
+					# possible syscall restart
 	tm	__TI_flags+7(%r12),_TIF_SIGPENDING
 	jo	sysc_sigpending
 	tm	__TI_flags+7(%r12),_TIF_NOTIFY_RESUME
@@ -568,6 +575,7 @@ io_work_tif:
 	jo	io_mcck_pending
 	tm	__TI_flags+7(%r12),_TIF_NEED_RESCHED
 	jo	io_reschedule
+	HANDLE_KGRAFT %r12
 	tm	__TI_flags+7(%r12),_TIF_SIGPENDING
 	jo	io_sigpending
 	tm	__TI_flags+7(%r12),_TIF_NOTIFY_RESUME
--- /dev/null
+++ b/arch/s390/kernel/kgraft.c
@@ -0,0 +1,19 @@
+/*
+ * kGraft Online Kernel Patching
+ *
+ *  Copyright (c) 2015 SUSE
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+#include <linux/sched.h>
+
+asmlinkage void s390_handle_kgraft(void)
+{
+	kgr_task_safe(current);
+}
