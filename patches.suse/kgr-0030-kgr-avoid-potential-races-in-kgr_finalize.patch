From: Petr Mladek <pmladek@suse.cz>
Date: Wed, 30 Jul 2014 11:34:11 +0200
Subject: kgr: avoid potential races in kgr_finalize()
Patch-mainline: submitted for review
References: fate#313296

Skipped patches need to be applied when the related modules are being loaded.
The patch also need to be disabled when the patched module is being removed.
Both these operations need to manipulate also the patch in progress that has not
been finalized yet.

This commit makes sure that status flags are not manipulated without
kgr_in_progress_lock.

Also it makes sure that kgr_patch is NULL when the patch is finalized.
It prevents from processing the patch as non-finalized.

Finally, it slightly reorganizes the calls to safe one check and set
both "NULL" and "false" together. It looked better readable to me.

Signed-off-by: Petr Mladek <pmladek@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 kernel/kgraft.c | 12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

diff --git a/kernel/kgraft.c b/kernel/kgraft.c
index fc0f048637a7..8f85261c54b3 100644
--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -145,6 +145,8 @@ static void kgr_finalize(void)
 {
 	struct kgr_patch_fun *patch_fun;
 
+	mutex_lock(&kgr_in_progress_lock);
+
 	kgr_for_each_patch_fun(kgr_patch, patch_fun) {
 		int ret = kgr_patch_code(patch_fun, true, kgr_revert);
 
@@ -155,16 +157,16 @@ static void kgr_finalize(void)
 
 	free_percpu(kgr_patch->irq_use_new);
 
-	if (kgr_revert)
-		module_put(kgr_patch->owner);
-
-	mutex_lock(&kgr_in_progress_lock);
-	kgr_in_progress = false;
 	if (kgr_revert) {
 		list_del(&kgr_patch->list);
 		kgr_refs_dec();
+		module_put(kgr_patch->owner);
 	} else
 		list_add_tail(&kgr_patch->list, &kgr_patches);
+
+	kgr_patch = NULL;
+	kgr_in_progress = false;
+
 	mutex_unlock(&kgr_in_progress_lock);
 }
 
-- 
2.1.0

