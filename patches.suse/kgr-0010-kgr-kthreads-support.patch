From: Jiri Slaby <jslaby@suse.cz>
Date: Mon, 6 Jan 2014 09:35:56 +0100
Subject: kgr: kthreads support
Patch-mainline: submitted for review
References: fate#313296

Wake up kthreads so that they cycle through kgr_task_safe either
by an explicit call to it or implicitly via try_to_freeze. This
ensures nobody should use the old version of the code and kgraft core
can push everybody to use the new version by switching to the fast
path.

jk: proper test for a process being a kthread

Signed-off-by: Jiri Kosina <jkosina@suse.cz> [fixes]
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
Cc: Tejun Heo <tj@kernel.org>
Cc: Steven Rostedt <rostedt@goodmis.org>
Cc: Frederic Weisbecker <fweisbec@gmail.com>
Cc: Ingo Molnar <mingo@redhat.com>
---
 kernel/kgraft.c | 27 ++++++++++++++++-----------
 1 file changed, 16 insertions(+), 11 deletions(-)

diff --git a/kernel/kgraft.c b/kernel/kgraft.c
index 589f0dba0916..c3321a34a1f0 100644
--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -52,7 +52,7 @@ static void kgr_stub_slow(unsigned long ip, unsigned long parent_ip,
 		struct ftrace_ops *ops, struct pt_regs *regs)
 {
 	struct kgr_patch_fun *p = ops->private;
-	bool go_old = kgr_task_in_progress(current) && current->mm;
+	bool go_old = kgr_task_in_progress(current);
 
 	if (go_old) {
 		pr_debug("kgr: slow stub: calling old code at %lx\n",
@@ -102,11 +102,7 @@ static bool kgr_still_patching(void)
 
 	read_lock(&tasklist_lock);
 	for_each_process(p) {
-		/*
-		 * TODO
-		 *   kernel thread codepaths not supported and silently ignored
-		 */
-		if (kgr_task_in_progress(p) && p->mm) {
+		if (kgr_task_in_progress(p)) {
 			pr_info("pid %d (%s) still in kernel after timeout\n",
 					p->pid, p->comm);
 			failed = true;
@@ -151,13 +147,23 @@ static void kgr_work_fn(struct work_struct *work)
 	kgr_finalize();
 }
 
-static void kgr_mark_processes(void)
+static void kgr_handle_processes(void)
 {
 	struct task_struct *p;
 
 	read_lock(&tasklist_lock);
-	for_each_process(p)
+	for_each_process(p) {
 		kgr_mark_task_in_progress(p);
+
+		/* wake up kthreads, they will clean the progress flag */
+		if (p->flags & PF_KTHREAD) {
+			/*
+			 * this is incorrect for kthreads waiting still for
+			 * their first wake_up.
+			 */
+			wake_up_process(p);
+		}
+	}
 	read_unlock(&tasklist_lock);
 }
 
@@ -280,8 +286,7 @@ static int kgr_patch_code(struct kgr_patch_fun *patch_fun, bool final)
  * kgr_patch_kernel -- the entry for a kgraft patch
  * @patch: patch to be applied
  *
- * Start patching of code that is neither running in IRQ context nor
- * kernel thread.
+ * Start patching of code that is not running in IRQ context.
  */
 int kgr_patch_kernel(struct kgr_patch *patch)
 {
@@ -324,7 +329,7 @@ int kgr_patch_kernel(struct kgr_patch *patch)
 	kgr_patch = patch;
 	mutex_unlock(&kgr_in_progress_lock);
 
-	kgr_mark_processes();
+	kgr_handle_processes();
 
 	/*
 	 * give everyone time to exit kernel, and check after a while
-- 
2.1.0

