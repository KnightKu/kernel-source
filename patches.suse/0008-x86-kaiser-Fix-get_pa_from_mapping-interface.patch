From 225e7df7cb5debbf18935707f87460fe8646f973 Mon Sep 17 00:00:00 2001
From: Joerg Roedel <jroedel@suse.de>
Date: Tue, 13 Mar 2018 15:34:34 +0100
Subject: [PATCH 08/17] x86/kaiser: Fix get_pa_from_mapping() interface
References: bsc#1068032 CVE-2017-5754
Patch-mainline: No, different upstream implementation

Return the target address via a parameter and use the real
return value only for success/fail indication.

Signed-off-by: Joerg Roedel <jroedel@suse.de>
---
 arch/x86/mm/kaiser.c | 35 +++++++++++++++++++++--------------
 1 file changed, 21 insertions(+), 14 deletions(-)

diff --git a/arch/x86/mm/kaiser.c b/arch/x86/mm/kaiser.c
index 0715ea9..814fbf3 100644
--- a/arch/x86/mm/kaiser.c
+++ b/arch/x86/mm/kaiser.c
@@ -61,7 +61,8 @@ static DEFINE_SPINLOCK(shadow_table_allocation_lock);
 /*
  * Returns -1 on error.
  */
-static inline unsigned long get_pa_from_mapping(unsigned long vaddr)
+static inline int get_pa_from_mapping(unsigned long vaddr,
+				      phys_addr_t *paddr)
 {
 	pgd_t *pgd;
 	pud_t *pud;
@@ -83,28 +84,35 @@ static inline unsigned long get_pa_from_mapping(unsigned long vaddr)
 	pud = pud_offset(pgd, vaddr);
 	if (pud_none(*pud)) {
 		WARN_ON_ONCE(1);
-		return -1;
+		return -EINVAL;
 	}
 
-	if (pud_large(*pud))
-		return (pud_pfn(*pud) << PAGE_SHIFT) | (vaddr & ~PUD_PAGE_MASK);
+	if (pud_large(*pud)) {
+		*paddr = ((phys_addr_t)pud_pfn(*pud) << PAGE_SHIFT) | (vaddr & ~PUD_PAGE_MASK);
+		return 0;
+	}
 
 	pmd = pmd_offset(pud, vaddr);
 	if (pmd_none(*pmd)) {
 		WARN_ON_ONCE(1);
-		return -1;
+		return -EINVAL;
 	}
 
-	if (pmd_large(*pmd))
-		return (pmd_pfn(*pmd) << PAGE_SHIFT) | (vaddr & ~PMD_PAGE_MASK);
+	if (pmd_large(*pmd)) {
+		*paddr = ((phys_addr_t)pmd_pfn(*pmd) << PAGE_SHIFT) | (vaddr & ~PMD_PAGE_MASK);
+		return 0;
+	}
 
 	pte = pte_offset_kernel(pmd, vaddr);
 	if (pte_none(*pte)) {
 		WARN_ON_ONCE(1);
-		return -1;
+		return -EINVAL;
 	}
 
-	return (pte_pfn(*pte) << PAGE_SHIFT) | (vaddr & ~PAGE_MASK);
+	*paddr = ((phys_addr_t)pte_pfn(*pte) << PAGE_SHIFT) | (vaddr &
+			~PAGE_MASK);
+
+	return 0;
 }
 
 /*
@@ -166,14 +174,14 @@ static pte_t *kaiser_pagetable_walk(unsigned long address)
 }
 
 static int kaiser_add_user_map(const void *__start_addr, unsigned long size,
-			       unsigned long flags)
+			       pteval_t flags)
 {
 	int ret = 0;
 	pte_t *pte;
 	unsigned long start_addr = (unsigned long )__start_addr;
 	unsigned long address = start_addr & PAGE_MASK;
 	unsigned long end_addr = PAGE_ALIGN(start_addr + size);
-	unsigned long target_address;
+	phys_addr_t target_address = 0;
 
 	if (!(__supported_pte_mask & _PAGE_NX))
 		flags &= ~_PAGE_NX;
@@ -188,11 +196,10 @@ static int kaiser_add_user_map(const void *__start_addr, unsigned long size,
 	flags &= ~_PAGE_GLOBAL;
 
 	if (flags & _PAGE_USER)
-		BUG_ON(address < FIXADDR_START || end_addr >= FIXADDR_TOP);
+		BUG_ON(address < FIXADDR_START || end_addr > FIXADDR_TOP);
 
 	for (; address < end_addr; address += PAGE_SIZE) {
-		target_address = get_pa_from_mapping(address);
-		if (target_address == -1) {
+		if (get_pa_from_mapping(address, &target_address)) {
 			ret = -EIO;
 			break;
 		}
-- 
1.8.5.6

