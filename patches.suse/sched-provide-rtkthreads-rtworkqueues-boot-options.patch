Subject: sched: Provide realtime priority kthread and workqueue boot options
From: Mike Galbraith <mgalbraith@suse.de>
Date: Tue Oct  8 06:27:03 CEST 2013
Patch-mainline: never, SUSE specific
References: bnc#836718

Nasty hack to allow users to abuse realtime without starving the kernel,
and reaping the consequences thereof.

Boot box nortsched rtkthreads=N and optionally rtworkqueues=N+1, and the
user can slam a box into the saturation wall without starving the kernel
IFF he restricts userspace to priority < N.

Signed-off-by: Mike Galbraith <mgalbraith@suse.de>
---
 Documentation/kernel-parameters.txt |    4 +++
 kernel/kthread.c                    |   42 ++++++++++++++++++++++++++++++++++--
 kernel/workqueue.c                  |   39 +++++++++++++++++++++++++++++++++
 3 files changed, 83 insertions(+), 2 deletions(-)

--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -2853,6 +2853,10 @@ bytes respectively. Such letter suffixes
 
 	nortsched       [KNL] Disables realtime task bandwidth control.
 
+	rtkthreads=	[KNL] kernel threads run as SCHED_FIFO at the provided priority (1..99).
+
+	rtworkqueues=	[KNL] kworker threads run as SCHED_FIFO at the provided priority (1..99).
+
 	skew_tick=	[KNL] Offset the periodic timer tick per cpu to mitigate
 			xtime_lock contention on larger systems, and/or RCU lock
 			contention on all systems with CONFIG_MAXSMP set.
--- a/kernel/kthread.c
+++ b/kernel/kthread.c
@@ -18,6 +18,7 @@
 #include <linux/freezer.h>
 #include <linux/ptrace.h>
 #include <linux/uaccess.h>
+#include <linux/hardirq.h>
 #include <trace/events/sched.h>
 
 static DEFINE_SPINLOCK(kthread_create_lock);
@@ -228,6 +229,28 @@ static void create_kthread(struct kthrea
 	}
 }
 
+static struct sched_param fifo_param, normal_param;
+
+static inline void kthread_set_sched_params(struct task_struct *kthread)
+{
+	if (in_interrupt())
+		return;
+	if (!fifo_param.sched_priority) {
+		sched_setscheduler_nocheck(kthread, SCHED_NORMAL, &normal_param);
+		return;
+	}
+	sched_setscheduler_nocheck(kthread, SCHED_FIFO, &fifo_param);
+}
+
+static inline void kthread_clr_sched_params(struct task_struct *kthread)
+{
+	if (in_interrupt())
+		return;
+	if (!fifo_param.sched_priority || kthread->policy != SCHED_FIFO)
+		return;
+	sched_setscheduler_nocheck(kthread, SCHED_NORMAL, &normal_param);
+}
+
 /**
  * kthread_create_on_node - create a kthread.
  * @threadfn: the function to run until signal_pending(current).
@@ -270,7 +293,6 @@ struct task_struct *kthread_create_on_no
 	wait_for_completion(&create.done);
 
 	if (!IS_ERR(create.result)) {
-		static const struct sched_param param = { .sched_priority = 0 };
 		va_list args;
 
 		va_start(args, namefmt);
@@ -281,7 +303,7 @@ struct task_struct *kthread_create_on_no
 		 * root may have changed our (kthreadd's) priority or CPU mask.
 		 * The kernel thread should not inherit these properties.
 		 */
-		sched_setscheduler_nocheck(create.result, SCHED_NORMAL, &param);
+		kthread_set_sched_params(create.result);
 		set_cpus_allowed_ptr(create.result, cpu_all_mask);
 	}
 	return create.result;
@@ -432,6 +454,7 @@ int kthread_stop(struct task_struct *k)
 	if (kthread) {
 		set_bit(KTHREAD_SHOULD_STOP, &kthread->flags);
 		__kthread_unpark(k, kthread);
+		kthread_clr_sched_params(k);
 		wake_up_process(k);
 		wait_for_completion(&kthread->exited);
 	}
@@ -452,6 +475,7 @@ int kthreadd(void *unused)
 	ignore_signals(tsk);
 	set_cpus_allowed_ptr(tsk, cpu_all_mask);
 	set_mems_allowed(node_states[N_MEMORY]);
+	kthread_set_sched_params(current);
 
 	current->flags |= PF_NOFREEZE;
 
@@ -653,3 +677,17 @@ void flush_kthread_worker(struct kthread
 	wait_for_completion(&fwork.done);
 }
 EXPORT_SYMBOL_GPL(flush_kthread_worker);
+
+static int __init setup_rtkthreads(char *str)
+{
+	int prio;
+
+	if (kstrtoint(str, 0, &prio) || prio < 1 || prio > 99) {
+		prio = 0;
+		pr_warn("Unable to set kthread default priority\n");
+	}
+	fifo_param.sched_priority = prio;
+
+        return 1;
+}
+__setup("rtkthreads=", setup_rtkthreads);
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -1685,6 +1685,27 @@ static struct worker *alloc_worker(void)
 	return worker;
 }
 
+static struct sched_param fifo_param, normal_param;
+
+static inline void kworker_set_sched_params(struct task_struct *worker)
+{
+	int prio = fifo_param.sched_priority;
+	if (!prio || in_interrupt())
+		return;
+	if (worker->policy == SCHED_FIFO && worker->rt_priority == prio)
+		return;
+	sched_setscheduler_nocheck(worker, SCHED_FIFO, &fifo_param);
+}
+
+static inline void kworker_clr_sched_params(struct task_struct *worker)
+{
+	if (in_interrupt())
+		return;
+	if (!fifo_param.sched_priority || worker->policy != SCHED_FIFO)
+		return;
+	sched_setscheduler_nocheck(worker, SCHED_NORMAL, &normal_param);
+}
+
 /**
  * create_worker - create a new workqueue worker
  * @pool: pool the new worker will belong to
@@ -1745,6 +1766,7 @@ static struct worker *create_worker(stru
 	 */
 	set_user_nice(worker->task, pool->attrs->nice);
 	set_cpus_allowed_ptr(worker->task, pool->attrs->cpumask);
+	kworker_set_sched_params(worker->task);
 
 	/* prevent userland from meddling with cpumask of workqueue workers */
 	worker->task->flags |= PF_NO_SETAFFINITY;
@@ -1856,6 +1878,7 @@ static void destroy_worker(struct worker
 
 	spin_unlock_irq(&pool->lock);
 
+	kworker_clr_sched_params(worker->task);
 	kthread_stop(worker->task);
 	put_task_struct(worker->task);
 	kfree(worker);
@@ -4290,6 +4313,7 @@ struct workqueue_struct *__alloc_workque
 
 		wq->rescuer = rescuer;
 		rescuer->task->flags |= PF_NO_SETAFFINITY;
+		kworker_set_sched_params(rescuer->task);
 		wake_up_process(rescuer->task);
 	}
 
@@ -4370,6 +4394,7 @@ void destroy_workqueue(struct workqueue_
 	workqueue_sysfs_unregister(wq);
 
 	if (wq->rescuer) {
+		kworker_clr_sched_params(wq->rescuer->task);
 		kthread_stop(wq->rescuer->task);
 		kfree(wq->rescuer);
 		wq->rescuer = NULL;
@@ -5163,3 +5188,17 @@ static int __init init_workqueues(void)
 	return 0;
 }
 early_initcall(init_workqueues);
+
+static int __init setup_rtworkqueues(char *str)
+{
+	int prio;
+
+	if (kstrtoint(str, 0, &prio) || prio < 1 || prio > 99) {
+		prio = 0;
+		pr_warn("Unable to set kworker default priority\n");
+	}
+	fifo_param.sched_priority = prio;
+
+        return 1;
+}
+__setup("rtworkqueues=", setup_rtworkqueues);
