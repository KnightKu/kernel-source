From 9a781a5a983dd5b95e56e08712d11c63e6ff54fb Mon Sep 17 00:00:00 2001
From: Mark Tinguely <tinguely@sgi.com>
Date: Mon, 1 Jun 2015 15:06:36 +0200
Subject: [PATCH] xfs_dmapi: xfs_dm_rdwr() uses dir file ops not file's ops
References: bsc#932898
Patch-mainline: Depends on DMAPI

In v3.5-rc6-321-g765927b Al Viro made dentry_open take a path argument
instead of a dentry. In the newer code a path using the mount point
was used to create a file and that file operations was used for
reading and writing. We passes the directory file (not the file in
the directory) to the read/write as well.

Directory file operations do not have an write function, so the
kernel crashed trying to execute code at offset 0.

The patch is to create a path structure using the dentry of the file
and using that in the dentry_open().

Also put put in checks to make sure the f_op->read() and
f_op->write() exist rather than just using them and crashing.

Signed-off-by: Mark Tinguely <tinguely@sgi.com>
Reviewed-by: Ben Myers <bpm@sgi.com>
Acked-by: Jeff Mahoney <jeffm@suse.com>
---
 fs/xfs/dmapi/xfs_dm.c | 14 ++++++++++----
 1 file changed, 10 insertions(+), 4 deletions(-)

diff --git a/fs/xfs/dmapi/xfs_dm.c b/fs/xfs/dmapi/xfs_dm.c
index ea4253b..c0022de 100644
--- a/fs/xfs/dmapi/xfs_dm.c
+++ b/fs/xfs/dmapi/xfs_dm.c
@@ -858,6 +858,7 @@ xfs_dm_rdwr(
 	struct file	*file;
 	struct dentry	*dentry;
 	struct path	path;
+	struct path	dpath;
 	struct xfs_mount *mp = ip->i_mount;
 
 	if ((off < 0) || (off > i_size_read(inode)) || !S_ISREG(inode->i_mode))
@@ -899,7 +900,11 @@ xfs_dm_rdwr(
 	if (error)
 		return -error;
 
-	file = dentry_open(&path, oflags, cred);
+	/* create a path structure for the inode passed into function */
+	dpath.mnt = path.mnt;
+	dpath.dentry = dentry;
+	file = dentry_open(&dpath, oflags, cred);
+	/* path_put() will only dput the directory dentry, so we do it here */
 	dput(dentry);
 	if (IS_ERR(file)) {
 		path_put(&path);
@@ -907,11 +912,12 @@ xfs_dm_rdwr(
 	}
 	file->f_mode |= FMODE_NOCMTIME;
 
-	if (fmode & FMODE_READ) {
+	if (fmode & FMODE_READ && file->f_op->read != NULL) {
 		xfer = file->f_op->read(file, bufp, len, (loff_t*)&off);
-	} else {
+	} else if (fmode & FMODE_WRITE && file->f_op->write != NULL) {
 		xfer = file->f_op->write(file, bufp, len, (loff_t*)&off);
-	}
+	} else
+		xfer = -EINVAL; /* error code when f_op functions are NULL */
 
 	if (xfer >= 0) {
 		*rvp = xfer;
-- 
2.1.4

