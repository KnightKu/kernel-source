From: Jiri Kosina <jkosina@suse.cz>
Date: Tue, 12 Aug 2014 16:03:06 +0200
Subject: kgr: make it possible to avoid lazy switching
Patch-mainline: submitted for review
References: fate#313296

In cases where the patch is known to be completely independent on other
context (such as, but not limited to, added check at the beginning of a
syscall), it's convenient to be able to completely avoid going through the
hoops of lazy migration to the new universe.

Allow patches to set an 'immediate' flag and not (re-)start the lazy
migration when it's set.

jk: simplify 'immediate' logic (remove preparation to parallelism)
js: call kgr_finalize properly also with immediate flag set

Signed-off-by: Jiri Kosina <jkosina@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 include/linux/kgraft.h |  2 ++
 kernel/kgraft.c        | 24 +++++++++++++++++-------
 2 files changed, 19 insertions(+), 7 deletions(-)

diff --git a/include/linux/kgraft.h b/include/linux/kgraft.h
index 30701157cd4b..f02d8025588b 100644
--- a/include/linux/kgraft.h
+++ b/include/linux/kgraft.h
@@ -81,6 +81,7 @@ struct kgr_patch_fun {
  * @name: name of the patch (to appear in sysfs)
  * @owner: module to refcount on patching
  * @replace_all: revert everything applied before and apply this one instead
+ * @immediate: avoid the lazy-switching mechanism and flip the switch ASAP
  * @patches: array of @kgr_patch_fun structures
  */
 struct kgr_patch {
@@ -95,6 +96,7 @@ struct kgr_patch {
 	const char *name;
 	struct module *owner;
 	bool replace_all;
+	bool immediate;
 	struct kgr_patch_fun patches[];
 };
 
diff --git a/kernel/kgraft.c b/kernel/kgraft.c
index 06aec5a12003..c8bf435d3f82 100644
--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -189,6 +189,8 @@ static void kgr_finalize(void)
 	struct kgr_patch_fun *patch_fun;
 	struct kgr_patch *p_to_revert = NULL;
 
+	pr_info("kgr succeeded\n");
+
 	mutex_lock(&kgr_in_progress_lock);
 
 	kgr_for_each_patch_fun(kgr_patch, patch_fun) {
@@ -246,7 +248,6 @@ static void kgr_work_fn(struct work_struct *work)
 	 * victory, patching finished, put everything back in shape
 	 * with as less performance impact as possible again
 	 */
-	pr_info("kgr succeeded\n");
 	kgr_finalize();
 }
 
@@ -553,7 +554,12 @@ int kgr_modify_kernel(struct kgr_patch *patch, bool revert, bool force)
 		goto err_unlock;
 	}
 
-	kgr_mark_processes();
+	/*
+	 * If the patch has immediate flag set, avoid the lazy-switching
+	 * between universes completely.
+	 */
+	if (!patch->immediate)
+		kgr_mark_processes();
 
 	kgr_for_each_patch_fun(patch, patch_fun) {
 		patch_fun->patch = patch;
@@ -583,12 +589,16 @@ int kgr_modify_kernel(struct kgr_patch *patch, bool revert, bool force)
 	mutex_unlock(&kgr_in_progress_lock);
 
 	kgr_handle_irqs();
-	kgr_handle_processes();
 
-	/*
-	 * give everyone time to exit kernel, and check after a while
-	 */
-	queue_delayed_work(kgr_wq, &kgr_work, 10 * HZ);
+	if (patch->immediate) {
+		kgr_finalize();
+	} else {
+		kgr_handle_processes();
+		/*
+		 * give everyone time to exit kernel, and check after a while
+		 */
+		queue_delayed_work(kgr_wq, &kgr_work, 10 * HZ);
+	}
 
 	return 0;
 err_free:
-- 
2.1.1

