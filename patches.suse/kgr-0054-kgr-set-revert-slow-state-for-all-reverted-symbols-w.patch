From: Petr Mladek <pmladek@suse.cz>
Date: Tue, 6 Jan 2015 17:11:04 +0100
Subject: kgr: set revert slow state for all reverted symbols when loading
 patched module
Patch-mainline: submitted for review
References: fate#313296

kgr_patch_code_delayed() is supposed to put the patch to the same
state as if the patched module has been loaded before the patch.

There is one difference. kgr_revert_replaced_funs() modifies
loc_old and calls kgr_patch_code() for all patch_fun structures
that need to be reverted. But kgr_patch_code_delayed() does the
related changes only for the last finalized patch_fun.

This patch fixes the inconsistency and also slightly improves the
related comments.

Signed-off-by: Petr Mladek <pmladek@suse.cz>
Reviewed-by: Miroslav Benes <mbenes@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 kernel/kgraft.c | 18 ++++++++++++------
 1 file changed, 12 insertions(+), 6 deletions(-)

diff --git a/kernel/kgraft.c b/kernel/kgraft.c
index d8706b74a093..de4bf6e210be 100644
--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -882,18 +882,24 @@ static int kgr_patch_code_delayed(struct kgr_patch_fun *patch_fun)
 		new_ops = &patch_fun->ftrace_ops_slow;
 	} else {
 		if (kgr_patch && kgr_patch->replace_all && !kgr_revert &&
-		    !kgr_patch_contains(kgr_patch, patch_fun->name) &&
-		    kgr_is_patch_fun(patch_fun, KGR_LAST_FINALIZED)) {
+		    !kgr_patch_contains(kgr_patch, patch_fun->name)) {
 			next_state = KGR_PATCH_REVERT_SLOW;
 			patch_fun->loc_old = patch_fun->loc_name;
-			new_ops = &patch_fun->ftrace_ops_slow;
+			/*
+			 * Check for the last finalized patch is enough. We are
+			 * here only when the function is not included in the
+			 * patch in progress (kgr_patch).
+			 */
+			if (kgr_is_patch_fun(patch_fun, KGR_LAST_FINALIZED))
+				new_ops = &patch_fun->ftrace_ops_slow;
 		} else {
 			next_state = KGR_PATCH_APPLIED;
 			/*
 			 * Check for the last existing and not the last
-			 * finalized patch_fun here! There might be another
-			 * patch_fun in the patch in progress that will be
-			 * handled in the next calls.
+			 * finalized patch_fun here! This function is called
+			 * for all patches. There might be another patch_fun
+			 * in the patch in progress that will need to register
+			 * the ftrace ops.
 			 */
 			if (kgr_is_patch_fun(patch_fun, KGR_LAST_EXISTING))
 				new_ops = &patch_fun->ftrace_ops_fast;
-- 
2.2.1

