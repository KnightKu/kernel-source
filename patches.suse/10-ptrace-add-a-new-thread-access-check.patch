From: Borislav Petkov <bp@suse.de>
Date: Sat, 16 Dec 2017 18:32:52 +0100
Subject: ptrace: Add a new thread access check
Patch-mainline: submitted on 2018/1/9
References: bsc#1068032

... which checks current and a target task. Add IBPB ptrace mode too.

Carved out from a patch by Tim Chen <tim.c.chen@linux.intel.com>

Boris:

 - shorten PTRACE_MODE_IBPB as the other defines are not here yet.

Signed-off-by: Borislav Petkov <bp@suse.de>
---
 include/linux/ptrace.h |    9 +++++++--
 kernel/ptrace.c        |   18 ++++++++++++++----
 2 files changed, 21 insertions(+), 6 deletions(-)

--- a/include/linux/ptrace.h
+++ b/include/linux/ptrace.h
@@ -118,11 +118,16 @@ extern void __ptrace_unlink(struct task_
 extern void exit_ptrace(struct task_struct *tracer);
 #define PTRACE_MODE_READ   1
 #define PTRACE_MODE_ATTACH 2
-/* Returns 0 on success, -errno on denial. */
-extern int __ptrace_may_access(struct task_struct *task, unsigned int mode);
+#define PTRACE_MODE_NOACCESS_CHK 0x20
+
+#define PTRACE_MODE_IBPB (PTRACE_MODE_ATTACH | PTRACE_MODE_NOACCESS_CHK )
+
 /* Returns true on success, false on denial. */
 extern bool ptrace_may_access(struct task_struct *task, unsigned int mode);
 
+extern int ___ptrace_may_access(struct task_struct *cur, struct task_struct *task,
+	unsigned int mode);
+
 static inline int ptrace_reparented(struct task_struct *child)
 {
 	return child->real_parent != child->parent;
--- a/kernel/ptrace.c
+++ b/kernel/ptrace.c
@@ -169,9 +169,10 @@ int ptrace_check_attach(struct task_stru
 	return ret;
 }
 
-int __ptrace_may_access(struct task_struct *task, unsigned int mode)
+int ___ptrace_may_access(struct task_struct *cur, struct task_struct *task,
+		unsigned int mode)
 {
-	const struct cred *cred = current_cred(), *tcred;
+	const struct cred *cred = __task_cred(cur), *tcred;
 
 	/* May we inspect the given task?
 	 * This check is used both for attaching with ptrace
@@ -183,7 +184,7 @@ int __ptrace_may_access(struct task_stru
 	 */
 	int dumpable = 0;
 	/* Don't let security modules deny introspection */
-	if (same_thread_group(task, current))
+	if (same_thread_group(task, cur))
 		return 0;
 	rcu_read_lock();
 	tcred = __task_cred(task);
@@ -207,7 +208,16 @@ ok:
 	if (dumpable != SUID_DUMP_USER && !task_ns_capable(task, CAP_SYS_PTRACE))
 		return -EPERM;
 
-	return security_ptrace_access_check(task, mode);
+	if (!(mode & PTRACE_MODE_NOACCESS_CHK))
+		return security_ptrace_access_check(task, mode);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(___ptrace_may_access);
+
+static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
+{
+	return ___ptrace_may_access(current, task, mode);
 }
 
 bool ptrace_may_access(struct task_struct *task, unsigned int mode)
