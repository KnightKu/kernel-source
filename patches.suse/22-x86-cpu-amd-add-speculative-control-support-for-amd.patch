From: Tom Lendacky <thomas.lendacky@amd.com>
Date: Mon, 18 Dec 2017 11:50:09 +0100
Subject: x86/CPU/AMD: Add speculative control support for AMD
Patch-mainline: submitted on 2018/1/9
References: bsc#1068032

Add speculative control support for AMD processors. For AMD, speculative
control is indicated as follows:

  CPUID EAX=0x00000007, ECX=0x00 return EDX[26] indicates support for
  both IBRS and IBPB.

  CPUID EAX=0x80000008, ECX=0x00 return EBX[12] indicates support for
  just IBPB.

On AMD family 0x10, 0x12 and 0x16 processors where either of the above
features are not supported, IBPB can be achieved by disabling
indirect branch predictor support in MSR 0xc0011021[14] at boot.

Boris:
- make CPUID_0x80000008[EBX], cap leaf 10 as the others are missing
- use rdmsrl/wrmsrl because we don't have msr_set_bit() yet

Signed-off-by: Tom Lendacky <thomas.lendacky@amd.com>
[ Move everything to spec_ctrl.c ]
Signed-off-by: Borislav Petkov <bp@suse.de>
---
 arch/x86/include/asm/cpufeature.h |    5 ++++-
 arch/x86/include/asm/msr-index.h  |    2 ++
 arch/x86/kernel/cpu/amd.c         |    3 +++
 arch/x86/kernel/cpu/scattered.c   |    1 +
 arch/x86/kernel/cpu/spec_ctrl.c   |   20 ++++++++++++++++++++
 5 files changed, 30 insertions(+), 1 deletion(-)

--- a/arch/x86/include/asm/cpufeature.h
+++ b/arch/x86/include/asm/cpufeature.h
@@ -89,7 +89,10 @@
 #define X86_FEATURE_LFENCE_RDTSC (3*32+18) /* "" Lfence synchronizes RDTSC */
 #define X86_FEATURE_11AP	(3*32+19) /* "" Bad local APIC aka 11AP */
 #define X86_FEATURE_NOPL	(3*32+20) /* The NOPL (0F 1F) instructions */
-					  /* 21 available, was AMD_C1E */
+
+/* It is in word 13 upstream - move it here due to kABI breakage. */
+#define X86_FEATURE_IBPB       (3*32+21) /* Indirect Branch Prediction Barrier */
+
 #define X86_FEATURE_XTOPOLOGY	(3*32+22) /* cpu topology enum extensions */
 #define X86_FEATURE_TSC_RELIABLE (3*32+23) /* TSC is known to be reliable */
 #define X86_FEATURE_NONSTOP_TSC	(3*32+24) /* TSC does not stop in C states */
--- a/arch/x86/include/asm/msr-index.h
+++ b/arch/x86/include/asm/msr-index.h
@@ -152,6 +152,8 @@
 /* Fam 15h MSRs */
 #define MSR_F15H_PERF_CTL		0xc0010200
 #define MSR_F15H_PERF_CTR		0xc0010201
+#define MSR_F15H_IC_CFG			0xc0011021
+#define MSR_F15H_IC_CFG_DIS_IND		(1 << 14)
 
 /* Fam 10h MSRs */
 #define MSR_FAM10H_MMIO_CONF_BASE	0xc0010058
--- a/arch/x86/kernel/cpu/amd.c
+++ b/arch/x86/kernel/cpu/amd.c
@@ -8,6 +8,7 @@
 #include <asm/apic.h>
 #include <asm/cpu.h>
 #include <asm/pci-direct.h>
+#include <asm/spec_ctrl.h>
 
 #ifdef CONFIG_X86_64
 # include <asm/numa_64.h>
@@ -680,6 +681,8 @@ static void __cpuinit init_amd(struct cp
 			wrmsrl_safe(MSR_AMD64_MCx_MASK(4), mask);
 		}
 	}
+
+	x86_spec_check();
 }
 
 #ifdef CONFIG_X86_32
--- a/arch/x86/kernel/cpu/scattered.c
+++ b/arch/x86/kernel/cpu/scattered.c
@@ -41,6 +41,7 @@ void __cpuinit init_scattered_cpuid_feat
 		{ X86_FEATURE_SPEC_CTRL,        CR_EDX,26, 0x00000007, 0 },
 		{ X86_FEATURE_XSAVEOPT,		CR_EAX,	0, 0x0000000d, 1 },
 		{ X86_FEATURE_CPB,		CR_EDX, 9, 0x80000007, 0 },
+		{ X86_FEATURE_IBPB,		CR_EBX,12, 0x80000008, 0 },
 		{ X86_FEATURE_NPT,		CR_EDX, 0, 0x8000000a, 0 },
 		{ X86_FEATURE_LBRV,		CR_EDX, 1, 0x8000000a, 0 },
 		{ X86_FEATURE_SVML,		CR_EDX, 2, 0x8000000a, 0 },
--- a/arch/x86/kernel/cpu/spec_ctrl.c
+++ b/arch/x86/kernel/cpu/spec_ctrl.c
@@ -63,6 +63,26 @@ void x86_spec_check(void)
 
 			setup_force_cpu_cap(X86_FEATURE_SPEC_CTRL);
 		}
+	} else if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD) {
+		if (boot_cpu_has(X86_FEATURE_SPEC_CTRL))
+			ibrs_state = 1;
+
+		if (boot_cpu_has(X86_FEATURE_IBPB)) {
+			ibpb_state = 1;
+		} else {
+			u64 val;
+
+			switch (boot_cpu_data.x86) {
+			case 0x10:
+			case 0x12:
+			case 0x16:
+				pr_info_once("Disabling indirect branch predictor support\n");
+				rdmsrl(MSR_F15H_IC_CFG, val);
+				val |= MSR_F15H_IC_CFG_DIS_IND;
+				wrmsrl(MSR_F15H_IC_CFG, val);
+				break;
+			}
+		}
 	}
 }
 EXPORT_SYMBOL_GPL(x86_spec_check);
