From: Miroslav Benes <mbenes@suse.cz>
Date: Mon, 30 Mar 2015 15:47:38 +0200
Subject: kgr: handle the delayed patching of the modules
Patch-mainline: submitted for review
References: fate#313296

The delayed patching of the modules can fail. When the insertion of the
module fails we refuse to load it. However the user can force the
insertion in spite of the errors by setting force_load_module in sysfs
infrastructure. When true (default is false) the errors are omitted and
the module is loaded.

If an error occurs for going module we cannot do anything else than to
BUG.  It is very suspicious situation (kGraft or ftrace) and consistent
state cannot be guaranteed any longer. We cannot prohibit the module to
go away.

Signed-off-by: Miroslav Benes <mbenes@suse.cz>
Reviewed-by: Petr Mladek <pmladek@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 include/linux/kgraft.h |    3 +
 kernel/kgraft.c        |   98 ++++++++++++++++++++++++++++++++++++++-----------
 kernel/kgraft_files.c  |   27 +++++++++++++
 kernel/module.c        |    4 +-
 4 files changed, 108 insertions(+), 24 deletions(-)

--- a/include/linux/kgraft.h
+++ b/include/linux/kgraft.h
@@ -108,13 +108,14 @@ struct kgr_patch {
 #define KGR_PATCH_END				{ }
 
 extern bool kgr_in_progress;
+extern bool kgr_force_load_module;
 
 extern int kgr_patch_kernel(struct kgr_patch *);
 extern void kgr_patch_remove(struct kgr_patch *);
 
 extern void kgr_unmark_processes(void);
 extern int kgr_modify_kernel(struct kgr_patch *patch, bool revert);
-extern void kgr_module_init(const struct module *mod);
+extern int kgr_module_init(const struct module *mod);
 extern int kgr_patch_dir_add(struct kgr_patch *patch);
 extern void kgr_patch_dir_del(struct kgr_patch *patch);
 extern int kgr_add_files(void);
--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -33,6 +33,7 @@
 static int kgr_patch_code(struct kgr_patch_fun *patch_fun, bool final,
 		bool revert, bool replace_revert);
 static void kgr_work_fn(struct work_struct *work);
+static void __kgr_handle_going_module(const struct module *mod);
 
 static struct workqueue_struct *kgr_wq;
 static DECLARE_DELAYED_WORK(kgr_work, kgr_work_fn);
@@ -40,6 +41,7 @@ static DEFINE_MUTEX(kgr_in_progress_lock
 static LIST_HEAD(kgr_patches);
 static bool __percpu *kgr_irq_use_new;
 bool kgr_in_progress;
+bool kgr_force_load_module;
 static bool kgr_initialized;
 static struct kgr_patch *kgr_patch;
 static bool kgr_revert;
@@ -1087,8 +1089,13 @@ static int kgr_patch_code_delayed(struct
 /*
  * This function is called when new module is loaded but before it is used.
  * Therefore it could set the fast path for already finalized patches.
+ *
+ * The patching of the module (registration of the stubs) could fail. This would
+ * prevent the loading. However the user can force the loading. In such
+ * situation we continue. This can lead the inconsistent system state but the
+ * user should know what he is doing.
  */
-static void kgr_handle_patch_for_loaded_module(struct kgr_patch *patch,
+static int kgr_handle_patch_for_loaded_module(struct kgr_patch *patch,
 					       const struct module *mod)
 {
 	struct kgr_patch_fun *patch_fun;
@@ -1104,11 +1111,27 @@ static void kgr_handle_patch_for_loaded_
 			continue;
 
 		err = kgr_init_ftrace_ops(patch_fun);
-		if (err)
-			continue;
+		if (err) {
+			if (kgr_force_load_module) {
+				WARN(1, "kgr: delayed patching of the module (%s) failed (%d). Insertion of the module forced.\n",
+					mod->name, err);
+				continue;
+			} else {
+				return err;
+			}
+		}
 
-		kgr_patch_code_delayed(patch_fun);
+		err = kgr_patch_code_delayed(patch_fun);
+		if (err) {
+			if (kgr_force_load_module)
+				WARN(1, "kgr: delayed patching of the module (%s) failed (%d). Insertion of the module forced.\n",
+					mod->name, err);
+			else
+				return err;
+		}
 	}
+
+	return 0;
 }
 
 /**
@@ -1117,13 +1140,14 @@ static void kgr_handle_patch_for_loaded_
  * It must be called when symbols are visible to kallsyms but before the module
  * init is called. Otherwise, it would not be able to use the fast stub.
  */
-void kgr_module_init(const struct module *mod)
+int kgr_module_init(const struct module *mod)
 {
 	struct kgr_patch *p;
+	int ret;
 
 	/* early modules will be patched once KGraft is initialized */
 	if (!kgr_initialized)
-		return;
+		return 0;
 
 	mutex_lock(&kgr_in_progress_lock);
 
@@ -1131,15 +1155,33 @@ void kgr_module_init(const struct module
 	 * Check already applied patches for skipped functions. If there are
 	 * more patches we want to set them all. They need to be in place when
 	 * we remove some patch.
+	 * If the patching fails remove all stubs. It is doable by call to
+	 * module going notifier.
 	 */
-	list_for_each_entry(p, &kgr_patches, list)
-		kgr_handle_patch_for_loaded_module(p, mod);
+	list_for_each_entry(p, &kgr_patches, list) {
+		ret = kgr_handle_patch_for_loaded_module(p, mod);
+		if (ret) {
+			pr_err("kgr: delayed patching of the module (%s) failed (%d). Module was not inserted.\n",
+				mod->name, ret);
+			__kgr_handle_going_module(mod);
+			goto out;
+		}
+	}
 
 	/* also check the patch in progress that is being applied */
-	if (kgr_patch)
-		kgr_handle_patch_for_loaded_module(kgr_patch, mod);
+	if (kgr_patch) {
+		ret = kgr_handle_patch_for_loaded_module(kgr_patch, mod);
+		if (ret) {
+			pr_err("kgr: delayed patching of the module (%s) failed (%d). Module was not inserted.\n",
+				mod->name, ret);
+			__kgr_handle_going_module(mod);
+			goto out;
+		}
+	}
 
+out:
 	mutex_unlock(&kgr_in_progress_lock);
+	return ret;
 }
 
 /*
@@ -1173,9 +1215,13 @@ static int kgr_forced_code_patch_removal
 	if (ops) {
 		err = kgr_ftrace_disable(patch_fun, ops);
 		if (err) {
-			pr_warn("kgr: forced disabling of ftrace function for %s failed with %d\n",
+			pr_err("kgr: forced disabling of ftrace function for %s failed (%d)\n",
 				patch_fun->name, err);
-			return err;
+			/*
+			 * Cannot remove stubs for leaving module. This is very
+			 * suspicious situation, so we better BUG here.
+			 */
+			BUG();
 		}
 	}
 
@@ -1214,27 +1260,35 @@ static void kgr_handle_patch_for_going_m
 /*
  * Disable patches for the module that is being removed.
  *
- * FIXME: The module removal cannot be stopped at this stage. All affected
- * patches have to be removed. Therefore, the operation continues even in
- * case of errors.
+ * The module removal cannot be stopped at this stage. All affected patches have
+ * to be removed. Ftrace does not unregister stubs itself in order to optimize
+ * when the affected module gets loaded again. We have to do it ourselves. If we
+ * fail here and the module is loaded once more, we are going to patch it. This
+ * could lead to the conflicts with ftrace and more errors. We would not be able
+ * to load the module cleanly.
+ *
+ * In case of any error we BUG in the process.
  */
-static void kgr_handle_going_module(const struct module *mod)
+static void __kgr_handle_going_module(const struct module *mod)
 {
 	struct kgr_patch *p;
 
-	/* Nope when kGraft has not been initialized yet */
-	if (!kgr_initialized)
-		return;
-
-	mutex_lock(&kgr_in_progress_lock);
-
 	list_for_each_entry(p, &kgr_patches, list)
 		kgr_handle_patch_for_going_module(p, mod);
 
 	/* also check the patch in progress for removed functions */
 	if (kgr_patch)
 		kgr_handle_patch_for_going_module(kgr_patch, mod);
+}
+
+static void kgr_handle_going_module(const struct module *mod)
+{
+	/* Nope when kGraft has not been initialized yet */
+	if (!kgr_initialized)
+		return;
 
+	mutex_lock(&kgr_in_progress_lock);
+	__kgr_handle_going_module(mod);
 	mutex_unlock(&kgr_in_progress_lock);
 }
 
--- a/kernel/kgraft_files.c
+++ b/kernel/kgraft_files.c
@@ -165,10 +165,37 @@ static ssize_t in_progress_store(struct
 	return count;
 }
 
+static ssize_t force_load_module_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", kgr_force_load_module);
+}
+
+static ssize_t force_load_module_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long val;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &val);
+	if (ret)
+		return -EINVAL;
+
+	if (val != 1 && val != 0)
+		return -EINVAL;
+
+	kgr_force_load_module = val;
+
+	return count;
+}
+
 static struct kobj_attribute kgr_attr_in_progress = __ATTR_RW(in_progress);
+static struct kobj_attribute kgr_attr_force_load_module =
+		__ATTR_RW(force_load_module);
 
 static struct attribute *kgr_sysfs_entries[] = {
 	&kgr_attr_in_progress.attr,
+	&kgr_attr_force_load_module.attr,
 	NULL
 };
 
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -3422,7 +3422,9 @@ static int load_module(struct load_info
 	 * to kallsyms but before the module init is called. Then the
 	 * changes can be applied immediately.
 	 */
-	kgr_module_init(mod);
+	err = kgr_module_init(mod);
+	if (err)
+		goto bug_cleanup;
 #endif
 
 	/* Module is ready to execute: parsing args may do that. */
