From: Miroslav Benes <mbenes@suse.cz>
Date: Wed, 3 Jun 2015 13:44:14 +0200
Subject: x86/kgr: move kgr infrastructure from asm to C
Patch-mainline: submitted for review
References: fate#313296

There are several places in entry_64.S where we need to clear
TIF_KGR_IN_PROGRESS flag in order to migrate the task during patching.
We can modify TIF work masks (that is _TIF_WORK_SYSCALL_ENTRY,
_TIF_WORK_MASK, _TIF_ALLWORK_MASK and _TIF_DO_NOTIFY_MASK) to achieve
the same in C.

We also gain one more place of migration with this as a bonus. The tasks
can be safely migrated on return from an interrupt/exception back to the
userspace. It is going to be essential for the fake signal.

Signed-off-by: Miroslav Benes <mbenes@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 arch/x86/include/asm/thread_info.h |    5 +++--
 arch/x86/kernel/entry_64.S         |    9 ---------
 arch/x86/kernel/ptrace.c           |    5 +++++
 arch/x86/kernel/signal.c           |    5 +++++
 4 files changed, 13 insertions(+), 11 deletions(-)

--- a/arch/x86/include/asm/thread_info.h
+++ b/arch/x86/include/asm/thread_info.h
@@ -137,7 +137,8 @@ struct thread_info {
 #define _TIF_WORK_MASK							\
 	(0x0000FFFF &							\
 	 ~(_TIF_SYSCALL_TRACE|_TIF_SYSCALL_AUDIT|			\
-	   _TIF_SINGLESTEP|_TIF_SECCOMP|_TIF_SYSCALL_EMU))
+	   _TIF_SINGLESTEP|_TIF_SECCOMP|_TIF_SYSCALL_EMU) |		\
+	   _TIF_KGR_IN_PROGRESS)
 
 /* work to do on any return to user space */
 #define _TIF_ALLWORK_MASK						\
@@ -147,7 +148,7 @@ struct thread_info {
 /* Only used for 64 bit */
 #define _TIF_DO_NOTIFY_MASK						\
 	(_TIF_SIGPENDING | _TIF_MCE_NOTIFY | _TIF_NOTIFY_RESUME |	\
-	 _TIF_USER_RETURN_NOTIFY | _TIF_UPROBE)
+	 _TIF_USER_RETURN_NOTIFY | _TIF_UPROBE | _TIF_KGR_IN_PROGRESS)
 
 /* flags to check in __switch_to() */
 #define _TIF_WORK_CTXSW							\
--- a/arch/x86/kernel/entry_64.S
+++ b/arch/x86/kernel/entry_64.S
@@ -665,9 +665,6 @@ sysret_check:
 	/* Handle reschedules */
 	/* edx:	work, edi: workmask */
 sysret_careful:
-#if IS_ENABLED(CONFIG_KGRAFT)
-	LOCK_PREFIX ; andl $~_TIF_KGR_IN_PROGRESS,TI_flags+THREAD_INFO(%rsp,RIP-ARGOFFSET)
-#endif
 	bt $TIF_NEED_RESCHED,%edx
 	jnc sysret_signal
 	TRACE_IRQS_ON
@@ -731,9 +728,6 @@ sysret_audit:
 
 	/* Do syscall tracing */
 tracesys:
-#if IS_ENABLED(CONFIG_KGRAFT)
-	LOCK_PREFIX ; andl $~_TIF_KGR_IN_PROGRESS,TI_flags+THREAD_INFO(%rsp,RIP-ARGOFFSET)
-#endif
 #ifdef CONFIG_AUDITSYSCALL
 	testl $(_TIF_WORK_SYSCALL_ENTRY & ~_TIF_SYSCALL_AUDIT),TI_flags+THREAD_INFO(%rsp,RIP-ARGOFFSET)
 	jz auditsys
@@ -784,9 +778,6 @@ GLOBAL(int_with_check)
 	/* First do a reschedule test. */
 	/* edx:	work, edi: workmask */
 int_careful:
-#if IS_ENABLED(CONFIG_KGRAFT)
-	LOCK_PREFIX ; andl $~_TIF_KGR_IN_PROGRESS,TI_flags(%rcx)
-#endif
 	bt $TIF_NEED_RESCHED,%edx
 	jnc  int_very_careful
 	TRACE_IRQS_ON
--- a/arch/x86/kernel/ptrace.c
+++ b/arch/x86/kernel/ptrace.c
@@ -1491,6 +1491,11 @@ long syscall_trace_enter(struct pt_regs
 				    regs->dx, regs->r10);
 #endif
 
+#if IS_ENABLED(CONFIG_KGRAFT)
+	if (unlikely(test_thread_flag(TIF_KGR_IN_PROGRESS)))
+		kgr_task_safe(current);
+#endif
+
 out:
 	return ret ?: regs->orig_ax;
 }
--- a/arch/x86/kernel/signal.c
+++ b/arch/x86/kernel/signal.c
@@ -747,6 +747,11 @@ do_notify_resume(struct pt_regs *regs, v
 	if (thread_info_flags & _TIF_UPROBE)
 		uprobe_notify_resume(regs);
 
+#if IS_ENABLED(CONFIG_KGRAFT)
+	if (thread_info_flags & _TIF_KGR_IN_PROGRESS)
+		kgr_task_safe(current);
+#endif
+
 	/* deal with pending signal delivery */
 	if (thread_info_flags & _TIF_SIGPENDING)
 		do_signal(regs);
