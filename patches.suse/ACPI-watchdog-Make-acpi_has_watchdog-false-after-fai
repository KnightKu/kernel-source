From: Takashi Iwai <tiwai@suse.de>
Subject: [PATCH] ACPI / watchdog: Make acpi_has_watchdog() false after failing
 the device creation
Patch-mainline: No, temporary workaround until the upstream fix included
References: bsc#1073960

WDAT ACPI entry may conflict with other resources and the kernel gives
up creating it, and it ends up with the non-functional watchdog, since
iTCO_wdt also gives up when acpi_has_watchdog() returns true.

The best fix would be to allow ACPI WDAT gracefully handling the
resource conflict, and the upstream is working on it.  Meanwhile, as a
quick stop-gap solution, allow the iTCO_wdt working as before in such
a case as a fallback, until the upstream provides an actual solution.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/acpi/acpi_watchdog.c |    8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

--- a/drivers/acpi/acpi_watchdog.c
+++ b/drivers/acpi/acpi_watchdog.c
@@ -17,6 +17,8 @@
 
 #include "internal.h"
 
+static bool watchdog_failed;
+
 /**
  * Returns true if this system should prefer ACPI based watchdog instead of
  * the native one (which are typically the same hardware).
@@ -25,7 +27,7 @@ bool acpi_has_watchdog(void)
 {
 	struct acpi_table_header hdr;
 
-	if (acpi_disabled)
+	if (acpi_disabled || watchdog_failed)
 		return false;
 
 	return ACPI_SUCCESS(acpi_get_table_header(ACPI_SIG_WDAT, 0, &hdr));
@@ -44,6 +46,8 @@ void __init acpi_watchdog_init(void)
 	acpi_status status;
 	int i;
 
+	watchdog_failed = true;
+
 	status = acpi_get_table(ACPI_SIG_WDAT, 0,
 				(struct acpi_table_header **)&wdat);
 	if (ACPI_FAILURE(status)) {
@@ -115,6 +119,8 @@ void __init acpi_watchdog_init(void)
 					       resources, nresources);
 	if (IS_ERR(pdev))
 		pr_err("Device creation failed: %ld\n", PTR_ERR(pdev));
+	else
+		watchdog_failed = false; /* probe success */
 
 	kfree(resources);
 
