From 2a2d053db88c2fc6c9e5c057ebf87a007241da45 Mon Sep 17 00:00:00 2001
From: Mel Gorman <mgorman@suse.de>
Date: Wed, 6 Feb 2013 14:00:00 +0000
Subject: [PATCH] mm: Handle possibility of preemption in spin_trylock_page()
 and cancel

References: VM performance, lock page scalability (bnc#436953, bnc#629170)
Patch-mainline: No (Never, no compelling use case other than boot times on very large machines)

Should a SCHED_FIFO task preempt the task which should modify any of the
loop conditions, we can spin forever. This is because need_resched() never
becomes true.  This patch uses cpu_relax() until it needs to reschedule
or at least 1 lock tick has passed before going to sleep and unplugging IO.

Signed-off-by: Mike Galbraith <mgalbraith@suse.de>
Signed-off-by: Mel Gorman <mgorman@suse.de>
---
 mm/filemap.c | 14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)

diff --git a/mm/filemap.c b/mm/filemap.c
index 6e523a7..89e0852 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -676,6 +676,13 @@ enum trylock_page_status {
 	TRYLOCK_PAGE_SCHEDULE
 };
 
+/* Returns true if spin_trylock_page should continue */
+static bool continue_trylock_relax(unsigned long expires)
+{
+	cpu_relax();
+	return !(need_resched() || time_after(jiffies, expires));
+}
+
 /*
  * If a page is locked, clean and uptodate then in many cases the hold time
  * of the lock will be very short. It is better particularly on large machines
@@ -684,6 +691,8 @@ enum trylock_page_status {
  */
 static enum trylock_page_status spin_trylock_page(struct page *page)
 {
+	bool continue_spin = true;
+	unsigned long expires;
 	/*
 	 * Note that we do not spin for realtime tasks as a spinning realtime
 	 * realtime task could starve a non-rt holder of the page lock
@@ -692,8 +701,9 @@ static enum trylock_page_status spin_trylock_page(struct page *page)
 	if (!PageUptodate(page) || PageWriteback(page) || rt_task(current))
 		return TRYLOCK_PAGE_FAILURE;
 
-	while (PageUptodate(page) && !PageWriteback(page) && !need_resched()) {
-		cpu_relax();
+	expires = jiffies + 2;
+	while (PageUptodate(page) && !PageWriteback(page) && continue_spin) {
+		continue_spin = continue_trylock_relax(expires);
 		if (!PageLocked(page) && trylock_page(page))
 			return TRYLOCK_PAGE_SUCCESS;
 	}
