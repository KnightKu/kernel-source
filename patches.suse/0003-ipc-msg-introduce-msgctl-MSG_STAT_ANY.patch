From 66c7c4bfcad138851ff072021cd03d26c6f5c865 Mon Sep 17 00:00:00 2001i
From: Davidlohr Bueso <dave@stgolabs.net>
Date: Thu, 1 Mar 2018 07:28:25 -0800
Subject: [PATCH 2/3] ipc/msg: introduce msgctl(MSG_STAT_ANY)
Git-commit: 66c7c4bfcad138851ff072021cd03d26c6f5c865
Git-repo: git://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git
Patch-mainline: Queued in linux-next
References: bsc#1072689

There is a permission discrepancy when consulting msq ipc object metadata
between /proc/sysvipc/msg (0444) and the MSG_STAT shmctl command.  The
later does permission checks for the object vs S_IRUGO.  As such there can
be cases where EACCESS is returned via syscall but the info is displayed
anyways in the procfs files.

While this might have security implications via info leaking (albeit no
writing to the msq metadata), this behavior goes way back and showing all
the objects regardless of the permissions was most likely an overlook - so
we are stuck with it.  Furthermore, modifying either the syscall or the
procfs file can cause userspace programs to break (ie ipcs).  Some
applications require getting the procfs info (without root privileges) and
can be rather slow in comparison with a syscall -- up to 500x in some
reported cases for shm.

This patch introduces a new MSG_STAT_ANY command such that the msq ipc
object permissions are ignored, and only audited instead.  In addition,
I've left the lsm security hook checks in place, as if some policy can
block the call, then the user has no other choice than just parsing the
procfs file.

Link: http://lkml.kernel.org/r/20180215162458.10059-4-dave@stgolabs.net
Signed-off-by: Davidlohr Bueso <dbueso@suse.de>
Reported-by: Robert Kettler <robert.kettler@outlook.com>
Cc: Eric W. Biederman <ebiederm@xmission.com>
Cc: Kees Cook <keescook@chromium.org>
Cc: Manfred Spraul <manfred@colorfullife.com>
Cc: Michael Kerrisk <mtk.manpages@gmail.com>
Cc: Michal Hocko <mhocko@kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>

---
 include/linux/msg.h        |  1 +
 ipc/compat.c               |  1 +
 ipc/msg.c                  | 17 ++++++++++++-----
 security/selinux/hooks.c   |  1 +
 security/smack/smack_lsm.c |  1 +
 5 files changed, 16 insertions(+), 5 deletions(-)

diff --git a/include/linux/msg.h b/include/linux/msg.h
index 3bd2174a1586..888edafd3ca0 100644
--- a/include/linux/msg.h
+++ b/include/linux/msg.h
@@ -6,6 +6,7 @@
 /* ipcs ctl commands */
 #define MSG_STAT 11
 #define MSG_INFO 12
+#define MSG_STAT_ANY 13
 
 /* msgrcv options */
 #define MSG_NOERROR     010000  /* no error if message is too big */
diff --git a/ipc/compat.c b/ipc/compat.c
index ab2bbc13b72a..d02d035b4d73 100644
--- a/ipc/compat.c
+++ b/ipc/compat.c
@@ -450,6 +450,7 @@ long compat_sys_msgctl(int first, int second, void __user *uptr)
 
 	case IPC_STAT:
 	case MSG_STAT:
+	case MSG_STAT_ANY:
 		p = compat_alloc_user_space(sizeof(m64));
 		err = sys_msgctl(first, second, p);
 		if (err < 0)
diff --git a/ipc/msg.c b/ipc/msg.c
index 64131a9d48c6..247a088dedfc 100644
--- a/ipc/msg.c
+++ b/ipc/msg.c
@@ -520,6 +520,7 @@ SYSCALL_DEFINE3(msgctl, int, msqid, int, cmd, struct msqid_ds __user *, buf)
 	}
 	case MSG_STAT:	/* msqid is an index rather than a msg queue id */
 	case IPC_STAT:
+	case MSG_STAT_ANY:
 	{
 		struct msqid64_ds tbuf;
 		int success_return;
@@ -527,20 +528,26 @@ SYSCALL_DEFINE3(msgctl, int, msqid, int, cmd, struct msqid_ds __user *, buf)
 		if (!buf)
 			return -EFAULT;
 
-		if (cmd == MSG_STAT) {
+		if (cmd == MSG_STAT || MSG_STAT_ANY) {
 			msq = msg_lock(ns, msqid);
 			if (IS_ERR(msq))
 				return PTR_ERR(msq);
 			success_return = msq->q_perm.id;
-		} else {
+		} else { /* IPC_STAT */
 			msq = msg_lock_check(ns, msqid);
 			if (IS_ERR(msq))
 				return PTR_ERR(msq);
 			success_return = 0;
 		}
-		err = -EACCES;
-		if (ipcperms(ns, &msq->q_perm, S_IRUGO))
-			goto out_unlock;
+
+		/* see comment for SHM_STAT_ANY */
+		if (cmd == MSG_STAT_ANY)
+			audit_ipc_obj(&msq->q_perm);
+		else {
+			err = -EACCES;
+			if (ipcperms(ns, &msq->q_perm, S_IRUGO))
+				goto out_unlock;
+		}
 
 		err = security_msg_queue_msgctl(msq, cmd);
 		if (err)
diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c
index 866cca26e990..cf68c2eaa385 100644
--- a/security/selinux/hooks.c
+++ b/security/selinux/hooks.c
@@ -4895,6 +4895,7 @@ static int selinux_msg_queue_msgctl(struct msg_queue *msq, int cmd)
 		return task_has_system(current, SYSTEM__IPC_INFO);
 	case IPC_STAT:
 	case MSG_STAT:
+	case MSG_STAT_ANY:
 		perms = MSGQ__GETATTR | MSGQ__ASSOCIATE;
 		break;
 	case IPC_SET:
diff --git a/security/smack/smack_lsm.c b/security/smack/smack_lsm.c
index eedbac77bb2b..d37a0a7d2986 100644
--- a/security/smack/smack_lsm.c
+++ b/security/smack/smack_lsm.c
@@ -2397,6 +2397,7 @@ static int smack_msg_queue_msgctl(struct msg_queue *msq, int cmd)
 	switch (cmd) {
 	case IPC_STAT:
 	case MSG_STAT:
+	case MSG_STAT_ANY:
 		may = MAY_READ;
 		break;
 	case IPC_SET:
-- 
2.13.6

