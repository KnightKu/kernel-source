From: Petr Mladek <pmladek@suse.cz>
Date: Thu, 8 Jan 2015 17:58:06 +0100
Subject: kgr: handle IRQ context using global variable
Patch-mainline: submitted for review
References: fate#313296 bnc#912278

kgr_revert_replaced_funs() calls kgr_patch_code() for finalized patches.
It sets the slow stub and allows a correct revert of obsolete patches.

The problem is that kgr_stub_slow() accesses this_cpu_ptr(p->patch->irq_use_new)
and this variable is available only for the patch is progress.

In fact, the state of the IRQ context is not specific to a particular patch.
It should be handled by a global variable.

This patch takes the minimalist approach and just replaces the patch-specific
variable with a global one. It is still allocated when a patch is manipulated
and freed when the patch is finalized. It has the advantage that we do not
take the per-CPU memory when not needed. Also we do not need to reset it
when patching starts.

I also thought about renaming the variable to kgr_irq_in_progress. In fact,
it has the same meaning as the TIF_KGR_IN_PROGRESS flag. But it would revert
the logic and we would need to initialize the value to true. Therefore
I kept it as is for now.

Signed-off-by: Petr Mladek <pmladek@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 include/linux/kgraft.h |  2 --
 kernel/kgraft.c        | 13 +++++++------
 2 files changed, 7 insertions(+), 8 deletions(-)

diff --git a/include/linux/kgraft.h b/include/linux/kgraft.h
index 6bfed8cc8575..6f201848eaf3 100644
--- a/include/linux/kgraft.h
+++ b/include/linux/kgraft.h
@@ -75,7 +75,6 @@ struct kgr_patch_fun {
  * @kobj: object representing the sysfs entry
  * @list: member in patches list
  * @finish: waiting till it is safe to remove the module with the patch
- * @irq_use_new: per-cpu array to remember kGraft state for interrupts
  * @refs: how many patches need to be reverted before this one
  * @name: name of the patch (to appear in sysfs)
  * @owner: module to refcount on patching
@@ -88,7 +87,6 @@ struct kgr_patch {
 	struct kobject kobj;
 	struct list_head list;
 	struct completion finish;
-	bool __percpu *irq_use_new;
 	unsigned int refs;
 
 	/* a patch shall set these */
diff --git a/kernel/kgraft.c b/kernel/kgraft.c
index de4bf6e210be..056737d1a776 100644
--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -37,6 +37,7 @@ static struct workqueue_struct *kgr_wq;
 static DECLARE_DELAYED_WORK(kgr_work, kgr_work_fn);
 static DEFINE_MUTEX(kgr_in_progress_lock);
 static LIST_HEAD(kgr_patches);
+static bool __percpu *kgr_irq_use_new;
 bool kgr_in_progress;
 static bool kgr_initialized;
 static struct kgr_patch *kgr_patch;
@@ -73,7 +74,7 @@ static notrace void kgr_stub_slow(unsigned long ip, unsigned long parent_ip,
 	bool go_old;
 
 	if (in_interrupt())
-		go_old = !*this_cpu_ptr(p->patch->irq_use_new);
+		go_old = !*this_cpu_ptr(kgr_irq_use_new);
 	else if (test_bit(0, kgr_immutable)) {
 		kgr_mark_task_in_progress(current);
 		go_old = true;
@@ -234,7 +235,7 @@ static void kgr_finalize(void)
 		kgr_remove_patches_fast();
 	}
 
-	free_percpu(kgr_patch->irq_use_new);
+	free_percpu(kgr_irq_use_new);
 
 	if (kgr_revert) {
 		kgr_refs_dec();
@@ -337,7 +338,7 @@ static void kgr_handle_irq_cpu(struct work_struct *work)
 	unsigned long flags;
 
 	local_irq_save(flags);
-	*this_cpu_ptr(kgr_patch->irq_use_new) = true;
+	*this_cpu_ptr(kgr_irq_use_new) = true;
 	local_irq_restore(flags);
 }
 
@@ -718,8 +719,8 @@ int kgr_modify_kernel(struct kgr_patch *patch, bool revert)
 		goto err_unlock;
 	}
 
-	patch->irq_use_new = alloc_percpu(bool);
-	if (!patch->irq_use_new) {
+	kgr_irq_use_new = alloc_percpu(bool);
+	if (!kgr_irq_use_new) {
 		pr_err("kgr: can't patch, cannot allocate percpu data\n");
 		ret = -ENOMEM;
 		goto err_unlock;
@@ -788,7 +789,7 @@ int kgr_modify_kernel(struct kgr_patch *patch, bool revert)
 
 	return 0;
 err_free:
-	free_percpu(patch->irq_use_new);
+	free_percpu(kgr_irq_use_new);
 err_unlock:
 	mutex_unlock(&kgr_in_progress_lock);
 
-- 
2.2.1

