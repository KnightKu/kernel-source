From: K. Y. Srinivasan <kys@microsoft.com>
Date: Thu, 29 Sep 2011 11:54:58 -0700
Patch-mainline: v3.2-rc1
Subject: [PATCH] Staging: hv: mousevsc: Now cleanup mousevsc_remove()
Git-commit: c411f17daf0942509f6db47b4a237e953f35611b

Now, cleanup mousevsc_remove(). The mouse driver once initialized only
receives data from the host. So, by closing the channel first in the
unload path, we can properly deal with inflight packets. So, we don't need
the machinery for managing the life-cycle of the mousevsc_dev object.
Get rid of the unnecessary code.

Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/hv/hv_mouse.c |   53 ++--------------------------------------
 1 files changed, 3 insertions(+), 50 deletions(-)

diff --git a/drivers/staging/hv/hv_mouse.c b/drivers/staging/hv/hv_mouse.c
index 5324429..317d2be 100644
--- a/drivers/staging/hv/hv_mouse.c
+++ b/drivers/staging/hv/hv_mouse.c
@@ -197,9 +197,9 @@ static struct mousevsc_dev *alloc_input_device(struct hv_device *device)
 
 static void free_input_device(struct mousevsc_dev *device)
 {
-	WARN_ON(atomic_read(&device->ref_count) != 0);
 	kfree(device->hid_desc);
 	kfree(device->report_desc);
+	hv_set_drvdata(device->device, NULL);
 	kfree(device);
 }
 
@@ -229,39 +229,6 @@ static void put_input_device(struct hv_device *device)
 	atomic_dec(&input_dev->ref_count);
 }
 
-/*
- * Drop ref count to 1 to effectively disable get_input_device()
- */
-static struct mousevsc_dev *release_input_device(struct hv_device *device)
-{
-	struct mousevsc_dev *input_dev;
-
-	input_dev = hv_get_drvdata(device);
-
-	/* Busy wait until the ref drop to 2, then set it to 1  */
-	while (atomic_cmpxchg(&input_dev->ref_count, 2, 1) != 2)
-		udelay(100);
-
-	return input_dev;
-}
-
-/*
- * Drop ref count to 0. No one can use input_device object.
- */
-static struct mousevsc_dev *final_release_input_device(struct hv_device *device)
-{
-	struct mousevsc_dev *input_dev;
-
-	input_dev = hv_get_drvdata(device);
-
-	/* Busy wait until the ref drop to 1, then set it to 0  */
-	while (atomic_cmpxchg(&input_dev->ref_count, 1, 0) != 1)
-		udelay(100);
-
-	hv_set_drvdata(device, NULL);
-	return input_dev;
-}
-
 
 static void mousevsc_on_receive_device_info(struct mousevsc_dev *input_device,
 				struct synthhid_device_info *device_info)
@@ -673,28 +640,14 @@ static int mousevsc_remove(struct hv_device *dev)
 {
 	struct mousevsc_dev *input_dev = hv_get_drvdata(dev);
 
+	vmbus_close(dev->channel);
+
 	if (input_dev->connected) {
 		hidinput_disconnect(input_dev->hid_device);
 		input_dev->connected = 0;
 		hid_destroy_device(input_dev->hid_device);
 	}
 
-
-	release_input_device(dev);
-
-
-	/*
-	 * At this point, all outbound traffic should be disable. We only
-	 * allow inbound traffic (responses) to proceed
-	 *
-	 * so that outstanding requests can be completed.
-	 */
-
-	input_dev = final_release_input_device(dev);
-
-	/* Close the channel */
-	vmbus_close(dev->channel);
-
 	free_input_device(input_dev);
 
 	return 0;
-- 
1.6.0.2


