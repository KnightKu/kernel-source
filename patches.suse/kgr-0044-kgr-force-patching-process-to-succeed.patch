From: Miroslav Benes <mbenes@suse.cz>
Date: Tue, 4 Nov 2014 15:27:33 +0100
Subject: kgr: force patching process to succeed
Patch-mainline: submitted for review
References: fate#313296

Patching process can be blocked by kernel thread which has not be amended with
kgr_task_safe() call. Thus we need to have a possibility to mark such thread as
migrated on request.

The patch makes the global attribute kgr_in_progress in kgraft sysfs directory
writable. 'echo 0 > /sys/kernel/kgraft/in_progress' clears the
TIF_KGR_IN_PROGRESS flag for all processes. With that patching process should
finish successfully.

Clearing of the flag is done using kgr_task_safe(). After that it is necessary
to keep the patches list and stuff in the correct state and set internal
kgr_in_progress flag to false. This is however done by kgr_finalize() called by
running workqueue.

Signed-off-by: Miroslav Benes <mbenes@suse.cz>
Reviewed-by: Jiri Kosina <jkosina@suse.cz>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 include/linux/kgraft.h |  1 +
 kernel/kgraft.c        | 10 ++++++++++
 kernel/kgraft_files.c  | 14 +++++++++++++-
 3 files changed, 24 insertions(+), 1 deletion(-)

diff --git a/include/linux/kgraft.h b/include/linux/kgraft.h
index f02d8025588b..f9f88e4c2134 100644
--- a/include/linux/kgraft.h
+++ b/include/linux/kgraft.h
@@ -115,6 +115,7 @@ extern bool kgr_in_progress;
 extern int kgr_patch_kernel(struct kgr_patch *);
 extern void kgr_patch_remove(struct kgr_patch *);
 
+extern void kgr_unmark_processes(void);
 extern int kgr_modify_kernel(struct kgr_patch *patch, bool revert, bool force);
 extern void kgr_module_init(const struct module *mod);
 extern int kgr_patch_dir_add(struct kgr_patch *patch);
diff --git a/kernel/kgraft.c b/kernel/kgraft.c
index ca42674f1783..ccb497946abe 100644
--- a/kernel/kgraft.c
+++ b/kernel/kgraft.c
@@ -292,6 +292,16 @@ static void kgr_work_fn(struct work_struct *work)
 	kgr_finalize();
 }
 
+void kgr_unmark_processes(void)
+{
+	struct task_struct *p;
+
+	read_lock(&tasklist_lock);
+	for_each_process(p)
+		kgr_task_safe(p);
+	read_unlock(&tasklist_lock);
+}
+
 static void kgr_handle_processes(void)
 {
 	struct task_struct *p;
diff --git a/kernel/kgraft_files.c b/kernel/kgraft_files.c
index 0a39c2434d70..0dff3da29b08 100644
--- a/kernel/kgraft_files.c
+++ b/kernel/kgraft_files.c
@@ -153,7 +153,19 @@ static ssize_t in_progress_show(struct kobject *kobj,
 	return snprintf(buf, PAGE_SIZE, "%d\n", kgr_in_progress);
 }
 
-static struct kobj_attribute kgr_attr_in_progress = __ATTR_RO(in_progress);
+static ssize_t in_progress_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	if (count == 0 || buf[0] != '0')
+		return -EINVAL;
+
+	kgr_unmark_processes();
+	WARN(1, "kgr: all processes marked as migrated on admin's request\n");
+
+	return count;
+}
+
+static struct kobj_attribute kgr_attr_in_progress = __ATTR_RW(in_progress);
 
 static struct attribute *kgr_sysfs_entries[] = {
 	&kgr_attr_in_progress.attr,
-- 
2.1.3

