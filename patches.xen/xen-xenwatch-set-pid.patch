From: Juergen Gross <jgross@suse.com>
Date: Fri, 28 Jul 2017 16:23:59 +0200
Subject: [PATCH] xen: avoid deadlock in xenbus
References: bnc#1047523
Patch-mainline: Submitted, 28 Jul 2017 - LKML

When starting the xenwatch thread a deadlock situation is possible:

xs_init() contains:

    task = kthread_run(xenwatch_thread, NULL, "xenwatch");
    if (IS_ERR(task))
        return PTR_ERR(task);
    xenwatch_pid = task->pid;

And xenwatch_thread() does:

    mutex_lock(&xenwatch_mutex);
    ...
    xenwatch_handle_callback(msg);
    mutex_unlock(&xenwatch_mutex);

xenwatch_handle_callback(9 does:

    ...
    if (current->pid != xenwatch_pid)
	do_exit(0);

So xenwatch_mutex will be held for ever in case a watch event is being
handled by the xenwatch thread before xenwatch_pid has been set.

Avoid this by setting xenwatch_pid in xenwatch_thread().

Signed-off-by: Juergen Gross <jgross@suse.com>
---
 drivers/xen/xenbus/xenbus_xs.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff -pdaur a/drivers/xen/xenbus/xenbus_xs.c b/drivers/xen/xenbus/xenbus_xs.c
--- a/drivers/xen/xenbus/xenbus_xs.c
+++ b/drivers/xen/xenbus/xenbus_xs.c
@@ -787,6 +787,8 @@ static int xenwatch_thread(void *unused)
 	struct xs_stored_msg *msg;
 
 	current->flags |= PF_NOFREEZE;
+	xenwatch_pid = current->pid;
+
 	for (;;) {
 		wait_event_interruptible(watch_events_waitq,
 					 !list_empty(&watch_events));
@@ -977,7 +979,6 @@ xs_init(void)
 	task = kthread_run(xenwatch_thread, NULL, "xenwatch");
 	if (IS_ERR(task))
 		return PTR_ERR(task);
-	xenwatch_pid = task->pid;
 
 	task = kthread_run(xenbus_thread, NULL, "xenbus");
 	if (IS_ERR(task))
