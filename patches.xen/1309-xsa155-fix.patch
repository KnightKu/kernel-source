From http://xenbits.xen.org/hg/linux-2.6.18-xen.hg/rev/d018557a9a50
From: xen-devel@lists.xenproject.org
Patch-mainline: Never, SUSE-Xen specific
Subject: pciback: Save the number of MSI-X entries to be copied later
References: bsc#957988

c/s 8135cf8b092723dbfcc611fe6fdcb3a36c9951c5
"xen/pciback: Save xen_pci_op commands before processing it"
would copyback the processed values - which was great.

However it missed the case that xen_pcibk_enable_msix - when
completing would overwrite op->value (which had the number
of MSI-X vectors requested) with the return value (which for
success was zero). Hence the copy-back routine (which would use
op->value) would copy exactly zero MSI-X vectors back.

Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Committed-by: Jan Beulich <jbeulich@suse.com>

--- a/drivers/xen/pciback/pciback_ops.c
+++ b/drivers/xen/pciback/pciback_ops.c
@@ -80,6 +80,9 @@ void pciback_do_op(void *data)
 	struct pciback_device *pdev = data;
 	struct pci_dev *dev;
 	struct xen_pci_op *op = &pdev->op;
+#ifdef CONFIG_PCI_MSI
+	unsigned int nr = 0;
+#endif
 
 	*op = pdev->sh_info->op;
 	barrier();
@@ -107,6 +110,7 @@ void pciback_do_op(void *data)
 				op->err = pciback_disable_msi(pdev, dev, op);
 				break;
 			case XEN_PCI_OP_enable_msix:
+				nr = op->value;
 				op->err = pciback_enable_msix(pdev, dev, op);
 				break;
 			case XEN_PCI_OP_disable_msix:
@@ -124,7 +128,7 @@ void pciback_do_op(void *data)
 	if (op->cmd == XEN_PCI_OP_enable_msix && op->err == 0) {
 		unsigned int i;
 
-		for (i = 0; i < op->value; i++)
+		for (i = 0; i < nr; i++)
 			pdev->sh_info->op.msix_entries[i].vector =
 				op->msix_entries[i].vector;
 	}
