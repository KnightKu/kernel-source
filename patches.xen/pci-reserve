Subject: linux/pci: reserve io/memory space for bridge
From: http://xenbits.xensource.com/linux-2.6.18-xen.hg (tip 1010:10eae161c153)
Patch-mainline: Never, SUSE-Xen specific
References: none

reserve io/memory space for bridge which will be used later
by PCI hotplug.

Signed-off-by: Isaku Yamahata <yamahata@valinux.co.jp>
Acked-by: jbeulich@novell.com

--- a/Documentation/admin-guide/kernel-parameters.txt
+++ b/Documentation/admin-guide/kernel-parameters.txt
@@ -2986,6 +2986,13 @@
 				only look for one device below a PCIe downstream
 				port.
 
+	pci_reserve=	[PCI]
+			Format: [<sbdf>[+IO<size>][+MEM<size>]][,<sbdf>...]
+			Format of sbdf: [<segment>:]<bus>:<dev>.<func>
+			Specifies the least reserved io size or memory size
+			which is assigned to PCI bridge even when no child
+			pci device exists. This is useful with PCI hotplug.
+
 	pcie_aspm=	[PCIE] Forcibly enable or disable PCIe Active State Power
 			Management.
 		off	Disable ASPM.
--- a/drivers/pci/Kconfig
+++ b/drivers/pci/Kconfig
@@ -66,6 +66,13 @@ config PCI_IOMULTI
 	help
 	  Say Y here if you need io multiplexing.
 
+config PCI_RESERVE
+	bool "PCI IO/MEMORY space reserve"
+	depends on PCI && XEN_PRIVILEGED_GUEST
+	default y
+	help
+	  Say Y here if you need PCI IO/MEMORY space reserve
+
 config PCI_STUB
 	tristate "PCI Stub driver"
 	depends on PCI
--- a/drivers/pci/Makefile
+++ b/drivers/pci/Makefile
@@ -11,6 +11,7 @@ obj-$(CONFIG_PCI_GUESTDEV) += guestdev.o
 obj-$(CONFIG_PCI_IOMULTI) += pci-iomul.o
 iomul-$(CONFIG_PCI_IOMULTI) := iomulti.o
 obj-y += $(iomul-y) $(iomul-m)
+obj-$(CONFIG_PCI_RESERVE) += reserve.o
 
 obj-$(CONFIG_PCI_QUIRKS) += quirks.o
 
--- a/drivers/pci/pci.h
+++ b/drivers/pci/pci.h
@@ -361,4 +361,19 @@ extern int pci_is_iomuldev(struct pci_de
 #define pci_is_iomuldev(dev) 0
 #endif
 
+#ifdef CONFIG_PCI_RESERVE
+unsigned long pci_reserve_size_io(struct pci_bus *bus);
+unsigned long pci_reserve_size_mem(struct pci_bus *bus);
+#else
+static inline unsigned long pci_reserve_size_io(struct pci_bus *bus)
+{
+	return 0;
+}
+
+static inline unsigned long pci_reserve_size_mem(struct pci_bus *bus)
+{
+	return 0;
+}
+#endif /* CONFIG_PCI_RESERVE */
+
 #endif /* DRIVERS_PCI_H */
--- /dev/null
+++ b/drivers/pci/reserve.c
@@ -0,0 +1,137 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ *
+ * Copyright (c) 2009 Isaku Yamahata
+ *                    VA Linux Systems Japan K.K.
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+
+#include <asm/setup.h>
+
+static char pci_reserve_param[COMMAND_LINE_SIZE];
+
+/* pci_reserve=	[PCI]
+ * Format: [<sbdf>[+IO<size>][+MEM<size>]][,<sbdf>...]
+ * Format of sbdf: [<segment>:]<bus>:<dev>.<func>
+ */
+static int pci_reserve_parse_size(const char *str,
+				  unsigned long *io_size,
+				  unsigned long *mem_size)
+{
+	if (sscanf(str, "io%lx", io_size) == 1 ||
+	    sscanf(str, "IO%lx", io_size) == 1)
+		return 0;
+
+	if (sscanf(str, "mem%lx", mem_size) == 1 ||
+	    sscanf(str, "MEM%lx", mem_size) == 1)
+		return 0;
+
+	return -EINVAL;
+}
+
+static int pci_reserve_parse_one(const char *str,
+				 int *seg, int *bus, int *dev, int *func,
+				 unsigned long *io_size,
+				 unsigned long *mem_size)
+{
+	char *p;
+
+	*io_size = 0;
+	*mem_size = 0;
+
+	if (sscanf(str, "%x:%x:%x.%x", seg, bus, dev, func) != 4) {
+		*seg = 0;
+		if (sscanf(str, "%x:%x.%x", bus, dev, func) != 3) {
+			return -EINVAL;
+		}
+	}
+
+	p = strchr(str, '+');
+	if (p == NULL)
+		return -EINVAL;
+	if (pci_reserve_parse_size(++p, io_size, mem_size))
+		return -EINVAL;
+
+	p = strchr(p, '+');
+	return p ? pci_reserve_parse_size(p + 1, io_size, mem_size) : 0;
+}
+
+static unsigned long pci_reserve_size(struct pci_bus *pbus, int flags)
+{
+	char *sp;
+	char *ep;
+
+	int seg;
+	int bus;
+	int dev;
+	int func;
+
+	unsigned long io_size;
+	unsigned long mem_size;
+
+	sp = pci_reserve_param;
+
+	do {
+		ep = strchr(sp, ',');
+		if (ep)
+			*ep = '\0';	/* chomp */
+
+		if (pci_reserve_parse_one(sp, &seg, &bus, &dev, &func,
+					  &io_size, &mem_size) == 0) {
+			if (pci_domain_nr(pbus) == seg &&
+			    pbus->number == bus &&
+			    PCI_SLOT(pbus->self->devfn) == dev &&
+			    PCI_FUNC(pbus->self->devfn) == func) {
+				switch (flags) {
+				case IORESOURCE_IO:
+					return io_size;
+				case IORESOURCE_MEM:
+					return mem_size;
+				default:
+					break;
+				}
+			}
+		}
+
+		if (ep) {
+			*ep = ',';	/* restore chomp'ed ',' for later */
+			ep++;
+		}
+		sp = ep;
+	} while (ep);
+
+	return 0;
+}
+
+unsigned long pci_reserve_size_io(struct pci_bus *pbus)
+{
+	return pci_reserve_size(pbus, IORESOURCE_IO);
+}
+
+unsigned long pci_reserve_size_mem(struct pci_bus *pbus)
+{
+	return pci_reserve_size(pbus, IORESOURCE_MEM);
+}
+
+static int __init pci_reserve_setup(char *str)
+{
+	if (!is_initial_xendomain() || strlen(str) >= sizeof(pci_reserve_param))
+		return 0;
+	strlcpy(pci_reserve_param, str, sizeof(pci_reserve_param));
+	return 1;
+}
+__setup("pci_reserve=", pci_reserve_setup);
--- a/drivers/pci/setup-bus.c
+++ b/drivers/pci/setup-bus.c
@@ -910,7 +910,7 @@ static void pbus_size_io(struct pci_bus
 	struct pci_dev *dev;
 	struct resource *b_res = find_free_bus_resource(bus, IORESOURCE_IO,
 							IORESOURCE_IO);
-	resource_size_t size = 0, size0 = 0, size1 = 0;
+	resource_size_t size = 0, size0 = 0, size1 = 0, res_size;
 	resource_size_t children_add_size = 0;
 	resource_size_t min_align, align;
 
@@ -951,6 +951,11 @@ static void pbus_size_io(struct pci_bus
 	size1 = (!realloc_head || (realloc_head && !add_size)) ? size0 :
 		calculate_iosize(size, min_size, add_size + size1,
 			resource_size(b_res), min_align);
+	res_size = pci_reserve_size_io(bus);
+	if (size0 < res_size)
+		size0 = ALIGN(res_size, min_align);
+	if (size1 < res_size)
+		size1 = ALIGN(res_size, min_align);
 	if (!size0 && !size1) {
 		if (b_res->start || b_res->end)
 			dev_info(&bus->self->dev, "disabling bridge window %pR to %pR (unused)\n",
@@ -1093,6 +1098,7 @@ static int pbus_size_mem(struct pci_bus
 
 	min_align = calculate_mem_align(aligns, max_order);
 	min_align = max(min_align, window_alignment(bus, b_res->flags));
+	size = max(size, (resource_size_t)pci_reserve_size_mem(bus));
 	size0 = calculate_memsize(size, min_size, 0, resource_size(b_res), min_align);
 	add_align = max(min_align, add_align);
 	if (children_add_size > add_size)
