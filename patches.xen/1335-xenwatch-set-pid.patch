From http://xenbits.xen.org/hg/linux-2.6.18-xen.hg/rev/47fd5e5ac7f7
From: xen-devel@lists.xenproject.org
Patch-mainline: Never, SUSE-Xen specific
Subject: avoid deadlock in xenbus
References: bnc#1047523

When starting the xenwatch thread a deadlock situation is possible:

xs_init() contains:

    task = kthread_run(xenwatch_thread, NULL, "xenwatch");
    if (IS_ERR(task))
        return PTR_ERR(task);
    xenwatch_pid = task->pid;

And xenwatch_thread() does:

    mutex_lock(&xenwatch_mutex);
    ...
    xenwatch_handle_callback(msg);
    mutex_unlock(&xenwatch_mutex);

xenwatch_handle_callback() does:

    ...
    if (current->pid != xenwatch_pid)
	do_exit(0);

So xenwatch_mutex will be held for ever in case a watch event is being
handled by the xenwatch thread before xenwatch_pid has been set.

Avoid this by setting xenwatch_pid in xenwatch_thread().

Signed-off-by: Juergen Gross <jgross@suse.com>
Committed-by: Jan Beulich <jbeulich@suse.com>

--- a/drivers/xen/xenbus/xenbus_xs.c
+++ b/drivers/xen/xenbus/xenbus_xs.c
@@ -776,6 +776,8 @@ static int xenwatch_thread(void *unused)
 	struct xs_stored_msg *msg;
 
 	current->flags |= PF_NOFREEZE;
+	xenwatch_pid = current->pid;
+
 	for (;;) {
 		wait_event_interruptible(watch_events_waitq,
 					 !list_empty(&watch_events));
@@ -950,7 +952,6 @@ int xs_init(void)
 	task = kthread_run(xenwatch_thread, NULL, "xenwatch");
 	if (IS_ERR(task))
 		return PTR_ERR(task);
-	xenwatch_pid = task->pid;
 
 	task = kthread_run(xenbus_thread, NULL, "xenbus");
 	if (IS_ERR(task))
