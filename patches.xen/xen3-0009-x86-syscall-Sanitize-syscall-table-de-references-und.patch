From: Dan Williams <dan.j.williams@intel.com>
Date: Mon, 29 Jan 2018 17:02:59 -0800
Subject: xen/x86/syscall: Sanitize syscall table de-references under speculation
Patch-mainline: Never, SUSE-Xen specific
References: bsc#1068032 bsc#1082860 CVE-2017-5753

The syscall table base is a user controlled function pointer in kernel
space. Use array_index_nospec() to prevent any out of bounds speculation.

While retpoline prevents speculating into a userspace directed target it
does not stop the pointer de-reference, the concern is leaking memory
relative to the syscall table base, by observing instruction cache
behavior.

[js] 64bit syscall entry is still in asm in 4.4

Reported-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Cc: linux-arch@vger.kernel.org
Cc: kernel-hardening@lists.openwall.com
Cc: gregkh@linuxfoundation.org
Cc: Andy Lutomirski <luto@kernel.org>
Cc: alan@linux.intel.com
Link: https://lkml.kernel.org/r/151727417984.33451.1216731042505722161.stgit@dwillia2-desk3.amr.corp.intel.com
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
Automatically created from "patches.suse/0009-x86-syscall-Sanitize-syscall-table-de-references-und.patch" by xen-port-patches.py

--- a/arch/x86/ia32/ia32entry-xen.S
+++ b/arch/x86/ia32/ia32entry-xen.S
@@ -158,8 +158,10 @@ ENTRY(ia32_sysenter_target)
 	movl $AUDIT_ARCH_I386,%edi	/* 1st arg: audit arch */
 	call audit_syscall_entry
 	movl RAX-ARGOFFSET(%rsp),%eax	/* reload syscall number */
-	cmpq $(IA32_NR_syscalls-1),%rax
-	ja ia32_badsys
+	cmpl $IA32_NR_syscalls,%eax
+	jae ia32_badsys
+	sbbl %edi,%edi			/* array_index_mask_nospec() */
+	andl %edi,%eax
 	movl %ebx,%edi			/* reload 1st syscall arg */
 	movl RCX-ARGOFFSET(%rsp),%esi	/* reload 2nd syscall arg */
 	movl RDX-ARGOFFSET(%rsp),%edx	/* reload 3rd syscall arg */
@@ -223,9 +225,11 @@ ENTRY(ia32_cstar_target)
 	orl   $TS_COMPAT,TI_status(%r10)
 	testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%r10)
 	jnz   cstar_tracesys
-	cmpq $IA32_NR_syscalls-1,%rax
-	ja  ia32_badsys
+	cmpl $IA32_NR_syscalls,%eax
+	jae ia32_badsys
 cstar_do_call:
+	sbbq %r10,%r10			/* array_index_mask_nospec() */
+	andq %r10,%rax
 	IA32_ARG_FIXUP 1
 	
 #ifdef CONFIG_AUDITSYSCALL
@@ -250,8 +254,8 @@ cstar_tracesys:
 	LOAD_ARGS32 ARGOFFSET, 1  /* reload args from stack in case ptrace changed it */
 	RESTORE_REST
 	xchgl %ebp,%r9d
-	cmpq $(IA32_NR_syscalls-1),%rax
-	ja int_ret_from_sys_call /* cstar_tracesys has set RAX(%rsp) */
+	cmpl IA32_NR_syscalls,%eax
+	jae int_ret_from_sys_call /* cstar_tracesys has set RAX(%rsp) */
 	jmp cstar_do_call
 END(ia32_cstar_target)
 				
@@ -307,9 +311,11 @@ ENTRY(ia32_syscall)
 	testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%r10)
 	jnz ia32_tracesys
 .Lia32_check_call:
-	cmpq $(IA32_NR_syscalls-1),%rax
-	ja ia32_badsys
+	cmpl $IA32_NR_syscalls,%eax
+	jae ia32_badsys
 ia32_do_call:
+	sbbq %r10,%r10			/* array_index_mask_nospec() */
+	andq %r10,%rax
 	IA32_ARG_FIXUP
 .Lia32_dispatch:
 	call *ia32_sys_call_table(,%rax,8) # xxx: rip relative
@@ -331,8 +337,8 @@ ia32_tracesys:
 	call syscall_trace_enter
 	LOAD_ARGS32 ARGOFFSET  /* reload args from stack in case ptrace changed it */
 	RESTORE_REST
-	cmpq $(IA32_NR_syscalls-1),%rax
-	ja  int_ret_from_sys_call	/* ia32_tracesys has set RAX(%rsp) */
+	cmpl $IA32_NR_syscalls,%eax
+	jae int_ret_from_sys_call	/* ia32_tracesys has set RAX(%rsp) */
 	jmp ia32_do_call
 END(ia32_syscall)
 
--- a/arch/x86/kernel/entry_64-xen.S
+++ b/arch/x86/kernel/entry_64-xen.S
@@ -497,8 +497,10 @@ ENTRY(system_call)
 	testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%rcx)
 	jnz tracesys
 system_call_fastpath:
-	cmpq $__NR_syscall_max,%rax
-	ja badsys
+	cmpq $NR_syscalls,%rax
+	jae badsys
+	sbbl %ecx,%ecx			/* array_index_mask_nospec() */
+	andl %ecx,%eax
 	movq %r10,%rcx
 	call *sys_call_table(,%rax,8)  # XXX:	 rip relative
 	movq %rax,RAX-ARGOFFSET(%rsp)
@@ -611,8 +613,10 @@ tracesys:
 	 */
 	LOAD_ARGS ARGOFFSET, 1
 	RESTORE_REST
-	cmpq $__NR_syscall_max,%rax
-	ja   int_ret_from_sys_call	/* RAX(%rsp) set to -ENOSYS above */
+	cmpq $NR_syscalls,%rax
+	jae  int_ret_from_sys_call	/* RAX(%rsp) set to -ENOSYS above */
+	sbbl %ecx,%ecx			/* array_index_mask_nospec() */
+	andl %ecx,%eax
 	movq %r10,%rcx	/* fixup for C */
 	call *sys_call_table(,%rax,8)
 	movq %rax,RAX-ARGOFFSET(%rsp)
