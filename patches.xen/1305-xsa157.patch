From http://xenbits.xen.org/hg/linux-2.6.18-xen.hg/rev/ed2cdf550df2
From: xen-devel@lists.xenproject.org
Patch-mainline: Never, SUSE-Xen specific
Subject: pciback: for XEN_PCI_OP_disable_msi[|x] only disable if device has MSI(X) enabled

Otherwise just continue on, returning the same values as
previously (return of 0, and op->result has the PIRQ value).

This does not change the behavior of XEN_PCI_OP_disable_msi[|x].

The pci_disable_msi or pci_disable_msix have the checks for
msi_enabled or msix_enabled so they will error out immediately.

However the guest can still call these operations and cause
us to disable the 'ack_intr'. That means the backend IRQ handler
for the legacy interrupt will not respond to interrupts anymore.

This will lead to (if the device is causing an interrupt storm)
for the Linux generic code to disable the interrupt line.

Naturally this will only happen if the device in question
is plugged in on the motherboard on shared level interrupt GSI.

This is part of CVE-2015-8551 + CVE-2015-8552 / XSA-157.

Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Reviewed-by: David Vrabel <david.vrabel@citrix.com>
Committed-by: Jan Beulich <jbeulich@suse.com>
Acked-by: jbeulich@suse.com

--- a/drivers/xen/pciback/conf_space_capability_msi.c
+++ b/drivers/xen/pciback/conf_space_capability_msi.c
@@ -35,7 +35,8 @@ int pciback_enable_msi(struct pciback_de
 int pciback_disable_msi(struct pciback_device *pdev,
 		struct pci_dev *dev, struct xen_pci_op *op)
 {
-	pci_disable_msi(dev);
+	if (dev->msi_enabled)
+		pci_disable_msi(dev);
 
 	op->value = dev->irq;
 	return 0;
@@ -82,8 +83,8 @@ int pciback_enable_msix(struct pciback_d
 int pciback_disable_msix(struct pciback_device *pdev,
 		struct pci_dev *dev, struct xen_pci_op *op)
 {
-
-	pci_disable_msix(dev);
+	if (dev->msix_enabled)
+		pci_disable_msix(dev);
 
 	op->value = dev->irq;
 	return 0;
