From d2075bcd52353319b5837903ab75cfd6b27ac749 Mon Sep 17 00:00:00 2001
From: Rik van Riel <riel@redhat.com>
Date: Tue, 6 Nov 2012 09:54:47 +0000
Patch-mainline: Never, SUSE-Xen specific
References: bsc#948330
Subject: [PATCH 1/2] xen: x86: mm: only do a local tlb flush in
 ptep_set_access_flags()

The function ptep_set_access_flags() is only ever invoked to set access
flags or add write permission on a PTE.  The write bit is only ever set
together with the dirty bit.

Because we only ever upgrade a PTE, it is safe to skip flushing entries on
remote TLBs. The worst that can happen is a spurious page fault on other
CPUs, which would flush that TLB entry.

Lazily letting another CPU incur a spurious page fault occasionally is
(much!) cheaper than aggressively flushing everybody else's TLB.

Signed-off-by: Rik van Riel <riel@redhat.com>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Cc: Andrew Morton <akpm@linux-foundation.org>
Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Cc: Michel Lespinasse <walken@google.com>
Cc: Ingo Molnar <mingo@kernel.org>
Signed-off-by: Ales Novak <alnovak@suse.cz>
Automatically created from "patches.fixes/0001-x86-mm-only-do-a-local-tlb-flush-in-ptep_set_access_.patch" by xen-port-patches.py

--- a/arch/x86/mm/pgtable-xen.c
+++ b/arch/x86/mm/pgtable-xen.c
@@ -712,6 +712,13 @@ pte_t xen_ptep_get_and_clear_full(struct
 }
 EXPORT_SYMBOL_GPL(xen_ptep_get_and_clear_full);
 
+/*
+ * Used to set accessed or dirty bits in the page table entries
+ * on other architectures. On x86, the accessed and dirty bits
+ * are tracked by hardware. However, do_wp_page calls this function
+ * to also make the pte writeable at the same time the dirty bit is
+ * set. In that case we do actually need to write the PTE.
+ */
 int ptep_set_access_flags(struct vm_area_struct *vma,
 			  unsigned long address, pte_t *ptep,
 			  pte_t entry, int dirty)
@@ -720,13 +727,12 @@ int ptep_set_access_flags(struct vm_area
 
 	if (changed && dirty) {
 		if (likely(vma->vm_mm == current->mm)) {
-			if (HYPERVISOR_update_va_mapping(address,
-				entry,
-				uvm_multi(mm_cpumask(vma->vm_mm))|UVMF_INVLPG))
+			if (HYPERVISOR_update_va_mapping(address, entry,
+							 UVMF_INVLPG))
 				BUG();
 		} else {
 			xen_l1_entry_update(ptep, entry);
-			flush_tlb_page(vma, address);
+			__flush_tlb_one(address);
 		}
 	}
 
