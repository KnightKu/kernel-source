Subject: Xen/PCI-MSI: fix sysfs teardown in DomU
From: jbeulich@suse.com
Patch-mainline: Never, SUSE-Xen specific
References: bsc#986924

Signed-off-by: Jan Beulich <jbeulich@suse.com>

--- a/drivers/pci/msi-xen.c
+++ b/drivers/pci/msi-xen.c
@@ -206,21 +206,24 @@ EXPORT_SYMBOL(unregister_msi_get_owner);
 static int msi_unmap_pirq(struct pci_dev *dev, int pirq, domid_t owner,
 			  struct kobject *kobj)
 {
-	struct physdev_unmap_pirq unmap;
-	int rc;
+	if (is_initial_xendomain()) {
+		struct physdev_unmap_pirq unmap;
+		int rc;
 
-	unmap.domid = owner;
-	/* See comments in msi_map_vector, input parameter pirq means
-	 * irq number only if the device belongs to dom0 itself.
-	 */
-	unmap.pirq = (unmap.domid != DOMID_SELF)
-		? pirq : evtchn_get_xen_pirq(pirq);
+		unmap.domid = owner;
+		/* See comments in msi_map_vector, input parameter pirq means
+		 * irq number only if the device belongs to dom0 itself.
+		 */
+		unmap.pirq = (unmap.domid != DOMID_SELF)
+			? pirq : evtchn_get_xen_pirq(pirq);
 
-	if ((rc = HYPERVISOR_physdev_op(PHYSDEVOP_unmap_pirq, &unmap)))
-		dev_warn(&dev->dev, "unmap irq %d failed\n", pirq);
+		if ((rc = HYPERVISOR_physdev_op(PHYSDEVOP_unmap_pirq, &unmap)))
+			dev_warn(&dev->dev, "unmap irq %d failed\n", pirq);
 
-	if (rc < 0)
-		return rc;
+		if (rc < 0)
+			return rc;
+	} else
+		owner = DOMID_SELF;
 
 	/*
 	 * Its possible that we get into this path when populate_msi_sysfs()
@@ -232,7 +235,7 @@ static int msi_unmap_pirq(struct pci_dev
 		kobject_put(kobj);
 	}
 
-	if (unmap.domid == DOMID_SELF)
+	if (owner == DOMID_SELF)
 		evtchn_map_pirq(pirq, 0);
 
 	return 0;
@@ -748,15 +751,12 @@ void pci_msi_shutdown(struct pci_dev *de
 	if (!pci_msi_enable || !dev || !dev->msi_enabled)
 		return;
 
-	if (!is_initial_xendomain()) {
+	if (!is_initial_xendomain())
 #ifdef CONFIG_XEN_PCIDEV_FRONTEND
-		evtchn_map_pirq(dev->irq, 0);
 		pci_frontend_disable_msi(dev);
-		dev->irq = msi_dev_entry->default_irq;
-		dev->msi_enabled = 0;
-#endif
+#else
 		return;
-	}
+#endif
 
 	pirq = dev->irq;
 	/* Restore dev->irq to its default pin-assertion vector */
@@ -767,9 +767,11 @@ void pci_msi_shutdown(struct pci_dev *de
 	memset(&msi_dev_entry->e.kobj, 0, sizeof(msi_dev_entry->e.kobj));
 
 	/* Disable MSI mode */
-	pos = pci_find_capability(dev, PCI_CAP_ID_MSI);
-	msi_set_enable(dev, pos, 0);
-	pci_intx_for_msi(dev, 1);
+	if (is_initial_xendomain()) {
+		pos = pci_find_capability(dev, PCI_CAP_ID_MSI);
+		msi_set_enable(dev, pos, 0);
+		pci_intx_for_msi(dev, 1);
+	}
 	dev->msi_enabled = 0;
 }
 
@@ -949,12 +951,9 @@ void msi_remove_pci_irq_vectors(struct p
 
 	spin_lock_irqsave(&msi_dev_entry->pirq_list_lock, flags);
 	list_for_each_entry_safe(pirq_entry, tmp, &dev->msi_list, list) {
-		if (is_initial_xendomain())
-			msi_unmap_pirq(dev, pirq_entry->pirq,
-				       msi_dev_entry->owner,
-				       &pirq_entry->kobj);
-		else
-			evtchn_map_pirq(pirq_entry->pirq, 0);
+		msi_unmap_pirq(dev, pirq_entry->pirq,
+			       msi_dev_entry->owner,
+			       &pirq_entry->kobj);
 		list_del(&pirq_entry->list);
 		kfree(pirq_entry);
 	}
