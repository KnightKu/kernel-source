From 7319114698fcd5a26fd8daa04b326eabb97d4a1e Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <gqjiang@suse.com>
Date: Mon, 6 Nov 2017 11:48:30 +0800
Subject: [PATCH 2/5] md/raid10: add honouring of suspend_{lo,hi}
Patch-mainline: No, because mainline has changed related code
References: fate#323171

Commit 6eef4b21ffc9 ("md: add honouring of suspend_{lo,hi}
to raid1.") added the support for raid1. This commit does
the same thing for raid10.

This will allow us to stop writeout to portions of the array
while they are resynced by someone else
- e.g. another node in a cluster.

Reviewed-by: NeilBrown <neilb@suse.com>
Signed-off-by: Guoqing Jiang <gqjiang@suse.com>
---
 drivers/md/raid10.c | 27 +++++++++++++++++++++++++++
 1 file changed, 27 insertions(+)

diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c
index b1de089cef9f..a4ca131d0d3f 100644
--- a/drivers/md/raid10.c
+++ b/drivers/md/raid10.c
@@ -25,6 +25,7 @@
 #include <linux/seq_file.h>
 #include <linux/ratelimit.h>
 #include <linux/kthread.h>
+#include <linux/sched/signal.h>
 #include <trace/events/block.h>
 #include "md.h"
 #include "raid10.h"
@@ -1296,6 +1297,29 @@ static void raid10_write_request(struct mddev *mddev, struct bio *bio,
 	sector_t sectors;
 	int max_sectors;
 
+	if (bio_end_sector(bio) > mddev->suspend_lo &&
+	    bio->bi_iter.bi_sector < mddev->suspend_hi) {
+		/*
+		 * As the suspend_* range is controlled by
+		 * userspace, we want an interruptible wait.
+		 */
+		DEFINE_WAIT(w);
+		for (;;) {
+			sigset_t full, old;
+
+			prepare_to_wait(&conf->wait_barrier, &w,
+					TASK_INTERRUPTIBLE);
+			if (bio_end_sector(bio) <= mddev->suspend_lo ||
+			    bio->bi_iter.bi_sector >= mddev->suspend_hi)
+				break;
+			sigfillset(&full);
+			sigprocmask(SIG_BLOCK, &full, &old);
+			schedule();
+			sigprocmask(SIG_SETMASK, &old, NULL);
+		}
+		finish_wait(&conf->wait_barrier, &w);
+	}
+
 	/*
 	 * Register the new request and wait if the reconstruction
 	 * thread has put up a bar for new requests.
@@ -3842,6 +3866,9 @@ static void raid10_quiesce(struct mddev *mddev, int state)
 	struct r10conf *conf = mddev->private;
 
 	switch(state) {
+	case 2: /* wake for suspend */
+		wake_up(&conf->wait_barrier);
+		break;
 	case 1:
 		raise_barrier(conf, 0);
 		break;
-- 
2.10.0

