From: Hiral Shah <hishah@cisco.com>
Date: Wed, 7 May 2014 11:32:22 -0700
Subject: fnic: Correcting warnings given by Smatch and Sparse tool
Patch-Mainline: Never, fixed differently as abb14148c0f850e7201efc3e7aea1762f993606b
References: bnc#876870

Signed-off-by: Hiral Shah <hishah@cisco.com>
Signed-off-by: Shirish Pargaonkar <spargaonkar@suse.com>
---
 drivers/scsi/fnic/fnic_debugfs.c | 126 +++++++++++++------------
 drivers/scsi/fnic/fnic_fcs.c     |   3 +-
 drivers/scsi/fnic/fnic_scsi.c    |   6 +-
 drivers/scsi/fnic/fnic_trace.c   | 193 +++++++++++++++++++--------------------
 drivers/scsi/fnic/fnic_trace.h   |  10 +-
 5 files changed, 163 insertions(+), 175 deletions(-)

diff --git a/drivers/scsi/fnic/fnic_debugfs.c b/drivers/scsi/fnic/fnic_debugfs.c
index d2781bc..ea21422 100644
--- a/drivers/scsi/fnic/fnic_debugfs.c
+++ b/drivers/scsi/fnic/fnic_debugfs.c
@@ -31,11 +31,11 @@ static struct dentry *fnic_fc_trace_enable;
 static struct dentry *fnic_fc_trace_clear;
 
 struct fc_trace_flag_type {
-        u8 fc_row_file;
-        u8 fc_normal_file;
-        u8 fnic_trace;
-        u8 fc_trace;
-        u8 fc_clear;
+	u8 fc_row_file;
+	u8 fc_normal_file;
+	u8 fnic_trace;
+	u8 fc_trace;
+	u8 fc_clear;
 };
 
 static struct fc_trace_flag_type *fc_trc_flag;
@@ -72,16 +72,16 @@ int fnic_debugfs_init(void)
 	}
 
 	/* Allocate memory to structure */
-        fc_trc_flag = (struct fc_trace_flag_type *)
-                vmalloc(sizeof(struct fc_trace_flag_type));
+	fc_trc_flag = (struct fc_trace_flag_type *)
+		vmalloc(sizeof(struct fc_trace_flag_type));
 
-        if (fc_trc_flag) {
-                fc_trc_flag->fc_row_file = 0;
-                fc_trc_flag->fc_normal_file = 1;
-                fc_trc_flag->fnic_trace = 2;
-                fc_trc_flag->fc_trace = 3;
-                fc_trc_flag->fc_clear = 4;
-        }
+	if (fc_trc_flag) {
+		fc_trc_flag->fc_row_file = 0;
+		fc_trc_flag->fc_normal_file = 1;
+		fc_trc_flag->fnic_trace = 2;
+		fc_trc_flag->fc_trace = 3;
+		fc_trc_flag->fc_clear = 4;
+	}
 
 	rc = 0;
 	return rc;
@@ -102,9 +102,8 @@ void fnic_debugfs_terminate(void)
 	debugfs_remove(fnic_trace_debugfs_root);
 	fnic_trace_debugfs_root = NULL;
 
-	if (fc_trc_flag) {
+	if (fc_trc_flag)
 		vfree(fc_trc_flag);
-	}
 }
 
 /*
@@ -153,15 +152,14 @@ static ssize_t fnic_trace_ctrl_read(struct file *filp,
 	u8 *trace_type;
 	len = 0;
 	trace_type = (u8 *)filp->private_data;
-	if (*trace_type == fc_trc_flag->fnic_trace) {
+	if (*trace_type == fc_trc_flag->fnic_trace)
 		len = sprintf(buf, "%u\n", fnic_tracing_enabled);
-	} else if (*trace_type == fc_trc_flag->fc_trace) {
+	else if (*trace_type == fc_trc_flag->fc_trace)
 		len = sprintf(buf, "%u\n", fnic_fc_tracing_enabled);
-	} else if (*trace_type == fc_trc_flag->fc_clear) {
+	else if (*trace_type == fc_trc_flag->fc_clear)
 		len = sprintf(buf, "%u\n", fnic_fc_trace_cleared);
-	} else {
-		printk(KERN_ERR PFX "cannot read to any debugfs file");
-	}
+	else
+		pr_err("fnic: Cannot read to any debugfs file\n");
 
 	return simple_read_from_buffer(ubuf, cnt, ppos, buf, len);
 }
@@ -205,15 +203,15 @@ static ssize_t fnic_trace_ctrl_write(struct file *filp,
 	if (ret < 0)
 		return ret;
 
-	if (*trace_type == fc_trc_flag->fnic_trace) {
+	if (*trace_type == fc_trc_flag->fnic_trace)
 		fnic_tracing_enabled = val;
-	} else if (*trace_type == fc_trc_flag->fc_trace) {
+	else if (*trace_type == fc_trc_flag->fc_trace)
 		fnic_fc_tracing_enabled = val;
-	} else if (*trace_type == fc_trc_flag->fc_clear) {
+	else if (*trace_type == fc_trc_flag->fc_clear)
 		fnic_fc_trace_cleared = val;
-	} else {
-		printk(KERN_ERR PFX "cannot write to any debufs file");
-	}
+	else
+		pr_err("fnic: cannot write to any debufs file\n");
+
 	(*ppos)++;
 
 	return cnt;
@@ -247,28 +245,29 @@ static int fnic_trace_debugfs_open(struct inode *inode,
 	fnic_dbgfs_t *fnic_dbg_prt;
 	u8 *rdata_ptr;
 	rdata_ptr = (u8 *)inode->i_private;
-	fnic_dbg_prt = kzalloc(sizeof (fnic_dbgfs_t), GFP_KERNEL);
+	fnic_dbg_prt = kzalloc(sizeof(fnic_dbgfs_t), GFP_KERNEL);
 	if (!fnic_dbg_prt)
 		return -ENOMEM;
 
 	if (*rdata_ptr == fc_trc_flag->fnic_trace) {
-		fnic_dbg_prt->buffer = vmalloc(3*(trace_max_pages * PAGE_SIZE));
+		fnic_dbg_prt->buffer = vmalloc(3 *
+					(trace_max_pages * PAGE_SIZE));
 		if (!fnic_dbg_prt->buffer) {
 			kfree(fnic_dbg_prt);
 			return -ENOMEM;
 		}
 		memset((void *)fnic_dbg_prt->buffer, 0,
-		3*(trace_max_pages * PAGE_SIZE));
+		3 * (trace_max_pages * PAGE_SIZE));
 		fnic_dbg_prt->buffer_len = fnic_get_trace_data(fnic_dbg_prt);
 	} else {
 		fnic_dbg_prt->buffer =
-			vmalloc(3*(fnic_fc_trace_max_pages * PAGE_SIZE));
+			vmalloc(3 * (fnic_fc_trace_max_pages * PAGE_SIZE));
 		if (!fnic_dbg_prt->buffer) {
 			kfree(fnic_dbg_prt);
 			return -ENOMEM;
 		}
 		memset((void *)fnic_dbg_prt->buffer, 0,
-		3*(fnic_fc_trace_max_pages * PAGE_SIZE));
+			3 * (fnic_fc_trace_max_pages * PAGE_SIZE));
 		fnic_dbg_prt->buffer_len =
 			fnic_fc_trace_get_data(fnic_dbg_prt, *rdata_ptr);
 	}
@@ -382,10 +381,10 @@ int fnic_trace_debugfs_init(void)
 		return rc;
 	}
 	fnic_trace_enable = debugfs_create_file("tracing_enable",
-					  S_IFREG|S_IRUGO|S_IWUSR,
-					  fnic_trace_debugfs_root,
-					&(fc_trc_flag->fnic_trace),
-					&fnic_trace_ctrl_fops);
+						S_IFREG|S_IRUGO|S_IWUSR,
+						fnic_trace_debugfs_root,
+						&(fc_trc_flag->fnic_trace),
+						&fnic_trace_ctrl_fops);
 
 	if (!fnic_trace_enable) {
 		printk(KERN_DEBUG
@@ -394,10 +393,10 @@ int fnic_trace_debugfs_init(void)
 	}
 
 	fnic_trace_debugfs_file = debugfs_create_file("trace",
-						  S_IFREG|S_IRUGO|S_IWUSR,
-						  fnic_trace_debugfs_root,
+						S_IFREG|S_IRUGO|S_IWUSR,
+						fnic_trace_debugfs_root,
 						&(fc_trc_flag->fnic_trace),
-						  &fnic_trace_debugfs_fops);
+						&fnic_trace_debugfs_fops);
 
 	if (!fnic_trace_debugfs_file) {
 		printk(KERN_DEBUG
@@ -438,59 +437,56 @@ void fnic_trace_debugfs_terminate(void)
 
 int fnic_fc_trace_debugfs_init(void)
 {
-        int rc = -1;
+	int rc = -1;
 
 	if (!fnic_trace_debugfs_root) {
-		printk(KERN_DEBUG
-			"fnic Debugfs root directory doesn't exist\n");
+		pr_err("fnic:Debugfs root directory doesn't exist\n");
 		return rc;
 	}
 
 	fnic_fc_trace_enable = debugfs_create_file("fc_trace_enable",
-							S_IFREG|S_IRUGO|S_IWUSR,
-							fnic_trace_debugfs_root,
-							&(fc_trc_flag->fc_trace),
-							&fnic_trace_ctrl_fops);
+						S_IFREG|S_IRUGO|S_IWUSR,
+						fnic_trace_debugfs_root,
+						&(fc_trc_flag->fc_trace),
+						&fnic_trace_ctrl_fops);
 
 	if (!fnic_fc_trace_enable) {
-		printk(KERN_DEBUG "Cannot create fc_trace_enable"
-			"under debugfs");
+		pr_err("fnic: Failed create fc_trace_enable file\n");
 		return rc;
 	}
 
 	fnic_fc_trace_clear = debugfs_create_file("fc_trace_clear",
-                                                  S_IFREG|S_IRUGO|S_IWUSR,
-                                                  fnic_trace_debugfs_root,
-                                                  &(fc_trc_flag->fc_clear),
-                                                  &fnic_trace_ctrl_fops);
+						S_IFREG|S_IRUGO|S_IWUSR,
+						fnic_trace_debugfs_root,
+						&(fc_trc_flag->fc_clear),
+						&fnic_trace_ctrl_fops);
 
 	if (!fnic_fc_trace_clear) {
-		printk(KERN_DEBUG "Cannot create fc_trace_enable"
-			"under debugfs");
+		pr_err("fnic: Failed to create fc_trace_enable file\n");
 		return rc;
 	}
 
 	fnic_fc_rdata_trace_debugfs_file =
 		debugfs_create_file("fc_trace_rdata",
-				    S_IFREG|S_IRUGO|S_IWUSR,
-                                    fnic_trace_debugfs_root,
-				    &(fc_trc_flag->fc_normal_file),
-                                    &fnic_trace_debugfs_fops);
+					S_IFREG|S_IRUGO|S_IWUSR,
+					fnic_trace_debugfs_root,
+					&(fc_trc_flag->fc_normal_file),
+					&fnic_trace_debugfs_fops);
 
 	if (!fnic_fc_rdata_trace_debugfs_file) {
-		printk(KERN_DEBUG "Cannot create fc_rdata_trace under debugfs");
+		pr_err("fnic: Failed create fc_rdata_trace file\n");
 		return rc;
 	}
 
 	fnic_fc_trace_debugfs_file =
 		debugfs_create_file("fc_trace",
-                                    S_IFREG|S_IRUGO|S_IWUSR,
-                                    fnic_trace_debugfs_root,
-				    &(fc_trc_flag->fc_row_file),
-                                    &fnic_trace_debugfs_fops);
+					S_IFREG|S_IRUGO|S_IWUSR,
+					fnic_trace_debugfs_root,
+					&(fc_trc_flag->fc_row_file),
+					&fnic_trace_debugfs_fops);
 
 	if (!fnic_fc_trace_debugfs_file) {
-		printk(KERN_DEBUG "Cannot create fc_trace file under debugfs");
+		pr_err("fnic: Failed to create fc_trace file\n");
 		return rc;
 	}
 	rc = 0;
diff --git a/drivers/scsi/fnic/fnic_fcs.c b/drivers/scsi/fnic/fnic_fcs.c
index 3949bbc..6462b67 100644
--- a/drivers/scsi/fnic/fnic_fcs.c
+++ b/drivers/scsi/fnic/fnic_fcs.c
@@ -101,13 +101,14 @@ void fnic_handle_link(struct work_struct *work)
 				FNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,
 					     "link up\n");
 				fcoe_ctlr_link_up(&fnic->ctlr);
-			} else
+			} else {
 				/* UP -> UP */
 				spin_unlock_irqrestore(&fnic->fnic_lock, flags);
 				fnic_fc_trace_set_data(
 					fnic->lport->host->host_no, FNIC_FC_LE,
 					"Link Status: UP_UP",
 					strlen("Link Status: UP_UP"));
+			}
 		}
 	} else if (fnic->link_status) {
 		/* DOWN -> UP */
diff --git a/drivers/scsi/fnic/fnic_scsi.c b/drivers/scsi/fnic/fnic_scsi.c
index b174ca8..643a137 100644
--- a/drivers/scsi/fnic/fnic_scsi.c
+++ b/drivers/scsi/fnic/fnic_scsi.c
@@ -1312,9 +1312,9 @@ static void fnic_cleanup_io(struct fnic *fnic, int exclude_id)
 
 cleanup_scsi_cmd:
 		sc->result = DID_TRANSPORT_DISRUPTED << 16;
-		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host, "fnic_cleanup_io:"
-			      " sc duration = %lu DID_TRANSPORT_DISRUPTED\n",
-				(jiffies - start_time));
+		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
+				"%s: sc duration = %lu DID_TRANSPORT_DISRUPTED\n",
+				__func__, (jiffies - start_time));
 
 		if (atomic64_read(&fnic->io_cmpl_skip))
 			atomic64_dec(&fnic->io_cmpl_skip);
diff --git a/drivers/scsi/fnic/fnic_trace.c b/drivers/scsi/fnic/fnic_trace.c
index b166ebd..25c71cb 100644
--- a/drivers/scsi/fnic/fnic_trace.c
+++ b/drivers/scsi/fnic/fnic_trace.c
@@ -439,10 +439,10 @@ int fnic_trace_buf_init(void)
 	}
 	err = fnic_trace_debugfs_init();
 	if (err < 0) {
-		printk(KERN_ERR PFX "Failed to initialize debugfs for tracing\n");
+		pr_err("fnic: Failed to initialize debugfs for tracing\n");
 		goto err_fnic_trace_debugfs_init;
 	}
-	printk(KERN_INFO PFX "Successfully Initialized Trace Buffer\n");
+	pr_info("fnic: Successfully Initialized Trace Buffer\n");
 	return err;
 err_fnic_trace_debugfs_init:
 	fnic_trace_free();
@@ -470,7 +470,7 @@ void fnic_trace_free(void)
 
 /*
  * fnic_fc_ctlr_trace_buf_init -
- * 	Initialize trace buffer to log fnic control frames
+ * Initialize trace buffer to log fnic control frames
  * Description:
  * Initialize trace buffer data structure by allocating
  * required memory for trace data as well as for Indexes.
@@ -488,12 +488,12 @@ int fnic_fc_trace_init(void)
 	int i;
 
 	fc_trace_max_entries = (fnic_fc_trace_max_pages * PAGE_SIZE)/
-                               FC_TRC_SIZE_BYTES;
+				FC_TRC_SIZE_BYTES;
 	fnic_fc_ctlr_trace_buf_p = (unsigned long)vmalloc(
 					fnic_fc_trace_max_pages * PAGE_SIZE);
 	if (!fnic_fc_ctlr_trace_buf_p) {
-		printk(KERN_ERR PFX "Failed to allocate memory "
-                       "for fnic_fc_ctlr_trace_buf_p\n");
+		pr_err("fnic: Failed to allocate memory for "
+			"FC Control Trace Buf\n");	
 		err = -ENOMEM;
 		goto err_fnic_fc_ctlr_trace_buf_init;
 	}
@@ -503,13 +503,11 @@ int fnic_fc_trace_init(void)
 
 	/* Allocate memory for page offset */
 	fc_trace_entries.page_offset = vmalloc(fc_trace_max_entries *
-                                                      sizeof (unsigned long));
+						sizeof(unsigned long));
 	if (!fc_trace_entries.page_offset) {
-		printk(KERN_ERR PFX "Failed to allocate memory for"
-                       " page_offset\n");
-		if (!fnic_fc_ctlr_trace_buf_p) {
-			printk(KERN_DEBUG PFX
-				"Release fnic_fc_ctlr_trace_buf_p");
+		pr_err("fnic:Failed to allocate memory for page_offset\n");
+		if (fnic_fc_ctlr_trace_buf_p) {
+			pr_err("fnic: Freeing FC Control Trace Buf\n");
 			vfree((void *)fnic_fc_ctlr_trace_buf_p);
 			fnic_fc_ctlr_trace_buf_p = 0;
 		}
@@ -517,27 +515,25 @@ int fnic_fc_trace_init(void)
 		goto err_fnic_fc_ctlr_trace_buf_init;
 	}
 	memset((void *)fc_trace_entries.page_offset, 0,
-			(fc_trace_max_entries * sizeof (unsigned long)));
+		(fc_trace_max_entries * sizeof(unsigned long)));
 
 	fc_trace_entries.rd_idx = fc_trace_entries.wr_idx = 0;
 	fc_trace_buf_head = fnic_fc_ctlr_trace_buf_p;
 
-        /*
-         * Set up fc_trace_entries.page_offset field with memory location
-         * for every trace entry
-         */
+	/*
+	 * Set up fc_trace_entries.page_offset field with memory location
+	 * for every trace entry
+	 */
 	for (i = 0; i < fc_trace_max_entries; i++) {
 		fc_trace_entries.page_offset[i] = fc_trace_buf_head;
 		fc_trace_buf_head += FC_TRC_SIZE_BYTES;
 	}
 	err = fnic_fc_trace_debugfs_init();
 	if (err < 0) {
-		printk(KERN_ERR PFX
-			"Failed to initialize debugfs for FC_CTLR tracing\n");
+		pr_err("fnic: Failed to initialize FC_CTLR tracing.\n");
 		goto err_fnic_fc_ctlr_trace_debugfs_init;
 	}
-	printk(KERN_DEBUG PFX
-		"Successfully Initialized FC_CTLR Trace Buffer\n");
+	pr_info("fnic: Successfully Initialized FC_CTLR Trace Buffer\n");
 	return err;
 
 err_fnic_fc_ctlr_trace_debugfs_init:
@@ -561,7 +557,7 @@ void fnic_fc_trace_free(void)
 		vfree((void *)fnic_fc_ctlr_trace_buf_p);
 		fnic_fc_ctlr_trace_buf_p = 0;
 	}
-	printk(KERN_DEBUG PFX "Successfully FC_CTLR Freed Trace Buffer\n");
+	pr_info("fnic:Successfully FC_CTLR Freed Trace Buffer\n");
 }
 
 /*
@@ -573,37 +569,36 @@ void fnic_fc_trace_free(void)
  *       fc_frame: pointer to fc_frame
  *       frame_len: Length of the fc_frame
  * Description:
- * 	This routine will get next available wr_idx and
- * 	copy all passed trace data to the buffer pointed by wr_idx
- * 	and increment wr_idx. It will also make sure that we dont
- * 	overwrite the entry which we are reading and also
- * 	wrap around if we reach the maximum entries.
+ *       This routine will get next available wr_idx and
+ *       copy all passed trace data to the buffer pointed by wr_idx
+ *       and increment wr_idx. It will also make sure that we dont
+ *       overwrite the entry which we are reading and also
+ *       wrap around if we reach the maximum entries.
  * Returned Value:
- * 	It will return 0 for success or -1 for failure
+ *       It will return 0 for success or -1 for failure
  */
 int fnic_fc_trace_set_data(u32 host_no, u8 frame_type,
-                                char *frame, u32 fc_trc_frame_len)
+			char *frame, u32 fc_trc_frame_len)
 {
 	unsigned long flags;
-	fc_trace_hdr_t *fc_buf;
+	struct fc_trace_hdr *fc_buf;
 	unsigned long eth_fcoe_hdr_len;
 	char *fc_trace;
 
-	if (fnic_fc_tracing_enabled == 0) {
+	if (fnic_fc_tracing_enabled == 0)
 		return 0;
-	}
 
 	spin_lock_irqsave(&fnic_fc_trace_lock, flags);
 
 	if (fnic_fc_trace_cleared == 1) {
 		fc_trace_entries.rd_idx = fc_trace_entries.wr_idx = 0;
-		printk(KERN_DEBUG "Reseting the read idx \n");
+		pr_info("fnic: Reseting the read idx\n");
 		memset((void *)fnic_fc_ctlr_trace_buf_p, 0,
 				fnic_fc_trace_max_pages * PAGE_SIZE);
 		fnic_fc_trace_cleared = 0;
 	}
 
-	fc_buf = (fc_trace_hdr_t *)
+	fc_buf = (struct fc_trace_hdr *)
 		fc_trace_entries.page_offset[fc_trace_entries.wr_idx];
 
 	fc_trace_entries.wr_idx++;
@@ -627,8 +622,8 @@ int fnic_fc_trace_set_data(u32 host_no, u8 frame_type,
 	 * at trace entry point so we will stuff 0xff just to make it generic.
 	 */
 	if( frame_type == FNIC_FC_RECV ) {
-		eth_fcoe_hdr_len = sizeof (struct ethhdr) +
-					sizeof (struct fcoe_hdr);
+		eth_fcoe_hdr_len = sizeof(struct ethhdr) +
+					sizeof(struct fcoe_hdr);
 		fc_trc_frame_len = fc_trc_frame_len + eth_fcoe_hdr_len;
 		memset((char *)fc_trace, 0xff, eth_fcoe_hdr_len);
 		/* Copy the rest of data frame */
@@ -653,41 +648,43 @@ int fnic_fc_trace_set_data(u32 host_no, u8 frame_type,
  * Passed parameter:
  *       @fnic_dbgfs_t: pointer to debugfs trace buffer
  *       rdata_flag: 1 => Unformated file
- * 		0 => formated file
+ * 	             0 => formated file
  * Description:
- *	 This routine will copy the trace data to memory file with
- *	 proper formatting and also copy to another memory
- *	 file without formatting for further procesing.
+ *       This routine will copy the trace data to memory file with
+ *       proper formatting and also copy to another memory
+ *       file without formatting for further procesing.
  * Retrun Value:
- * 	Number of bytes that were dumped into fnic_dbgfs_t
+ *       Number of bytes that were dumped into fnic_dbgfs_t
  */
 
-int fnic_fc_trace_get_data(fnic_dbgfs_t *fnic_dbgfs_prt, u8 rdata_flag) {
+int fnic_fc_trace_get_data(fnic_dbgfs_t *fnic_dbgfs_prt, u8 rdata_flag)
+{
 	int rd_idx, wr_idx;
 	unsigned long flags;
 	int len = 0, j;
-	fc_trace_hdr_t *tdata;
+	struct fc_trace_hdr *tdata;
 	char *fc_trace;
 
 	spin_lock_irqsave(&fnic_fc_trace_lock, flags);
 	if (fc_trace_entries.wr_idx == fc_trace_entries.rd_idx) {
 		spin_unlock_irqrestore(&fnic_fc_trace_lock, flags);
-		printk(KERN_DEBUG "Buffer is empty");
+		pr_info("fnic: Buffer is empty\n");
 		return 0;
 	}
 	rd_idx = fc_trace_entries.rd_idx;
 	wr_idx = fc_trace_entries.wr_idx;
 	if (rdata_flag == 0) {
 		len += snprintf(fnic_dbgfs_prt->buffer + len,
-				(fnic_fc_trace_max_pages * PAGE_SIZE *3) -len,
-				"Time Stamp (UTC)\t\t Host No:"
-				"   F Type:  len:     FCoE_FRAME:\n");
+			(fnic_fc_trace_max_pages * PAGE_SIZE * 3) - len,
+			"Time Stamp (UTC)\t\t"
+			"Host No:   F Type:  len:     FCoE_FRAME:\n");
 	}
 
 	while (rd_idx != wr_idx) {
-		tdata = (fc_trace_hdr_t *)fc_trace_entries.page_offset[rd_idx];
+		tdata = (struct fc_trace_hdr *)
+			fc_trace_entries.page_offset[rd_idx];
 		if (!tdata) {
-			printk(KERN_DEBUG "Rd data is NULL");
+			pr_info("fnic: Rd data is NULL\n");
 			spin_unlock_irqrestore(&fnic_fc_trace_lock, flags);
 			return 0;
 		}
@@ -696,46 +693,47 @@ int fnic_fc_trace_get_data(fnic_dbgfs_t *fnic_dbgfs_prt, u8 rdata_flag) {
 				fnic_dbgfs_prt, &len, rdata_flag);
 		} else {
 			fc_trace = (char *)tdata;
-                        for (j = 0; j < FC_TRC_SIZE_BYTES; j++) {
-                                len += snprintf(fnic_dbgfs_prt->buffer + len,
-                                    (fnic_fc_trace_max_pages * PAGE_SIZE * 3)
-				     - len, "%02x", fc_trace[j] & 0xff);
-                        } // for loop
-                        len += snprintf(fnic_dbgfs_prt->buffer + len,
-                                (fnic_fc_trace_max_pages * PAGE_SIZE *3) -len,
-                                "\n");
+			for (j = 0; j < FC_TRC_SIZE_BYTES; j++) {
+				len += snprintf(fnic_dbgfs_prt->buffer + len,
+				(fnic_fc_trace_max_pages * PAGE_SIZE * 3)
+				- len, "%02x", fc_trace[j] & 0xff);
+			} /* for loop */
+			len += snprintf(fnic_dbgfs_prt->buffer + len,
+				(fnic_fc_trace_max_pages * PAGE_SIZE * 3) - len,
+				"\n");
 		}
 		rd_idx++;
-		if (rd_idx > (fc_trace_max_entries -1))
+		if (rd_idx > (fc_trace_max_entries - 1))
 			rd_idx = 0;
 	}
 
-        spin_unlock_irqrestore(&fnic_fc_trace_lock, flags);
-        return len;
+	spin_unlock_irqrestore(&fnic_fc_trace_lock, flags);
+	return len;
 }
 
 /*
  * copy_and_format_trace_data: Copy formatted data to char * buffer
  * Passed Parameter:
- * 	@fc_trace_hdr_t: pointer to trace data
- * 	@fnic_dbgfs_t: pointer to debugfs trace buffer
- * 	@orig_len: pointer to len
- * 	rdata_flag: 0 => Formated file, 1 => Unformated file
+ *      @fc_trace_hdr_t: pointer to trace data
+ *      @fnic_dbgfs_t: pointer to debugfs trace buffer
+ *      @orig_len: pointer to len
+ * rdata_flag: 0 => Formated file, 1 => Unformated file
  * Description:
- * 	This routine will format and copy the passed trace data
- * 	for formated file or unformated file accordingly.
+ *      This routine will format and copy the passed trace data
+ *      for formated file or unformated file accordingly.
  */
 
-void copy_and_format_trace_data(fc_trace_hdr_t *tdata,
-                               fnic_dbgfs_t *fnic_dbgfs_prt, int *orig_len,
-                               u8 rdata_flag)
+void copy_and_format_trace_data(struct fc_trace_hdr *tdata,
+				fnic_dbgfs_t *fnic_dbgfs_prt, int *orig_len,
+				u8 rdata_flag)
 {
-        struct tm tm;
-        int j, i = 1, len;
-        char *fc_trace;
-	int ethhdr_len = sizeof (struct ethhdr) - 1;
-	int fcoehdr_len = sizeof (struct fcoe_hdr);
-	int fchdr_len = sizeof (struct fc_frame_header);
+	struct tm tm;
+	int j, i = 1, len;
+	char *fc_trace, *fmt;
+	int ethhdr_len = sizeof(struct ethhdr) - 1;
+	int fcoehdr_len = sizeof(struct fcoe_hdr);
+	int fchdr_len = sizeof(struct fc_frame_header);
+	int max_size = fnic_fc_trace_max_pages * PAGE_SIZE * 3;
 
 	tdata->frame_type = tdata->frame_type & 0x7F;
 
@@ -743,44 +741,39 @@ void copy_and_format_trace_data(fc_trace_hdr_t *tdata,
 
 	time_to_tm(tdata->time_stamp.tv_sec, 0, &tm);
 
-        len += snprintf(fnic_dbgfs_prt->buffer + len,
-                       (fnic_fc_trace_max_pages * PAGE_SIZE *3) -len,
-                        "%02d:%02d:%04ld %02d:%02d:%02d.%09lu ns"
-                        "%8x       %c%8x\t",
-                        tm.tm_mon + 1, tm.tm_mday, tm.tm_year + 1900,
-                        tm.tm_hour, tm.tm_min, tm.tm_sec,
-                        tdata->time_stamp.tv_nsec, tdata->host_no,
-                        tdata->frame_type, tdata->frame_len);
+	fmt = "%02d:%02d:%04ld %02d:%02d:%02d.%09lu ns%8x       %c%8x\t";
+	len += snprintf(fnic_dbgfs_prt->buffer + len,
+		max_size - len,
+		fmt,
+		tm.tm_mon + 1, tm.tm_mday, tm.tm_year + 1900,
+		tm.tm_hour, tm.tm_min, tm.tm_sec,
+		tdata->time_stamp.tv_nsec, tdata->host_no,
+		tdata->frame_type, tdata->frame_len);
 
-        fc_trace = (char *)FC_TRACE_ADDRESS(tdata);
+	fc_trace = (char *)FC_TRACE_ADDRESS(tdata);
 
 	for (j = 0; j < min_t(u8, tdata->frame_len,
 		(u8)(FC_TRC_SIZE_BYTES - FC_TRC_HEADER_SIZE)); j++) {
 		if (tdata->frame_type == FNIC_FC_LE) {
 			len += snprintf(fnic_dbgfs_prt->buffer + len,
-				(fnic_fc_trace_max_pages * PAGE_SIZE * 3) -len,
-				"%c", fc_trace[j]);
+				max_size - len, "%c", fc_trace[j]);
 		} else {
 			len += snprintf(fnic_dbgfs_prt->buffer + len,
-				(fnic_fc_trace_max_pages * PAGE_SIZE * 3) -len,
-                               "%02x", fc_trace[j] & 0xff);
+				max_size - len, "%02x", fc_trace[j] & 0xff);
 			len += snprintf(fnic_dbgfs_prt->buffer + len,
-                               (fnic_fc_trace_max_pages * PAGE_SIZE * 3)
-                                -len, " ");
+				max_size - len, " ");
 			if (j == ethhdr_len ||
-			    j == ethhdr_len + fcoehdr_len ||
-                            j == ethhdr_len + fcoehdr_len + fchdr_len ||
-                            (i > 3 && j%fchdr_len == 0)) {
+				j == ethhdr_len + fcoehdr_len ||
+				j == ethhdr_len + fcoehdr_len + fchdr_len ||
+				(i > 3 && j%fchdr_len == 0)) {
 				len += snprintf(fnic_dbgfs_prt->buffer
-					+ len, (fnic_fc_trace_max_pages
-                                        * PAGE_SIZE * 3) -len,
-                                        "\n\t\t\t\t\t\t\t\t");
+					+ len, max_size - len,
+					"\n\t\t\t\t\t\t\t\t");
 				i++;
 			}
-		} // end of else
-	} // for loop
+		} /* end of else */
+	} /* end of for loop */
 	len += snprintf(fnic_dbgfs_prt->buffer + len,
-                        (fnic_fc_trace_max_pages * PAGE_SIZE *3) -len,
-                        "\n");
+		 max_size - len, "\n");
 	*orig_len = len;
 }
diff --git a/drivers/scsi/fnic/fnic_trace.h b/drivers/scsi/fnic/fnic_trace.h
index ad4610a..2b7a16a 100644
--- a/drivers/scsi/fnic/fnic_trace.h
+++ b/drivers/scsi/fnic/fnic_trace.h
@@ -78,8 +78,6 @@ struct fc_trace_hdr {
 	u8 frame_len;
 } __attribute__((__packed__));
 
-typedef struct fc_trace_hdr fc_trace_hdr_t;
-
 #define FC_TRACE_ADDRESS(a) \
 	((unsigned long )(a) + sizeof (struct fc_trace_hdr))
 
@@ -120,11 +118,11 @@ void fnic_trace_debugfs_terminate(void);
 int fnic_fc_trace_init(void);
 void fnic_fc_trace_free(void);
 int fnic_fc_trace_set_data(u32 host_no, u8 frame_type,
-                                char *frame, u32 fc_frame_len);
+				char *frame, u32 fc_frame_len);
 int fnic_fc_trace_get_data(fnic_dbgfs_t *fnic_dbgfs_prt, u8 rdata_flag);
-void copy_and_format_trace_data(fc_trace_hdr_t *tdata,
-                               fnic_dbgfs_t *fnic_dbgfs_prt,
-                               int *len, u8 rdata_flag);
+void copy_and_format_trace_data(struct fc_trace_hdr *tdata,
+				fnic_dbgfs_t *fnic_dbgfs_prt,
+				int *len, u8 rdata_flag);
 int fnic_fc_trace_debugfs_init(void);
 void fnic_fc_trace_debugfs_terminate(void);
 
-- 
1.8.5.4

