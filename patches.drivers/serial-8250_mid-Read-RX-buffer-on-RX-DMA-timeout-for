From 692aa1905679bd72f84115986235d214f6096a98 Mon Sep 17 00:00:00 2001
From: "Chuah, Kim Tatt" <kim.tatt.chuah@intel.com>
Date: Wed, 15 Jun 2016 13:44:13 +0800
Subject: [PATCH] serial: 8250_mid: Read RX buffer on RX DMA timeout for DNV
Git-commit: 692aa1905679bd72f84115986235d214f6096a98
Patch-mainline: 4.8-rc1
References: bsc#1024449

In DNV, when RX DMA is used and number of bytes received is less than
transfer size, only RX DMA timeout interrupt is sent. When this happens,
read the RX buffer.

Signed-off-by: Chuah, Kim Tatt <kim.tatt.chuah@intel.com>
Acked-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/tty/serial/8250/8250_mid.c |    6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

--- a/drivers/tty/serial/8250/8250_mid.c
+++ b/drivers/tty/serial/8250/8250_mid.c
@@ -91,6 +91,7 @@ static int tng_setup(struct mid8250 *mid
 static int dnv_handle_irq(struct uart_port *p)
 {
 	struct mid8250 *mid = p->private_data;
+	struct uart_8250_port *up = up_to_u8250p(p);
 	unsigned int fisr = serial_port_in(p, INTEL_MID_UART_DNV_FISR);
 	u32 status;
 	int ret = IRQ_NONE;
@@ -98,9 +99,10 @@ static int dnv_handle_irq(struct uart_po
 
 	if (fisr & BIT(2)) {
 		err = hsu_dma_get_status(&mid->dma_chip, 1, &status);
-		if (err > 0)
+		if (err > 0) {
+			serial8250_rx_dma_flush(up);
 			ret |= IRQ_HANDLED;
-		else if (err == 0)
+		} else if (err == 0)
 			ret |= hsu_dma_do_irq(&mid->dma_chip, 1, status);
 	}
 	if (fisr & BIT(1)) {
