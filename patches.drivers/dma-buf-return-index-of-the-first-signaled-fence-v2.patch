From 7392b4bb702b05749539ff0936e94976248240c9 Mon Sep 17 00:00:00 2001
From: "monk.liu" <monk.liu@amd.com>
Date: Fri, 4 Nov 2016 16:16:09 -0400
Subject: [PATCH] dma-buf: return index of the first signaled fence (v2)
Git-commit: 7392b4bb702b05749539ff0936e94976248240c9
Patch-mainline: 4.10-rc1
References: bsc#1040550

[tiwai: this patch was modified to be applicable to 4.4.x as the original
 patch was after the function renames.
 Also, this patch contains the partial change to amdgpu code as well,
 which was included in commit eef18a827a9ec58aa9fc1ccfb7e65ff04ebc25f3
   drm/amdgpu: add the interface of waiting multiple fences (v4)
 for fixing the build breakage. ]

Return the index of the first signaled fence.  This information
is useful in some APIs like Vulkan.

V2: rebase on drm-next (fence -> dma_fence)

Signed-off-by: monk.liu <monk.liu@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Cc: Sumit Semwal <sumit.semwal@linaro.org>
Signed-off-by: Sumit Semwal <sumit.semwal@linaro.org> [sumits: fix warnings]
Link: http://patchwork.freedesktop.org/patch/msgid/1478290570-30982-1-git-send-email-alexander.deucher@amd.com
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/dma-buf/fence.c                |   21 ++++++++++++++++-----
 drivers/gpu/drm/amd/amdgpu/amdgpu_sa.c |    3 ++-
 include/linux/fence.h                  |    3 ++-
 3 files changed, 20 insertions(+), 7 deletions(-)

--- a/drivers/dma-buf/fence.c
+++ b/drivers/dma-buf/fence.c
@@ -398,14 +398,18 @@ out:
 EXPORT_SYMBOL(fence_default_wait);
 
 static bool
-fence_test_signaled_any(struct fence **fences, uint32_t count)
+fence_test_signaled_any(struct fence **fences, uint32_t count,
+			uint32_t *idx)
 {
 	int i;
 
 	for (i = 0; i < count; ++i) {
 		struct fence *fence = fences[i];
-		if (test_bit(FENCE_FLAG_SIGNALED_BIT, &fence->flags))
+		if (test_bit(FENCE_FLAG_SIGNALED_BIT, &fence->flags)) {
+			if (idx)
+				*idx = i;
 			return true;
+		}
 	}
 	return false;
 }
@@ -417,6 +421,8 @@ fence_test_signaled_any(struct fence **f
  * @count:	[in]	number of fences to wait on
  * @intr:	[in]	if true, do an interruptible wait
  * @timeout:	[in]	timeout value in jiffies, or MAX_SCHEDULE_TIMEOUT
+ * @idx:       [out]	the first signaled fence index, meaningful only on
+ *			positive return
  *
  * Returns -EINVAL on custom fence wait implementation, -ERESTARTSYS if
  * interrupted, 0 if the wait timed out, or the remaining timeout in jiffies
@@ -428,7 +434,7 @@ fence_test_signaled_any(struct fence **f
  */
 signed long
 fence_wait_any_timeout(struct fence **fences, uint32_t count,
-		       bool intr, signed long timeout)
+		       bool intr, signed long timeout, uint32_t *idx)
 {
 	struct default_wait_cb *cb;
 	signed long ret = timeout;
@@ -439,8 +445,11 @@ fence_wait_any_timeout(struct fence **fe
 
 	if (timeout == 0) {
 		for (i = 0; i < count; ++i)
-			if (fence_is_signaled(fences[i]))
+			if (fence_is_signaled(fences[i])) {
+				if (idx)
+					*idx = i;
 				return 1;
+			}
 
 		return 0;
 	}
@@ -463,6 +472,8 @@ fence_wait_any_timeout(struct fence **fe
 		if (fence_add_callback(fence, &cb[i].base,
 				       fence_default_wait_cb)) {
 			/* This fence is already signaled */
+			if (idx)
+				*idx = i;
 			goto fence_rm_cb;
 		}
 	}
@@ -473,7 +484,7 @@ fence_wait_any_timeout(struct fence **fe
 		else
 			set_current_state(TASK_UNINTERRUPTIBLE);
 
-		if (fence_test_signaled_any(fences, count))
+		if (fence_test_signaled_any(fences, count, idx))
 			break;
 
 		ret = schedule_timeout(ret);
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_sa.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_sa.c
@@ -359,7 +359,8 @@ int amdgpu_sa_bo_new(struct amdgpu_sa_ma
 		if (count) {
 			spin_unlock(&sa_manager->wq.lock);
 			t = fence_wait_any_timeout(fences, count, false,
-						   MAX_SCHEDULE_TIMEOUT);
+						   MAX_SCHEDULE_TIMEOUT,
+						   NULL);
 			for (i = 0; i < count; ++i)
 				fence_put(fences[i]);
 
--- a/include/linux/fence.h
+++ b/include/linux/fence.h
@@ -323,7 +323,8 @@ static inline struct fence *fence_later(
 
 signed long fence_wait_timeout(struct fence *, bool intr, signed long timeout);
 signed long fence_wait_any_timeout(struct fence **fences, uint32_t count,
-				   bool intr, signed long timeout);
+				   bool intr, signed long timeout,
+				   uint32_t *idx);
 
 /**
  * fence_wait - sleep until the fence gets signaled
