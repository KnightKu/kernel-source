From: Andrew Lunn <andrew@lunn.ch>
Date: Wed, 6 Jan 2016 20:11:27 +0100
Subject: mdio: Abstract device_remove() and device_free()
Patch-mainline: v4.5-rc1
Git-commit: 711fdba37a3dd7ee487e28767f9f0e67144cbf80
References: bsc#1026030 FATE#321670

Make device_free and device_remove operations in the mdio device
structure, so the core code does not need to differentiate between
phy devices and generic mdio devices.

Signed-off-by: Andrew Lunn <andrew@lunn.ch>
Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Benjamin Poirier <bpoirier@suse.com>
---
 drivers/net/phy/mdio_bus.c    |   23 +++++++++--------------
 drivers/net/phy/mdio_device.c |    2 ++
 drivers/net/phy/phy_device.c  |   18 ++++++++++++++++++
 include/linux/mdio.h          |    4 ++++
 4 files changed, 33 insertions(+), 14 deletions(-)

--- a/drivers/net/phy/mdio_bus.c
+++ b/drivers/net/phy/mdio_bus.c
@@ -299,6 +299,7 @@ static inline void of_mdiobus_link_mdiod
  */
 int __mdiobus_register(struct mii_bus *bus, struct module *owner)
 {
+	struct mdio_device *mdiodev;
 	int i, err;
 
 	if (NULL == bus || NULL == bus->name ||
@@ -344,11 +345,12 @@ int __mdiobus_register(struct mii_bus *b
 
 error:
 	while (--i >= 0) {
-		struct phy_device *phydev = mdiobus_get_phy(bus, i);
-		if (phydev) {
-			phy_device_remove(phydev);
-			phy_device_free(phydev);
-		}
+		mdiodev = bus->mdio_map[i];
+		if (!mdiodev)
+			continue;
+
+		mdiodev->device_remove(mdiodev);
+		mdiodev->device_free(mdiodev);
 	}
 	device_del(&bus->dev);
 	return err;
@@ -358,7 +360,6 @@ EXPORT_SYMBOL(__mdiobus_register);
 void mdiobus_unregister(struct mii_bus *bus)
 {
 	struct mdio_device *mdiodev;
-	struct phy_device *phydev;
 	int i;
 
 	BUG_ON(bus->state != MDIOBUS_REGISTERED);
@@ -369,14 +370,8 @@ void mdiobus_unregister(struct mii_bus *
 		if (!mdiodev)
 			continue;
 
-		if (!(mdiodev->flags & MDIO_DEVICE_FLAG_PHY)) {
-			phydev = container_of(mdiodev, struct phy_device, mdio);
-			phy_device_remove(phydev);
-			phy_device_free(phydev);
-		} else {
-			mdio_device_remove(mdiodev);
-			mdio_device_free(mdiodev);
-		}
+		mdiodev->device_remove(mdiodev);
+		mdiodev->device_free(mdiodev);
 	}
 	device_del(&bus->dev);
 }
--- a/drivers/net/phy/mdio_device.c
+++ b/drivers/net/phy/mdio_device.c
@@ -46,6 +46,8 @@ struct mdio_device *mdio_device_create(s
 	mdiodev->dev.release = mdio_device_release;
 	mdiodev->dev.parent = &bus->dev;
 	mdiodev->dev.bus = &mdio_bus_type;
+	mdiodev->device_free = mdio_device_free;
+	mdiodev->device_remove = mdio_device_remove;
 	mdiodev->bus = bus;
 	mdiodev->addr = addr;
 
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@ -47,11 +47,27 @@ void phy_device_free(struct phy_device *
 }
 EXPORT_SYMBOL(phy_device_free);
 
+static void phy_mdio_device_free(struct mdio_device *mdiodev)
+{
+	struct phy_device *phydev;
+
+	phydev = container_of(mdiodev, struct phy_device, mdio);
+	phy_device_free(phydev);
+}
+
 static void phy_device_release(struct device *dev)
 {
 	kfree(to_phy_device(dev));
 }
 
+static void phy_mdio_device_remove(struct mdio_device *mdiodev)
+{
+	struct phy_device *phydev;
+
+	phydev = container_of(mdiodev, struct phy_device, mdio);
+	phy_device_remove(phydev);
+}
+
 enum genphy_driver {
 	GENPHY_DRV_1G,
 	GENPHY_DRV_10G,
@@ -308,6 +324,8 @@ struct phy_device *phy_device_create(str
 	mdiodev->bus_match = phy_bus_match;
 	mdiodev->addr = addr;
 	mdiodev->flags = MDIO_DEVICE_FLAG_PHY;
+	mdiodev->device_free = phy_mdio_device_free;
+	mdiodev->device_remove = phy_mdio_device_remove;
 
 	dev->speed = 0;
 	dev->duplex = -1;
--- a/include/linux/mdio.h
+++ b/include/linux/mdio.h
@@ -18,7 +18,11 @@ struct mdio_device {
 
 	const struct dev_pm_ops *pm_ops;
 	struct mii_bus *bus;
+
 	int (*bus_match)(struct device *dev, struct device_driver *drv);
+	void (*device_free)(struct mdio_device *mdiodev);
+	void (*device_remove)(struct mdio_device *mdiodev);
+
 	/* Bus address of the MDIO device (0-31) */
 	int addr;
 	int flags;
