From: Caesar Wang <wxt@rock-chips.com>
Date: Wed, 22 Jun 2016 18:13:57 +0800
Subject: thermal: rockchip: fixes the exception interrupts
Git-commit: 1f09ba82fa4bd405f5c656c48d53e076931b4a2d
Patch-mainline: v4.9-rc1
References: fate#322003

The hardware-tracked trips will set the alarm interrupt value for
registers. Then when the thermal zone has no trips to be set,
That make the thermal trips callback a over range value.

The root cause is the rk_tsadcv2_temp_to_code() function to handle the
invalid temperature range is indeed incorrect, let's fix it on now.
Otherwise, the thermal alarm interrupt will be triggered all the time
on some SoCs.

Fox example:
localhost tmp # grep thermal /proc/interrupts; sleep 5;
grep thermal /proc/interrupts

23:     994830  ..    GICv3 129 Level     rockchip_thermal
23:    1003423  ..    GICv3 129 Level     rockchip_thermal

Reported-by: Rocky Hao <rocky.hao@rock-chips.com>
Signed-off-by: Caesar Wang <wxt@rock-chips.com>
Cc: Zhang Rui <rui.zhang@intel.com>
Cc: Eduardo Valentin <edubezval@gmail.com>
Cc: Heiko Stuebner <heiko@sntech.de>
Cc: linux-pm@vger.kernel.org
Signed-off-by: Eduardo Valentin <edubezval@gmail.com>
Signed-off-by: Zhang Rui <rui.zhang@intel.com>
Signed-off-by: Matthias Brugger <mbrugger@suse.com>
---
 drivers/thermal/rockchip_thermal.c | 20 +++++++++++++++++---
 1 file changed, 17 insertions(+), 3 deletions(-)

diff --git a/drivers/thermal/rockchip_thermal.c b/drivers/thermal/rockchip_thermal.c
index 2d5ba97ade08..db5ecc5ed83a 100644
--- a/drivers/thermal/rockchip_thermal.c
+++ b/drivers/thermal/rockchip_thermal.c
@@ -401,13 +401,17 @@ static u32 rk_tsadcv2_temp_to_code(struct chip_tsadc_table table,
 				   int temp)
 {
 	int high, low, mid;
+	u32 error = 0;
 
 	low = 0;
 	high = table.length - 1;
 	mid = (high + low) / 2;
 
-	if (temp < table.id[low].temp || temp > table.id[high].temp)
-		return 0;
+	/* Return mask code data when the temp is over table range */
+	if (temp < table.id[low].temp || temp > table.id[high].temp) {
+		error = table.data_mask;
+		goto exit;
+	}
 
 	while (low <= high) {
 		if (temp == table.id[mid].temp)
@@ -419,7 +423,9 @@ static u32 rk_tsadcv2_temp_to_code(struct chip_tsadc_table table,
 		mid = (low + high) / 2;
 	}
 
-	return 0;
+exit:
+	pr_err("Invalid the conversion, error=%d\n", error);
+	return error;
 }
 
 static int rk_tsadcv2_code_to_temp(struct chip_tsadc_table table, u32 code,
@@ -651,7 +657,11 @@ static void rk_tsadcv2_alarm_temp(struct chip_tsadc_table table,
 {
 	u32 alarm_value, int_en;
 
+	/* Make sure the value is valid */
 	alarm_value = rk_tsadcv2_temp_to_code(table, temp);
+	if (alarm_value == table.data_mask)
+		return;
+
 	writel_relaxed(alarm_value & table.data_mask,
 		       regs + TSADCV2_COMP_INT(chn));
 
@@ -665,7 +675,11 @@ static void rk_tsadcv2_tshut_temp(struct chip_tsadc_table table,
 {
 	u32 tshut_value, val;
 
+	/* Make sure the value is valid */
 	tshut_value = rk_tsadcv2_temp_to_code(table, temp);
+	if (tshut_value == table.data_mask)
+		return;
+
 	writel_relaxed(tshut_value, regs + TSADCV2_COMP_SHUT(chn));
 
 	/* TSHUT will be valid */
-- 
2.11.0

