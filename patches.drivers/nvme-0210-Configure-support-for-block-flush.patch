From: Keith Busch <keith.busch@intel.com>
Date: Tue, 29 Apr 2014 11:41:28 -0600
Subject: NVMe: Configure support for block flush
References: bnc#913030,FATE#317455
Patch-Mainline: v3.17
Git-commit: a7d2ce2832d84e0182585f63bf96ca7323b3aee7

This configures an nvme request_queue as flush capable if the device
has a volatile write cache present.

Signed-off-by: Keith Busch <keith.busch@intel.com>
Signed-off-by: Matthew Wilcox <matthew.r.wilcox@intel.com>
Acked-by: Hannes Reinecke <hare@suse.de>
---
 drivers/block/nvme-core.c |    3 +++
 include/linux/nvme.h      |    2 ++
 2 files changed, 5 insertions(+)

--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@ -1978,6 +1978,8 @@ static struct nvme_ns *nvme_alloc_ns(str
 	blk_queue_logical_block_size(ns->queue, 1 << ns->lba_shift);
 	if (dev->max_hw_sectors)
 		blk_queue_max_hw_sectors(ns->queue, dev->max_hw_sectors);
+	if (dev->vwc & NVME_CTRL_VWC_PRESENT)
+		blk_queue_flush(ns->queue, REQ_FLUSH | REQ_FUA);
 
 	disk->major = nvme_major;
 	disk->first_minor = 0;
@@ -2297,6 +2299,7 @@ static int nvme_dev_add(struct nvme_dev
 	nn = le32_to_cpup(&ctrl->nn);
 	dev->oncs = le16_to_cpup(&ctrl->oncs);
 	dev->abort_limit = ctrl->acl + 1;
+	dev->vwc = ctrl->vwc;
 	memcpy(dev->serial, ctrl->sn, sizeof(ctrl->sn));
 	memcpy(dev->model, ctrl->mn, sizeof(ctrl->mn));
 	memcpy(dev->firmware_rev, ctrl->fr, sizeof(ctrl->fr));
--- a/include/linux/nvme.h
+++ b/include/linux/nvme.h
@@ -115,6 +115,7 @@ enum {
 	NVME_CTRL_ONCS_COMPARE			= 1 << 0,
 	NVME_CTRL_ONCS_WRITE_UNCORRECTABLE	= 1 << 1,
 	NVME_CTRL_ONCS_DSM			= 1 << 2,
+	NVME_CTRL_VWC_PRESENT			= 1 << 0,
 };
 
 struct nvme_lbaf {
@@ -565,6 +566,7 @@ struct nvme_dev {
 	u32 stripe_size;
 	u16 oncs;
 	u16 abort_limit;
+	u8 vwc;
 	u8 initialized;
 };
 
