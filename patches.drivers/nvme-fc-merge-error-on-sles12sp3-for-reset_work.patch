From 3d5223d10dcddfceab673ae07ccd9936a54534f6 Mon Sep 17 00:00:00 2001
From: James Smart <jsmart2021@gmail.com>
Date: Fri, 2 Feb 2018 15:34:42 -0800
Subject: nvme-fc: merge error on sles12sp3 for reset_work
References: bsc#1079195
Patch-mainline: Never, SLE12-SP3 specific

When the upstream patches were converted to sles12sp3, which does
not have the "commonized" reset path, the conversion only schedules
the reset work. It forgot to change the ctrl state. The controller
state is what protects against multiple scheduleding of redundant
errors on the controller.

Minimally, we have seen 10's (100's?) of io aborts causing multiple
attempts to schedule the reset as it isn't blocked by the state change.
Things get rather hosed up after this point and the reset never completes.
Additionally, it causes multiple reschedules of something alredy scheduled
perhaps. We also believe we've seen a case of the queue_delayed_work()
to hit a race condition on a linked list that became corrupt and faulted.

Fix by adding back the state change - which is the first thing done in
the upstream commonized code.

Signed-off-by: James Smart <james.smart@broadcom.com>
Acked-by: Johannes Thumshirn <jthumshirn@suse.de>
---
 drivers/nvme/host/fc.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/drivers/nvme/host/fc.c b/drivers/nvme/host/fc.c
index ccb688d8eb84..dd10ad5b073c 100644
--- a/drivers/nvme/host/fc.c
+++ b/drivers/nvme/host/fc.c
@@ -2124,6 +2124,9 @@ nvme_fc_error_recovery(struct nvme_fc_ctrl *ctrl, char *errmsg)
 	if (ctrl->ctrl.state != NVME_CTRL_LIVE)
 		return;
 
+	if (!nvme_change_ctrl_state(&ctrl->ctrl, NVME_CTRL_RESETTING))
+		return;
+
 	dev_warn(ctrl->ctrl.device,
 		"NVME-FC{%d}: transport association error detected: %s\n",
 		ctrl->cnum, errmsg);
-- 
2.13.1

