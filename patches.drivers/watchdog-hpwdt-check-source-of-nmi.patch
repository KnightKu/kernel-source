From BPetkov@suse.com Mon Dec  4 23:52:52 2017
From: Jerry Hoemann <jerry.hoemann@hpe.com>
To: bp@suse.de
Cc: root <root@tanerite01.ftc.rdlabs.hpecorp.net>
Subject: [PATCH] watchdog/hpwdt: Check source of NMI
Date: Mon,  4 Dec 2017 15:39:36 -0700
Message-Id: <1512427176-4164-1-git-send-email-jerry.hoemann@hpe.com>
X-Mailer: git-send-email 1.8.3.1
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Content-Type: text/plain; charset=utf-8
Status: RO
X-Status: F
Patch-mainline: no, never. A SLE11-specific fix
References: bsc#1024612

From: Jerry Hoemann <jerry.hoemann@hpe.com>

Do not claim the NMI (i.e. return NOTIFY_OK) if the source of
the NMI isn't the iLO watchdog or debug.

Profiling in SLES 11 SP4 will fail to claim an NMI it generates once
every 1 to 10 million times.  These NMIs become "NMIUNKNOWN" and would
be claimed by hpwdt and cause spurious system crashes during profiling
except that perf_event is prioritized ahead of hpwdt and claims them
instead.

Profiling in SLES 12 has been re-written and doesn't generate unknown
NMIs. SLES 12 also doesn't have the priority driver setting for hpwdt.

hpwdt will claim NMIs that are of type NMIIOCK, NMISERR, or NMIUNKOWN.
Prior proliant system would siginal iLO generated NMI as NMIIOCK.

However, due to a limitation in the Gen 10 processors, NMI generated
by iLO (ASR or explicit NMI button) will not show up as NMIIOCK,
but only as NMIUNKNOWN.  Since hpwdt is prioritized behind perf_event,
hpwdt will not see any iLO generated NMI in SLES 11 SP4.

The iLO NMI feature works on SLES12 on Gen10 systems as profiling
doesn't generate NMIUNKNOWN and it is safe to allow hpwdt to claim them.

With this patch it will be safe to prioritize hpwdt ahead of
perf_event in SLES 11 SP4 and enable the iLO NMI feature.

Signed-off-by: Jerry Hoemann <jerry.hoemann@hpe.com>
Cc: Borislav Petkov <bp@suse.de>
Cc: Guenter Roeck <linux@roeck-us.net>
Cc: Jimmy Vance <jimmy.vance@hpe.com>
Cc: Wim Van Sebroeck <wim@iguana.be>
Cc: linux-watchdog@vger.kernel.org
Cc: lkml <linux-kernel@vger.kernel.org>
Cc: root <root@tanerite01.ftc.rdlabs.hpecorp.net>
Acked-by: Borislav Petkov <bp@suse.de>
---
 drivers/watchdog/hpwdt.c |   11 +++++++++++
 1 file changed, 11 insertions(+)

--- a/drivers/watchdog/hpwdt.c
+++ b/drivers/watchdog/hpwdt.c
@@ -49,6 +49,7 @@ static char expect_release;
 static unsigned long hpwdt_is_open;
 
 static void __iomem *pci_mem_addr;		/* the PCI-memory address */
+static unsigned long __iomem *hpwdt_nmistat;
 static unsigned long __iomem *hpwdt_timer_reg;
 static unsigned long __iomem *hpwdt_timer_con;
 
@@ -478,6 +479,11 @@ static int hpwdt_time_left(void)
 	return TICKS_TO_SECS(ioread16(hpwdt_timer_reg));
 }
 
+static int hpwdt_my_nmi(void)
+{
+	return ioread8(hpwdt_nmistat) & 0x6;
+}
+
 #ifdef CONFIG_HPWDT_NMI_DECODING
 /*
  *	NMI Handler
@@ -496,6 +502,10 @@ static int hpwdt_pretimeout(struct notif
 	if (!hpwdt_nmi_decoding)
 		goto out;
 
+	if ((ulReason == DIE_NMIUNKNOWN) && !hpwdt_my_nmi())
+		goto out;
+
+
 	spin_lock_irqsave(&rom_lock, rom_pl);
 	if (!die_nmi_called && !is_icru && !is_uefi)
 		asminline_call(&cmn_regs, cru_rom_addr);
@@ -837,6 +847,7 @@ static int __devinit hpwdt_init_one(stru
 		retval = -ENOMEM;
 		goto error_pci_iomap;
 	}
+	hpwdt_nmistat	= pci_mem_addr + 0x6e;
 	hpwdt_timer_reg = pci_mem_addr + 0x70;
 	hpwdt_timer_con = pci_mem_addr + 0x72;
 
