From: Edward Cree <ecree@solarflare.com>
Date: Wed, 15 Jun 2016 17:49:05 +0100
Subject: sfc: Refactor checks for invalid filter ID
Patch-mainline: v4.8-rc1
Git-commit: 8c91562075e8621f6d9a11cfcf31a71a7203cbbe
References: bsc#1017967 FATE#321663

Nearly every time we call efx_ef10_filter_remove_unsafe, we first check
for EFX_EF10_FILTER_ID_INVALID, in which case we do nothing.  So move
that check into the function, simplifying all the call sites.

Also, change the return type to void, since none of the callers check it.

Signed-off-by: Edward Cree <ecree@solarflare.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: David Chang <dchang@suse.com>
---
 drivers/net/ethernet/sfc/ef10.c |   39 +++++++++++++--------------------------
 1 file changed, 13 insertions(+), 26 deletions(-)

--- a/drivers/net/ethernet/sfc/ef10.c
+++ b/drivers/net/ethernet/sfc/ef10.c
@@ -3580,12 +3580,13 @@ static u32 efx_ef10_filter_get_unsafe_id
 	return filter_id % HUNT_FILTER_TBL_ROWS;
 }
 
-static int efx_ef10_filter_remove_unsafe(struct efx_nic *efx,
-					 enum efx_filter_priority priority,
-					 u32 filter_id)
+static void efx_ef10_filter_remove_unsafe(struct efx_nic *efx,
+					  enum efx_filter_priority priority,
+					  u32 filter_id)
 {
-	return efx_ef10_filter_remove_internal(efx, 1U << priority,
-					       filter_id, true);
+	if (filter_id == EFX_EF10_FILTER_ID_INVALID)
+		return;
+	efx_ef10_filter_remove_internal(efx, 1U << priority, filter_id, true);
 }
 
 static int efx_ef10_filter_get_safe(struct efx_nic *efx,
@@ -4241,8 +4242,6 @@ static int efx_ef10_filter_insert_addr_l
 					   rc);
 				/* Fall back to promiscuous */
 				for (j = 0; j < i; j++) {
-					if (ids[j] == EFX_EF10_FILTER_ID_INVALID)
-						continue;
 					efx_ef10_filter_remove_unsafe(
 						efx, EFX_FILTER_PRI_AUTO,
 						ids[j]);
@@ -4268,8 +4267,6 @@ static int efx_ef10_filter_insert_addr_l
 				   "Broadcast filter insert failed rc=%d\n", rc);
 			/* Fall back to promiscuous */
 			for (j = 0; j < i; j++) {
-				if (ids[j] == EFX_EF10_FILTER_ID_INVALID)
-					continue;
 				efx_ef10_filter_remove_unsafe(
 					efx, EFX_FILTER_PRI_AUTO,
 					ids[j]);
@@ -4628,25 +4625,15 @@ static void efx_ef10_filter_del_vlan_int
 
 	list_del(&vlan->list);
 
-	for (i = 0; i < ARRAY_SIZE(vlan->uc); i++) {
-		if (vlan->uc[i] != EFX_EF10_FILTER_ID_INVALID)
-			efx_ef10_filter_remove_unsafe(efx, EFX_FILTER_PRI_AUTO,
-						      vlan->uc[i]);
-	}
-	for (i = 0; i < ARRAY_SIZE(vlan->mc); i++) {
-		if (vlan->mc[i] != EFX_EF10_FILTER_ID_INVALID)
-			efx_ef10_filter_remove_unsafe(efx, EFX_FILTER_PRI_AUTO,
-						      vlan->mc[i]);
-	}
-	if (vlan->ucdef != EFX_EF10_FILTER_ID_INVALID)
-		efx_ef10_filter_remove_unsafe(efx, EFX_FILTER_PRI_AUTO,
-					      vlan->ucdef);
-	if (vlan->bcast != EFX_EF10_FILTER_ID_INVALID)
+	for (i = 0; i < ARRAY_SIZE(vlan->uc); i++)
 		efx_ef10_filter_remove_unsafe(efx, EFX_FILTER_PRI_AUTO,
-					      vlan->bcast);
-	if (vlan->mcdef != EFX_EF10_FILTER_ID_INVALID)
+					      vlan->uc[i]);
+	for (i = 0; i < ARRAY_SIZE(vlan->mc); i++)
 		efx_ef10_filter_remove_unsafe(efx, EFX_FILTER_PRI_AUTO,
-					      vlan->mcdef);
+					      vlan->mc[i]);
+	efx_ef10_filter_remove_unsafe(efx, EFX_FILTER_PRI_AUTO, vlan->ucdef);
+	efx_ef10_filter_remove_unsafe(efx, EFX_FILTER_PRI_AUTO, vlan->bcast);
+	efx_ef10_filter_remove_unsafe(efx, EFX_FILTER_PRI_AUTO, vlan->mcdef);
 
 	kfree(vlan);
 }
