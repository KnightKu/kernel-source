From 4ff83a07529ae4cbf76a40c44fb8cd9f1febc608 Mon Sep 17 00:00:00 2001
From: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
Date: Thu, 21 Jan 2016 10:49:21 -0200
Subject: [PATCH 14/88] staging/android: remove struct sync_pt
Git-commit: b55b54b5db330e36cd465adb3fbe274ffb1061d3
Patch-mainline: v4.6-rc1
References: fate#321223

struct sync_pt was just wrapping around struct fence and creating an
extra abstraction layer. The only two members of struct sync_pt, child_list
and active_list, were moved to struct fence in an earlier commit. After
removing those two members struct sync_pt is nothing more than struct
fence, so remove it all and use struct fence directly.

Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/staging/android/sw_sync.c    |  23 ++++----
 drivers/staging/android/sw_sync.h    |   8 +--
 drivers/staging/android/sync.c       | 101 +++++++++++++++--------------------
 drivers/staging/android/sync.h       |  63 +++++++---------------
 drivers/staging/android/sync_debug.c |  49 ++++++++---------
 drivers/staging/android/trace/sync.h |  14 ++---
 include/linux/fence.h                |   2 +
 7 files changed, 113 insertions(+), 147 deletions(-)

diff --git a/drivers/staging/android/sw_sync.c b/drivers/staging/android/sw_sync.c
index f491dbce5696..3bee959b41d8 100644
--- a/drivers/staging/android/sw_sync.c
+++ b/drivers/staging/android/sw_sync.c
@@ -25,7 +25,7 @@
 
 #include "sw_sync.h"
 
-struct sync_pt *sw_sync_pt_create(struct sw_sync_timeline *obj, u32 value)
+struct fence *sw_sync_pt_create(struct sw_sync_timeline *obj, u32 value)
 {
 	struct sw_sync_pt *pt;
 
@@ -34,23 +34,23 @@ struct sync_pt *sw_sync_pt_create(struct sw_sync_timeline *obj, u32 value)
 
 	pt->value = value;
 
-	return (struct sync_pt *)pt;
+	return (struct fence *)pt;
 }
 EXPORT_SYMBOL(sw_sync_pt_create);
 
-static int sw_sync_pt_has_signaled(struct sync_pt *sync_pt)
+static int sw_sync_fence_has_signaled(struct fence *fence)
 {
-	struct sw_sync_pt *pt = (struct sw_sync_pt *)sync_pt;
+	struct sw_sync_pt *pt = (struct sw_sync_pt *)fence;
 	struct sw_sync_timeline *obj =
-		(struct sw_sync_timeline *)sync_pt_parent(sync_pt);
+		(struct sw_sync_timeline *)fence_parent(fence);
 
 	return (pt->value > obj->value) ? 0 : 1;
 }
 
-static int sw_sync_fill_driver_data(struct sync_pt *sync_pt,
+static int sw_sync_fill_driver_data(struct fence *fence,
 				    void *data, int size)
 {
-	struct sw_sync_pt *pt = (struct sw_sync_pt *)sync_pt;
+	struct sw_sync_pt *pt = (struct sw_sync_pt *)fence;
 
 	if (size < sizeof(pt->value))
 		return -ENOMEM;
@@ -68,20 +68,19 @@ static void sw_sync_timeline_value_str(struct sync_timeline *sync_timeline,
 	snprintf(str, size, "%d", timeline->value);
 }
 
-static void sw_sync_pt_value_str(struct sync_pt *sync_pt,
-				 char *str, int size)
+static void sw_sync_fence_value_str(struct fence *fence, char *str, int size)
 {
-	struct sw_sync_pt *pt = (struct sw_sync_pt *)sync_pt;
+	struct sw_sync_pt *pt = (struct sw_sync_pt *)fence;
 
 	snprintf(str, size, "%d", pt->value);
 }
 
 static struct sync_timeline_ops sw_sync_timeline_ops = {
 	.driver_name = "sw_sync",
-	.has_signaled = sw_sync_pt_has_signaled,
+	.has_signaled = sw_sync_fence_has_signaled,
 	.fill_driver_data = sw_sync_fill_driver_data,
 	.timeline_value_str = sw_sync_timeline_value_str,
-	.pt_value_str = sw_sync_pt_value_str,
+	.fence_value_str = sw_sync_fence_value_str,
 };
 
 struct sw_sync_timeline *sw_sync_timeline_create(const char *name)
diff --git a/drivers/staging/android/sw_sync.h b/drivers/staging/android/sw_sync.h
index c87ae9ebf267..e18667bfb0ca 100644
--- a/drivers/staging/android/sw_sync.h
+++ b/drivers/staging/android/sw_sync.h
@@ -29,7 +29,7 @@ struct sw_sync_timeline {
 };
 
 struct sw_sync_pt {
-	struct sync_pt		pt;
+	struct fence		pt;
 
 	u32			value;
 };
@@ -38,7 +38,7 @@ struct sw_sync_pt {
 struct sw_sync_timeline *sw_sync_timeline_create(const char *name);
 void sw_sync_timeline_inc(struct sw_sync_timeline *obj, u32 inc);
 
-struct sync_pt *sw_sync_pt_create(struct sw_sync_timeline *obj, u32 value);
+struct fence *sw_sync_pt_create(struct sw_sync_timeline *obj, u32 value);
 #else
 static inline struct sw_sync_timeline *sw_sync_timeline_create(const char *name)
 {
@@ -49,8 +49,8 @@ static inline void sw_sync_timeline_inc(struct sw_sync_timeline *obj, u32 inc)
 {
 }
 
-static inline struct sync_pt *sw_sync_pt_create(struct sw_sync_timeline *obj,
-						u32 value)
+static inline struct fence *sw_sync_pt_create(struct sw_sync_timeline *obj,
+					      u32 value)
 {
 	return NULL;
 }
diff --git a/drivers/staging/android/sync.c b/drivers/staging/android/sync.c
index 22b1d9b03fd6..3c2c8d07df62 100644
--- a/drivers/staging/android/sync.c
+++ b/drivers/staging/android/sync.c
@@ -102,51 +102,45 @@ void sync_timeline_signal(struct sync_timeline *obj)
 {
 	unsigned long flags;
 	LIST_HEAD(signaled_pts);
-	struct sync_pt *pt, *next;
+	struct fence *fence, *next;
 
 	trace_sync_timeline(obj);
 
 	spin_lock_irqsave(&obj->child_list_lock, flags);
 
-	list_for_each_entry_safe(pt, next, &obj->active_list_head,
+	list_for_each_entry_safe(fence, next, &obj->active_list_head,
 				 active_list) {
-		if (fence_is_signaled_locked(&pt->base))
-			list_del_init(&pt->active_list);
+		if (fence_is_signaled_locked(fence))
+			list_del_init(&fence->active_list);
 	}
 
 	spin_unlock_irqrestore(&obj->child_list_lock, flags);
 }
 EXPORT_SYMBOL(sync_timeline_signal);
 
-struct sync_pt *sync_pt_create(struct sync_timeline *obj, int size)
+struct fence *sync_pt_create(struct sync_timeline *obj, int size)
 {
 	unsigned long flags;
-	struct sync_pt *pt;
+	struct fence *fence;
 
-	if (size < sizeof(struct sync_pt))
+	if (size < sizeof(*fence))
 		return NULL;
 
-	pt = kzalloc(size, GFP_KERNEL);
-	if (!pt)
+	fence = kzalloc(size, GFP_KERNEL);
+	if (!fence)
 		return NULL;
 
 	spin_lock_irqsave(&obj->child_list_lock, flags);
 	sync_timeline_get(obj);
-	fence_init(&pt->base, &android_fence_ops, &obj->child_list_lock,
+	fence_init(fence, &android_fence_ops, &obj->child_list_lock,
 		   obj->context, ++obj->value);
-	list_add_tail(&pt->child_list, &obj->child_list_head);
-	INIT_LIST_HEAD(&pt->active_list);
+	list_add_tail(&fence->child_list, &obj->child_list_head);
+	INIT_LIST_HEAD(&fence->active_list);
 	spin_unlock_irqrestore(&obj->child_list_lock, flags);
-	return pt;
+	return fence;
 }
 EXPORT_SYMBOL(sync_pt_create);
 
-void sync_pt_free(struct sync_pt *pt)
-{
-	fence_put(&pt->base);
-}
-EXPORT_SYMBOL(sync_pt_free);
-
 static struct sync_file *sync_file_alloc(int size, const char *name)
 {
 	struct sync_file *sync_file;
@@ -184,8 +178,8 @@ static void fence_check_cb_func(struct fence *f, struct fence_cb *cb)
 		wake_up_all(&sync_file->wq);
 }
 
-/* TODO: implement a create which takes more that one sync_pt */
-struct sync_file *sync_file_create_dma(const char *name, struct fence *pt)
+/* TODO: implement a create which takes more that one fence */
+struct sync_file *sync_file_create_dma(const char *name, struct fence *fence)
 {
 	struct sync_file *sync_file;
 
@@ -197,9 +191,10 @@ struct sync_file *sync_file_create_dma(const char *name, struct fence *pt)
 	sync_file->num_fences = 1;
 	atomic_set(&sync_file->status, 1);
 
-	sync_file->cbs[0].fence = pt;
+	sync_file->cbs[0].fence = fence;
 	sync_file->cbs[0].sync_file = sync_file;
-	if (fence_add_callback(pt, &sync_file->cbs[0].cb, fence_check_cb_func))
+	if (fence_add_callback(fence, &sync_file->cbs[0].cb,
+			       fence_check_cb_func))
 		atomic_dec(&sync_file->status);
 
 	sync_file_debug_add(sync_file);
@@ -208,9 +203,9 @@ struct sync_file *sync_file_create_dma(const char *name, struct fence *pt)
 }
 EXPORT_SYMBOL(sync_file_create_dma);
 
-struct sync_file *sync_file_create(const char *name, struct sync_pt *pt)
+struct sync_file *sync_file_create(const char *name, struct fence *fence)
 {
-	return sync_file_create_dma(name, &pt->base);
+	return sync_file_create_dma(name, fence);
 }
 EXPORT_SYMBOL(sync_file_create);
 
@@ -245,14 +240,14 @@ void sync_file_install(struct sync_file *sync_file, int fd)
 EXPORT_SYMBOL(sync_file_install);
 
 static void sync_file_add_pt(struct sync_file *sync_file, int *i,
-			     struct fence *pt)
+			     struct fence *fence)
 {
-	sync_file->cbs[*i].fence = pt;
+	sync_file->cbs[*i].fence = fence;
 	sync_file->cbs[*i].sync_file = sync_file;
 
-	if (!fence_add_callback(pt, &sync_file->cbs[*i].cb,
+	if (!fence_add_callback(fence, &sync_file->cbs[*i].cb,
 				fence_check_cb_func)) {
-		fence_get(pt);
+		fence_get(fence);
 		(*i)++;
 	}
 }
@@ -328,7 +323,7 @@ int sync_file_wait(struct sync_file *sync_file, long timeout)
 
 	trace_sync_wait(sync_file, 1);
 	for (i = 0; i < sync_file->num_fences; ++i)
-		trace_sync_pt(sync_file->cbs[i].fence);
+		trace_fence(sync_file->cbs[i].fence);
 	ret = wait_event_interruptible_timeout(sync_file->wq,
 					       atomic_read(&sync_file->status) <= 0,
 					       timeout);
@@ -356,43 +351,39 @@ EXPORT_SYMBOL(sync_file_wait);
 
 static const char *android_fence_get_driver_name(struct fence *fence)
 {
-	struct sync_pt *pt = container_of(fence, struct sync_pt, base);
-	struct sync_timeline *parent = sync_pt_parent(pt);
+	struct sync_timeline *parent = fence_parent(fence);
 
 	return parent->ops->driver_name;
 }
 
 static const char *android_fence_get_timeline_name(struct fence *fence)
 {
-	struct sync_pt *pt = container_of(fence, struct sync_pt, base);
-	struct sync_timeline *parent = sync_pt_parent(pt);
+	struct sync_timeline *parent = fence_parent(fence);
 
 	return parent->name;
 }
 
 static void android_fence_release(struct fence *fence)
 {
-	struct sync_pt *pt = container_of(fence, struct sync_pt, base);
-	struct sync_timeline *parent = sync_pt_parent(pt);
+	struct sync_timeline *parent = fence_parent(fence);
 	unsigned long flags;
 
 	spin_lock_irqsave(fence->lock, flags);
-	list_del(&pt->child_list);
-	if (WARN_ON_ONCE(!list_empty(&pt->active_list)))
-		list_del(&pt->active_list);
+	list_del(&fence->child_list);
+	if (WARN_ON_ONCE(!list_empty(&fence->active_list)))
+		list_del(&fence->active_list);
 	spin_unlock_irqrestore(fence->lock, flags);
 
 	sync_timeline_put(parent);
-	fence_free(&pt->base);
+	fence_free(fence);
 }
 
 static bool android_fence_signaled(struct fence *fence)
 {
-	struct sync_pt *pt = container_of(fence, struct sync_pt, base);
-	struct sync_timeline *parent = sync_pt_parent(pt);
+	struct sync_timeline *parent = fence_parent(fence);
 	int ret;
 
-	ret = parent->ops->has_signaled(pt);
+	ret = parent->ops->has_signaled(fence);
 	if (ret < 0)
 		fence->status = ret;
 	return ret;
@@ -400,46 +391,42 @@ static bool android_fence_signaled(struct fence *fence)
 
 static bool android_fence_enable_signaling(struct fence *fence)
 {
-	struct sync_pt *pt = container_of(fence, struct sync_pt, base);
-	struct sync_timeline *parent = sync_pt_parent(pt);
+	struct sync_timeline *parent = fence_parent(fence);
 
 	if (android_fence_signaled(fence))
 		return false;
 
-	list_add_tail(&pt->active_list, &parent->active_list_head);
+	list_add_tail(&fence->active_list, &parent->active_list_head);
 	return true;
 }
 
 static int android_fence_fill_driver_data(struct fence *fence,
 					  void *data, int size)
 {
-	struct sync_pt *pt = container_of(fence, struct sync_pt, base);
-	struct sync_timeline *parent = sync_pt_parent(pt);
+	struct sync_timeline *parent = fence_parent(fence);
 
 	if (!parent->ops->fill_driver_data)
 		return 0;
-	return parent->ops->fill_driver_data(pt, data, size);
+	return parent->ops->fill_driver_data(fence, data, size);
 }
 
 static void android_fence_value_str(struct fence *fence,
 				    char *str, int size)
 {
-	struct sync_pt *pt = container_of(fence, struct sync_pt, base);
-	struct sync_timeline *parent = sync_pt_parent(pt);
+	struct sync_timeline *parent = fence_parent(fence);
 
-	if (!parent->ops->pt_value_str) {
+	if (!parent->ops->fence_value_str) {
 		if (size)
 			*str = 0;
 		return;
 	}
-	parent->ops->pt_value_str(pt, str, size);
+	parent->ops->fence_value_str(fence, str, size);
 }
 
 static void android_fence_timeline_value_str(struct fence *fence,
 					     char *str, int size)
 {
-	struct sync_pt *pt = container_of(fence, struct sync_pt, base);
-	struct sync_timeline *parent = sync_pt_parent(pt);
+	struct sync_timeline *parent = fence_parent(fence);
 
 	if (!parent->ops->timeline_value_str) {
 		if (size)
@@ -624,9 +611,9 @@ static long sync_file_ioctl_fence_info(struct sync_file *sync_file,
 	len = sizeof(struct sync_file_info_data);
 
 	for (i = 0; i < sync_file->num_fences; ++i) {
-		struct fence *pt = sync_file->cbs[i].fence;
+		struct fence *fence = sync_file->cbs[i].fence;
 
-		ret = sync_fill_pt_info(pt, (u8 *)data + len, size - len);
+		ret = sync_fill_pt_info(fence, (u8 *)data + len, size - len);
 
 		if (ret < 0)
 			goto out;
diff --git a/drivers/staging/android/sync.h b/drivers/staging/android/sync.h
index a18d1e3365fb..8cdac1a12e4f 100644
--- a/drivers/staging/android/sync.h
+++ b/drivers/staging/android/sync.h
@@ -24,7 +24,6 @@
 #include "uapi/sync.h"
 
 struct sync_timeline;
-struct sync_pt;
 struct sync_file;
 
 /**
@@ -39,23 +38,23 @@ struct sync_file;
  *			  as specified by size.  This information is returned
  *			  to userspace by SYNC_IOC_FENCE_INFO.
  * @timeline_value_str: fill str with the value of the sync_timeline's counter
- * @pt_value_str:	fill str with the value of the sync_pt
+ * @fence_value_str:	fill str with the value of the fence
  */
 struct sync_timeline_ops {
 	const char *driver_name;
 
 	/* required */
-	int (*has_signaled)(struct sync_pt *pt);
+	int (*has_signaled)(struct fence *fence);
 
 	/* optional */
-	int (*fill_driver_data)(struct sync_pt *syncpt, void *data, int size);
+	int (*fill_driver_data)(struct fence *fence, void *data, int size);
 
 	/* optional */
 	void (*timeline_value_str)(struct sync_timeline *timeline, char *str,
 				   int size);
 
 	/* optional */
-	void (*pt_value_str)(struct sync_pt *pt, char *str, int size);
+	void (*fence_value_str)(struct fence *fence, char *str, int size);
 };
 
 /**
@@ -66,7 +65,7 @@ struct sync_timeline_ops {
  * @destroyed:		set when sync_timeline is destroyed
  * @child_list_head:	list of children sync_pts for this sync_timeline
  * @child_list_lock:	lock protecting @child_list_head, destroyed, and
- *			  sync_pt.status
+ *			fence.status
  * @active_list_head:	list of active (unsignaled/errored) sync_pts
  * @sync_timeline_list:	membership in global sync_timeline_list
  */
@@ -89,22 +88,9 @@ struct sync_timeline {
 #endif
 };
 
-/**
- * struct sync_pt - sync point
- * @base:		base fence class
- * @child_list:		membership in sync_timeline.child_list_head
- * @active_list:	membership in sync_timeline.active_list_head
- */
-struct sync_pt {
-	struct fence base;
-
-	struct list_head	child_list;
-	struct list_head	active_list;
-};
-
-static inline struct sync_timeline *sync_pt_parent(struct sync_pt *pt)
+static inline struct sync_timeline *fence_parent(struct fence *fence)
 {
-	return container_of(pt->base.lock, struct sync_timeline,
+	return container_of(fence->lock, struct sync_timeline,
 			    child_list_lock);
 }
 
@@ -164,7 +150,7 @@ struct sync_timeline *sync_timeline_create(const struct sync_timeline_ops *ops,
  *
  * A sync implementation should call this when the @obj is going away
  * (i.e. module unload.)  @obj won't actually be freed until all its children
- * sync_pts are freed.
+ * fences are freed.
  */
 void sync_timeline_destroy(struct sync_timeline *obj);
 
@@ -172,41 +158,32 @@ void sync_timeline_destroy(struct sync_timeline *obj);
  * sync_timeline_signal() - signal a status change on a sync_timeline
  * @obj:	sync_timeline to signal
  *
- * A sync implementation should call this any time one of it's sync_pts
+ * A sync implementation should call this any time one of it's fences
  * has signaled or has an error condition.
  */
 void sync_timeline_signal(struct sync_timeline *obj);
 
 /**
  * sync_pt_create() - creates a sync pt
- * @parent:	sync_pt's parent sync_timeline
+ * @parent:	fence's parent sync_timeline
  * @size:	size to allocate for this pt
  *
- * Creates a new sync_pt as a child of @parent.  @size bytes will be
+ * Creates a new fence as a child of @parent.  @size bytes will be
  * allocated allowing for implementation specific data to be kept after
- * the generic sync_timeline struct. Returns the sync_pt object or
+ * the generic sync_timeline struct. Returns the fence object or
  * NULL in case of error.
  */
-struct sync_pt *sync_pt_create(struct sync_timeline *parent, int size);
+struct fence *sync_pt_create(struct sync_timeline *parent, int size);
 
 /**
- * sync_pt_free() - frees a sync pt
- * @pt:		sync_pt to free
+ * sync_fence_create() - creates a sync fence
+ * @name:	name of fence to create
+ * @fence:	fence to add to the sync_fence
  *
- * This should only be called on sync_pts which have been created but
- * not added to a fence.
- */
-void sync_pt_free(struct sync_pt *pt);
-
-/**
- * sync_file_create() - creates a sync file
- * @name:	name of file to create
- * @pt:		sync_pt to add to the file
- *
- * Creates a sync_file containg @pt. Once this is called, the sync_file takes
- * ownership of @pt.
+ * Creates a sync_file containg @fence. Once this is called, the sync_file
+ * takes ownership of @fence.
  */
-struct sync_file *sync_file_create(const char *name, struct sync_pt *pt);
+struct sync_file *sync_file_create(const char *name, struct fence *fence);
 
 /**
  * sync_file_create_dma() - creates a sync file from dma-fence
@@ -228,7 +205,7 @@ struct sync_file *sync_file_create_dma(const char *name, struct fence *pt);
  * @a:		sync_file a
  * @b:		sync_file b
  *
- * Creates a new sync_file which contains copies of all the sync_pts in both
+ * Creates a new sync_file which contains copies of all the fences in both
  * @a and @b.  @a and @b remain valid, independent sync_file. Returns the
  * new merged sync_file or NULL in case of error.
  */
diff --git a/drivers/staging/android/sync_debug.c b/drivers/staging/android/sync_debug.c
index 85ae98a63a1e..fd13f1e885e5 100644
--- a/drivers/staging/android/sync_debug.c
+++ b/drivers/staging/android/sync_debug.c
@@ -85,39 +85,40 @@ static const char *sync_status_str(int status)
 	return "error";
 }
 
-static void sync_print_pt(struct seq_file *s, struct fence *pt, bool fence)
+static void sync_print_fence(struct seq_file *s, struct fence *fence, bool show)
 {
 	int status = 1;
+	struct sync_timeline *parent = fence_parent(fence);
 
-	if (fence_is_signaled_locked(pt))
-		status = pt->status;
+	if (fence_is_signaled_locked(fence))
+		status = fence->status;
 
-	seq_printf(s, "  %s%spt %s",
-		   fence && pt->ops->get_timeline_name ?
-		   pt->ops->get_timeline_name(pt) : "",
-		   fence ? "_" : "",
+	seq_printf(s, "  %s%sfence %s",
+		   show ? parent->name : "",
+		   show ? "_" : "",
 		   sync_status_str(status));
 
 	if (status <= 0) {
 		struct timespec64 ts64 =
-			ktime_to_timespec64(pt->timestamp);
+			ktime_to_timespec64(fence->timestamp);
 
 		seq_printf(s, "@%lld.%09ld", (s64)ts64.tv_sec, ts64.tv_nsec);
 	}
 
-	if ((!fence || pt->ops->timeline_value_str) &&
-	    pt->ops->fence_value_str) {
+	if ((!fence || fence->ops->timeline_value_str) &&
+		fence->ops->fence_value_str) {
 		char value[64];
 		bool success;
 
-		pt->ops->fence_value_str(pt, value, sizeof(value));
+		fence->ops->fence_value_str(fence, value, sizeof(value));
 		success = strlen(value);
 
 		if (success)
 			seq_printf(s, ": %s", value);
 
 		if (success && fence) {
-			pt->ops->timeline_value_str(pt, value, sizeof(value));
+			fence->ops->timeline_value_str(fence, value,
+						       sizeof(value));
 
 			if (strlen(value))
 				seq_printf(s, " / %s", value);
@@ -145,25 +146,25 @@ static void sync_print_obj(struct seq_file *s, struct sync_timeline *obj)
 
 	spin_lock_irqsave(&obj->child_list_lock, flags);
 	list_for_each(pos, &obj->child_list_head) {
-		struct sync_pt *pt =
-			container_of(pos, struct sync_pt, child_list);
-		sync_print_pt(s, &pt->base, false);
+		struct fence *fence =
+			container_of(pos, struct fence, child_list);
+		sync_print_fence(s, fence, false);
 	}
 	spin_unlock_irqrestore(&obj->child_list_lock, flags);
 }
 
 static void sync_print_sync_file(struct seq_file *s,
 				  struct sync_file *sync_file)
- {
+{
 	int i;
 
 	seq_printf(s, "[%p] %s: %s\n", sync_file, sync_file->name,
 		   sync_status_str(atomic_read(&sync_file->status)));
 
 	for (i = 0; i < sync_file->num_fences; ++i)
-		sync_print_pt(s, sync_file->cbs[i].fence, true);
- }
- 
+		sync_print_fence(s, sync_file->cbs[i].fence, true);
+}
+
 static int sync_debugfs_show(struct seq_file *s, void *unused)
 {
 	unsigned long flags;
@@ -244,7 +245,7 @@ static long sw_sync_ioctl_create_fence(struct sw_sync_timeline *obj,
 {
 	int fd = get_unused_fd_flags(O_CLOEXEC);
 	int err;
-	struct sync_pt *pt;
+	struct fence *fence;
 	struct sync_file *sync_file;
 	struct sw_sync_create_fence_data data;
 
@@ -256,16 +257,16 @@ static long sw_sync_ioctl_create_fence(struct sw_sync_timeline *obj,
 		goto err;
 	}
 
-	pt = sw_sync_pt_create(obj, data.value);
-	if (!pt) {
+	fence = sw_sync_pt_create(obj, data.value);
+	if (!fence) {
 		err = -ENOMEM;
 		goto err;
 	}
 
 	data.name[sizeof(data.name) - 1] = '\0';
-	sync_file = sync_file_create(data.name, pt);
+	sync_file = sync_file_create(data.name, fence);
 	if (!sync_file) {
-		sync_pt_free(pt);
+		fence_put(fence);
 		err = -ENOMEM;
 		goto err;
 	}
diff --git a/drivers/staging/android/trace/sync.h b/drivers/staging/android/trace/sync.h
index 80f5da4f2aa5..87c60e9f584e 100644
--- a/drivers/staging/android/trace/sync.h
+++ b/drivers/staging/android/trace/sync.h
@@ -53,20 +53,20 @@ TRACE_EVENT(sync_wait,
 			__get_str(name), __entry->status)
 );
 
-TRACE_EVENT(sync_pt,
-	TP_PROTO(struct fence *pt),
+TRACE_EVENT(fence,
+	TP_PROTO(struct fence *fence),
 
-	TP_ARGS(pt),
+	TP_ARGS(fence),
 
 	TP_STRUCT__entry(
-		__string(timeline, pt->ops->get_timeline_name(pt))
+		__string(timeline, fence->ops->get_timeline_name(fence))
 		__array(char, value, 32)
 	),
 
 	TP_fast_assign(
-		__assign_str(timeline, pt->ops->get_timeline_name(pt));
-		if (pt->ops->fence_value_str) {
-			pt->ops->fence_value_str(pt, __entry->value,
+		__assign_str(timeline, fence->ops->get_timeline_name(fence));
+		if (fence->ops->fence_value_str) {
+			fence->ops->fence_value_str(fence, __entry->value,
 							sizeof(__entry->value));
 		} else {
 			__entry->value[0] = '\0';
diff --git a/include/linux/fence.h b/include/linux/fence.h
index bb522011383b..605bd88246a6 100644
--- a/include/linux/fence.h
+++ b/include/linux/fence.h
@@ -79,6 +79,8 @@ struct fence {
 	unsigned long flags;
 	ktime_t timestamp;
 	int status;
+	struct list_head child_list;
+	struct list_head active_list;
 };
 
 enum fence_flag_bits {
-- 
2.12.0
