Delivered-To: matthias.bgg@gmail.com
Received: by 10.200.4.133 with SMTP id s5csp130403qtg;
        Thu, 27 Apr 2017 23:29:59 -0700 (PDT)
X-Received: by 10.84.217.136 with SMTP id p8mr13032093pli.47.1493360999456;
        Thu, 27 Apr 2017 23:29:59 -0700 (PDT)
Return-Path: <yankejian@huawei.com>
Received: from dfwrgout.huawei.com (dfwrgout.huawei.com. [206.16.17.72])
        by mx.google.com with ESMTPS id m1si4954068pld.265.2017.04.27.23.29.58
        for <matthias.bgg@gmail.com>
        (version=TLS1 cipher=AES128-SHA bits=128/128);
        Thu, 27 Apr 2017 23:29:59 -0700 (PDT)
Received-SPF: pass (google.com: domain of yankejian@huawei.com designates 206.16.17.72 as permitted sender) client-ip=206.16.17.72;
Authentication-Results: mx.google.com;
       spf=pass (google.com: domain of yankejian@huawei.com designates 206.16.17.72 as permitted sender) smtp.mailfrom=yankejian@huawei.com
Received: from 172.18.9.243 (EHLO dfweml701-cah.china.huawei.com) ([172.18.9.243])
	by dfwrg02-dlp.huawei.com (MOS 4.3.7-GA FastPath queued)
	with ESMTP id CDL51769;
	Fri, 28 Apr 2017 01:29:56 -0500 (CDT)
Received: from NKGEML413-HUB.china.huawei.com (10.98.56.74) by
 dfweml701-cah.china.huawei.com (10.193.5.175) with Microsoft SMTP Server
 (TLS) id 14.3.301.0; Thu, 27 Apr 2017 23:29:55 -0700
Received: from DGGEML404-HUB.china.huawei.com (10.3.17.39) by
 NKGEML413-HUB.china.huawei.com (10.98.56.74) with Microsoft SMTP Server (TLS)
 id 14.3.235.1; Fri, 28 Apr 2017 14:29:53 +0800
Received: from linux-ioko.site (10.71.200.31) by
 DGGEML404-HUB.china.huawei.com (10.3.17.39) with Microsoft SMTP Server id
 14.3.301.0; Fri, 28 Apr 2017 14:29:43 +0800
From: Yankejian <yankejian@huawei.com>
To: <davem@davemloft.net>, <salil.mehta@huawei.com>, <yisen.zhuang@huawei.com>,
        <matthias.bgg@gmail.com>, <yankejian@huawei.com>,
        <lipeng321@huawei.com>, <zhouhuiru@huawei.com>,
        <huangdaode@hisilicon.com>
CC: <netdev@vger.kernel.org>, <linuxarm@huawei.com>
Subject: [PATCH net-next v5 2/2] net: hns: support deferred probe when no mdio
Date: Fri, 28 Apr 2017 14:49:47 +0800
Message-ID: <1493362187-51671-3-git-send-email-yankejian@huawei.com>
X-Mailer: git-send-email 1.9.1
In-Reply-To: <1493362187-51671-1-git-send-email-yankejian@huawei.com>
References: <1493362187-51671-1-git-send-email-yankejian@huawei.com>
MIME-Version: 1.0
Content-Type: text/plain
X-Originating-IP: [10.71.200.31]
X-CFilter-Loop: Reflected

Patch-mainline: Submitted, https://patchwork.ozlabs.org/patch/756237
References: bsc#1033895

From: lipeng <lipeng321@huawei.com>

In the hip06 and hip07 SoCs, phy connect to mdio bus.The mdio
module is probed with module_init, and, as such,
is not guaranteed to probe before the HNS driver. So we need
to support deferred probe.

We check for probe deferral in the mac init, so we not init DSAF
when there is no mdio, and free all resource, to later learn that
we need to defer the probe.

Signed-off-by: lipeng <lipeng321@huawei.com>
Reviewed-by: Yisen Zhuang <yisen.zhuang@huawei.com>
Reviewed-by: Matthias Brugger <mbrugger@suse.com>
---
change log:
V4 -> V5:
1. Float on net-next;

V1 -> V2:
1. Return appropriate errno in hns_mac_register_phy;
---
 drivers/net/ethernet/hisilicon/hns/hns_dsaf_mac.c |   39 ++++++++++++++++++----
 1 file changed, 33 insertions(+), 6 deletions(-)

--- a/drivers/net/ethernet/hisilicon/hns/hns_dsaf_mac.c
+++ b/drivers/net/ethernet/hisilicon/hns/hns_dsaf_mac.c
@@ -696,6 +696,8 @@ hns_mac_register_phydev(struct mii_bus *
 	rc = phy_device_register(phy);
 	if (rc) {
 		phy_device_free(phy);
+		dev_err(&mdio->dev, "registered phy fail at address %i\n",
+			addr);
 		return -ENODEV;
 	}
 
@@ -706,7 +708,7 @@ hns_mac_register_phydev(struct mii_bus *
 	return 0;
 }
 
-static void hns_mac_register_phy(struct hns_mac_cb *mac_cb)
+static int hns_mac_register_phy(struct hns_mac_cb *mac_cb)
 {
 	struct acpi_reference_args args;
 	struct platform_device *pdev;
@@ -716,24 +718,39 @@ static void hns_mac_register_phy(struct
 
 	/* Loop over the child nodes and register a phy_device for each one */
 	if (!to_acpi_device_node(mac_cb->fw_port))
-		return;
+		return -ENODEV;
 
 	rc = acpi_node_get_property_reference(
 			mac_cb->fw_port, "mdio-node", 0, &args);
 	if (rc)
-		return;
+		return rc;
 
 	addr = hns_mac_phy_parse_addr(mac_cb->dev, mac_cb->fw_port);
 	if (addr < 0)
-		return;
+		return addr;
 
 	/* dev address in adev */
 	pdev = hns_dsaf_find_platform_device(acpi_fwnode_handle(args.adev));
+	if (!pdev) {
+		dev_err(mac_cb->dev, "mac%d mdio pdev is NULL\n",
+			mac_cb->mac_id);
+		return  -EINVAL;
+	}
+
 	mii_bus = platform_get_drvdata(pdev);
+	if (!mii_bus) {
+		dev_err(mac_cb->dev,
+			"mac%d mdio is NULL, dsaf will probe again later\n",
+			mac_cb->mac_id);
+		return -EPROBE_DEFER;
+	}
+
 	rc = hns_mac_register_phydev(mii_bus, mac_cb, addr);
 	if (!rc)
 		dev_dbg(mac_cb->dev, "mac%d register phy addr:%d\n",
 			mac_cb->mac_id, addr);
+
+	return rc;
 }
 
 #define MAC_MEDIA_TYPE_MAX_LEN		16
@@ -754,7 +771,7 @@ static const struct {
  *@np:device node
  * return: 0 --success, negative --fail
  */
-static int  hns_mac_get_info(struct hns_mac_cb *mac_cb)
+static int hns_mac_get_info(struct hns_mac_cb *mac_cb)
 {
 	struct device_node *np;
 	struct regmap *syscon;
@@ -864,7 +881,15 @@ static int  hns_mac_get_info(struct hns_
 			}
 		}
 	} else if (is_acpi_node(mac_cb->fw_port)) {
-		hns_mac_register_phy(mac_cb);
+		ret = hns_mac_register_phy(mac_cb);
+		/*
+		 * Mac can work well if there is phy or not.If the port don't
+		 * connect with phy, the return value will be ignored. Only
+		 * when there is phy but can't find mdio bus, the return value
+		 * will be handled.
+		 */
+		if (ret == -EPROBE_DEFER)
+			return ret;
 	} else {
 		dev_err(mac_cb->dev, "mac%d cannot find phy node\n",
 			mac_cb->mac_id);
@@ -1026,6 +1051,7 @@ int hns_mac_init(struct dsaf_device *dsa
 			dsaf_dev->mac_cb[port_id] = mac_cb;
 		}
 	}
+
 	/* init mac_cb for all port */
 	for (port_id = 0; port_id < max_port_num; port_id++) {
 		mac_cb = dsaf_dev->mac_cb[port_id];
@@ -1035,6 +1061,7 @@ int hns_mac_init(struct dsaf_device *dsa
 		ret = hns_mac_get_cfg(dsaf_dev, mac_cb);
 		if (ret)
 			return ret;
+
 		ret = hns_mac_init_ex(mac_cb);
 		if (ret)
 			return ret;
