From b9ad9b8565da5f6730464a35912dd3024acec81b Mon Sep 17 00:00:00 2001
From: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
Date: Thu, 21 Jan 2016 10:49:19 -0200
Subject: [PATCH 12/88] staging/android: rename sync_fence to sync_file
Git-commit: d7fdb0ae9d115fa14ff3a5382c8a62de41c7786a
Patch-mainline: v4.6-rc1
References: fate#321223

sync_file has a more close meaning to what a sync_fence really, a struct
that represent a file that can be used by userspace to get information on
a fence, or wait for it to be signaled.

Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Patrik Jakobsson <pjakobsson@suse.de>
---
 drivers/staging/android/sync.c       | 254 ++++++++++++++++++-----------------
 drivers/staging/android/sync.h       |  98 +++++++-------
 drivers/staging/android/sync_debug.c |  59 ++++----
 drivers/staging/android/trace/sync.h |  10 +-
 drivers/staging/android/uapi/sync.h  |  14 +-
 5 files changed, 221 insertions(+), 214 deletions(-)

diff --git a/drivers/staging/android/sync.c b/drivers/staging/android/sync.c
index f4d9bcddb6f8..8cccdf94ce77 100644
--- a/drivers/staging/android/sync.c
+++ b/drivers/staging/android/sync.c
@@ -32,7 +32,7 @@
 #include "trace/sync.h"
 
 static const struct fence_ops android_fence_ops;
-static const struct file_operations sync_fence_fops;
+static const struct file_operations sync_file_fops;
 
 struct sync_timeline *sync_timeline_create(const struct sync_timeline_ops *ops,
 					   int size, const char *name)
@@ -147,80 +147,81 @@ void sync_pt_free(struct sync_pt *pt)
 }
 EXPORT_SYMBOL(sync_pt_free);
 
-static struct sync_fence *sync_fence_alloc(int size, const char *name)
+static struct sync_file *sync_file_alloc(int size, const char *name)
 {
-	struct sync_fence *fence;
+	struct sync_file *sync_file;
 
-	fence = kzalloc(size, GFP_KERNEL);
-	if (!fence)
+	sync_file = kzalloc(size, GFP_KERNEL);
+	if (!sync_file)
 		return NULL;
 
-	fence->file = anon_inode_getfile("sync_fence", &sync_fence_fops,
-					 fence, 0);
-	if (IS_ERR(fence->file))
+	sync_file->file = anon_inode_getfile("sync_file", &sync_file_fops,
+					     sync_file, 0);
+	if (IS_ERR(sync_file->file))
 		goto err;
 
-	kref_init(&fence->kref);
-	strlcpy(fence->name, name, sizeof(fence->name));
+	kref_init(&sync_file->kref);
+	strlcpy(sync_file->name, name, sizeof(sync_file->name));
 
-	init_waitqueue_head(&fence->wq);
+	init_waitqueue_head(&sync_file->wq);
 
-	return fence;
+	return sync_file;
 
 err:
-	kfree(fence);
+	kfree(sync_file);
 	return NULL;
 }
 
 static void fence_check_cb_func(struct fence *f, struct fence_cb *cb)
 {
-	struct sync_fence_cb *check;
-	struct sync_fence *fence;
+	struct sync_file_cb *check;
+	struct sync_file *sync_file;
 
-	check = container_of(cb, struct sync_fence_cb, cb);
-	fence = check->fence;
+	check = container_of(cb, struct sync_file_cb, cb);
+	sync_file = check->sync_file;
 
-	if (atomic_dec_and_test(&fence->status))
-		wake_up_all(&fence->wq);
+	if (atomic_dec_and_test(&sync_file->status))
+		wake_up_all(&sync_file->wq);
 }
 
 /* TODO: implement a create which takes more that one sync_pt */
-struct sync_fence *sync_fence_create_dma(const char *name, struct fence *pt)
+struct sync_file *sync_file_create_dma(const char *name, struct fence *pt)
 {
-	struct sync_fence *fence;
+	struct sync_file *sync_file;
 
-	fence = sync_fence_alloc(offsetof(struct sync_fence, cbs[1]), name);
-	if (!fence)
+	sync_file = sync_file_alloc(offsetof(struct sync_file, cbs[1]),
+				    name);
+	if (!sync_file)
 		return NULL;
 
-	fence->num_fences = 1;
-	atomic_set(&fence->status, 1);
+	sync_file->num_fences = 1;
+	atomic_set(&sync_file->status, 1);
 
-	fence->cbs[0].sync_pt = pt;
-	fence->cbs[0].fence = fence;
-	if (fence_add_callback(pt, &fence->cbs[0].cb, fence_check_cb_func))
-		atomic_dec(&fence->status);
+	sync_file->cbs[0].sync_pt = pt;
+	sync_file->cbs[0].sync_file = sync_file;
+	if (fence_add_callback(pt, &sync_file->cbs[0].cb, fence_check_cb_func))
+		atomic_dec(&sync_file->status);
 
-	sync_fence_debug_add(fence);
+	sync_file_debug_add(sync_file);
 
-	return fence;
+	return sync_file;
 }
-EXPORT_SYMBOL(sync_fence_create_dma);
+EXPORT_SYMBOL(sync_file_create_dma);
 
-struct sync_fence *sync_fence_create(const char *name, struct sync_pt *pt)
+struct sync_file *sync_file_create(const char *name, struct sync_pt *pt)
 {
-	return sync_fence_create_dma(name, &pt->base);
+	return sync_file_create_dma(name, &pt->base);
 }
-EXPORT_SYMBOL(sync_fence_create);
+EXPORT_SYMBOL(sync_file_create);
 
-struct sync_fence *sync_fence_fdget(int fd)
+struct sync_file *sync_file_fdget(int fd)
 {
 	struct file *file = fget(fd);
 
 	if (!file)
 		return NULL;
 
-	if (file->f_op != &sync_fence_fops)
+	if (file->f_op != &sync_file_fops)
 		goto err;
 
 	return file->private_data;
@@ -229,70 +230,71 @@ err:
 	fput(file);
 	return NULL;
 }
-EXPORT_SYMBOL(sync_fence_fdget);
+EXPORT_SYMBOL(sync_file_fdget);
 
-void sync_fence_put(struct sync_fence *fence)
+void sync_file_put(struct sync_file *sync_file)
 {
-	fput(fence->file);
+	fput(sync_file->file);
 }
-EXPORT_SYMBOL(sync_fence_put);
+EXPORT_SYMBOL(sync_file_put);
 
-void sync_fence_install(struct sync_fence *fence, int fd)
+void sync_file_install(struct sync_file *sync_file, int fd)
 {
-	fd_install(fd, fence->file);
+	fd_install(fd, sync_file->file);
 }
-EXPORT_SYMBOL(sync_fence_install);
+EXPORT_SYMBOL(sync_file_install);
 
-static void sync_fence_add_pt(struct sync_fence *fence,
-			      int *i, struct fence *pt)
+static void sync_file_add_pt(struct sync_file *sync_file, int *i,
+			     struct fence *pt)
 {
-	fence->cbs[*i].sync_pt = pt;
-	fence->cbs[*i].fence = fence;
+	sync_file->cbs[*i].sync_pt = pt;
+	sync_file->cbs[*i].sync_file = sync_file;
 
-	if (!fence_add_callback(pt, &fence->cbs[*i].cb, fence_check_cb_func)) {
+	if (!fence_add_callback(pt, &sync_file->cbs[*i].cb,
+				fence_check_cb_func)) {
 		fence_get(pt);
 		(*i)++;
 	}
 }
 
-struct sync_fence *sync_fence_merge(const char *name,
-				    struct sync_fence *a, struct sync_fence *b)
+struct sync_file *sync_file_merge(const char *name,
+				  struct sync_file *a, struct sync_file *b)
 {
 	int num_fences = a->num_fences + b->num_fences;
-	struct sync_fence *fence;
+	struct sync_file *sync_file;
 	int i, i_a, i_b;
-	unsigned long size = offsetof(struct sync_fence, cbs[num_fences]);
+	unsigned long size = offsetof(struct sync_file, cbs[num_fences]);
 
-	fence = sync_fence_alloc(size, name);
-	if (!fence)
+	sync_file = sync_file_alloc(size, name);
+	if (!sync_file)
 		return NULL;
 
-	atomic_set(&fence->status, num_fences);
+	atomic_set(&sync_file->status, num_fences);
 
 	/*
-	 * Assume sync_fence a and b are both ordered and have no
+	 * Assume sync_file a and b are both ordered and have no
 	 * duplicates with the same context.
 	 *
-	 * If a sync_fence can only be created with sync_fence_merge
-	 * and sync_fence_create, this is a reasonable assumption.
+	 * If a sync_file can only be created with sync_file_merge
+	 * and sync_file_create, this is a reasonable assumption.
 	 */
 	for (i = i_a = i_b = 0; i_a < a->num_fences && i_b < b->num_fences; ) {
 		struct fence *pt_a = a->cbs[i_a].sync_pt;
 		struct fence *pt_b = b->cbs[i_b].sync_pt;
 
 		if (pt_a->context < pt_b->context) {
-			sync_fence_add_pt(fence, &i, pt_a);
+			sync_file_add_pt(sync_file, &i, pt_a);
 
 			i_a++;
 		} else if (pt_a->context > pt_b->context) {
-			sync_fence_add_pt(fence, &i, pt_b);
+			sync_file_add_pt(sync_file, &i, pt_b);
 
 			i_b++;
 		} else {
 			if (pt_a->seqno - pt_b->seqno <= INT_MAX)
-				sync_fence_add_pt(fence, &i, pt_a);
+				sync_file_add_pt(sync_file, &i, pt_a);
 			else
-				sync_fence_add_pt(fence, &i, pt_b);
+				sync_file_add_pt(sync_file, &i, pt_b);
 
 			i_a++;
 			i_b++;
@@ -300,21 +302,21 @@ struct sync_fence *sync_fence_merge(const char *name,
 	}
 
 	for (; i_a < a->num_fences; i_a++)
-		sync_fence_add_pt(fence, &i, a->cbs[i_a].sync_pt);
+		sync_file_add_pt(sync_file, &i, a->cbs[i_a].sync_pt);
 
 	for (; i_b < b->num_fences; i_b++)
-		sync_fence_add_pt(fence, &i, b->cbs[i_b].sync_pt);
+		sync_file_add_pt(sync_file, &i, b->cbs[i_b].sync_pt);
 
 	if (num_fences > i)
-		atomic_sub(num_fences - i, &fence->status);
-	fence->num_fences = i;
+		atomic_sub(num_fences - i, &sync_file->status);
+	sync_file->num_fences = i;
 
-	sync_fence_debug_add(fence);
-	return fence;
+	sync_file_debug_add(sync_file);
+	return sync_file;
 }
-EXPORT_SYMBOL(sync_fence_merge);
+EXPORT_SYMBOL(sync_file_merge);
 
-int sync_fence_wait(struct sync_fence *fence, long timeout)
+int sync_file_wait(struct sync_file *sync_file, long timeout)
 {
 	long ret;
 	int i;
@@ -324,33 +326,33 @@ int sync_fence_wait(struct sync_fence *fence, long timeout)
 	else
 		timeout = msecs_to_jiffies(timeout);
 
-	trace_sync_wait(fence, 1);
-	for (i = 0; i < fence->num_fences; ++i)
-		trace_sync_pt(fence->cbs[i].sync_pt);
-	ret = wait_event_interruptible_timeout(fence->wq,
-					       atomic_read(&fence->status) <= 0,
+	trace_sync_wait(sync_file, 1);
+	for (i = 0; i < sync_file->num_fences; ++i)
+		trace_sync_pt(sync_file->cbs[i].sync_pt);
+	ret = wait_event_interruptible_timeout(sync_file->wq,
+					       atomic_read(&sync_file->status) <= 0,
 					       timeout);
-	trace_sync_wait(fence, 0);
+	trace_sync_wait(sync_file, 0);
 
 	if (ret < 0) {
 		return ret;
 	} else if (ret == 0) {
 		if (timeout) {
-			pr_info("fence timeout on [%p] after %dms\n", fence,
-				jiffies_to_msecs(timeout));
+			pr_info("sync_file timeout on [%p] after %dms\n",
+				sync_file, jiffies_to_msecs(timeout));
 			sync_dump();
 		}
 		return -ETIME;
 	}
 
-	ret = atomic_read(&fence->status);
+	ret = atomic_read(&sync_file->status);
 	if (ret) {
-		pr_info("fence error %ld on [%p]\n", ret, fence);
+		pr_info("sync_file error %ld on [%p]\n", ret, sync_file);
 		sync_dump();
 	}
 	return ret;
 }
-EXPORT_SYMBOL(sync_fence_wait);
+EXPORT_SYMBOL(sync_file_wait);
 
 static const char *android_fence_get_driver_name(struct fence *fence)
 {
@@ -459,37 +461,39 @@ static const struct fence_ops android_fence_ops = {
 	.timeline_value_str = android_fence_timeline_value_str,
 };
 
-static void sync_fence_free(struct kref *kref)
+static void sync_file_free(struct kref *kref)
 {
-	struct sync_fence *fence = container_of(kref, struct sync_fence, kref);
+	struct sync_file *sync_file = container_of(kref, struct sync_file,
+						     kref);
 	int i;
 
-	for (i = 0; i < fence->num_fences; ++i) {
-		fence_remove_callback(fence->cbs[i].sync_pt, &fence->cbs[i].cb);
-		fence_put(fence->cbs[i].sync_pt);
+	for (i = 0; i < sync_file->num_fences; ++i) {
+		fence_remove_callback(sync_file->cbs[i].sync_pt,
+				      &sync_file->cbs[i].cb);
+		fence_put(sync_file->cbs[i].sync_pt);
 	}
 
-	kfree(fence);
+	kfree(sync_file);
 }
 
-static int sync_fence_release(struct inode *inode, struct file *file)
+static int sync_file_release(struct inode *inode, struct file *file)
 {
-	struct sync_fence *fence = file->private_data;
+	struct sync_file *sync_file = file->private_data;
 
-	sync_fence_debug_remove(fence);
+	sync_file_debug_remove(sync_file);
 
-	kref_put(&fence->kref, sync_fence_free);
+	kref_put(&sync_file->kref, sync_file_free);
 	return 0;
 }
 
-static unsigned int sync_fence_poll(struct file *file, poll_table *wait)
+static unsigned int sync_file_poll(struct file *file, poll_table *wait)
 {
-	struct sync_fence *fence = file->private_data;
+	struct sync_file *sync_file = file->private_data;
 	int status;
 
-	poll_wait(file, &fence->wq, wait);
+	poll_wait(file, &sync_file->wq, wait);
 
-	status = atomic_read(&fence->status);
+	status = atomic_read(&sync_file->status);
 
 	if (!status)
 		return POLLIN;
@@ -498,21 +502,23 @@ static unsigned int sync_fence_poll(struct file *file, poll_table *wait)
 	return 0;
 }
 
-static long sync_fence_ioctl_wait(struct sync_fence *fence, unsigned long arg)
+static long sync_file_ioctl_wait(struct sync_file *sync_file,
+				  unsigned long arg)
 {
 	__s32 value;
 
 	if (copy_from_user(&value, (void __user *)arg, sizeof(value)))
 		return -EFAULT;
 
-	return sync_fence_wait(fence, value);
+	return sync_file_wait(sync_file, value);
 }
 
-static long sync_fence_ioctl_merge(struct sync_fence *fence, unsigned long arg)
+static long sync_file_ioctl_merge(struct sync_file *sync_file,
+				   unsigned long arg)
 {
 	int fd = get_unused_fd_flags(O_CLOEXEC);
 	int err;
-	struct sync_fence *fence2, *fence3;
+	struct sync_file *fence2, *fence3;
 	struct sync_merge_data data;
 
 	if (fd < 0)
@@ -523,14 +529,14 @@ static long sync_fence_ioctl_merge(struct sync_fence *fence, unsigned long arg)
 		goto err_put_fd;
 	}
 
-	fence2 = sync_fence_fdget(data.fd2);
+	fence2 = sync_file_fdget(data.fd2);
 	if (!fence2) {
 		err = -ENOENT;
 		goto err_put_fd;
 	}
 
 	data.name[sizeof(data.name) - 1] = '\0';
-	fence3 = sync_fence_merge(data.name, fence, fence2);
+	fence3 = sync_file_merge(data.name, sync_file, fence2);
 	if (!fence3) {
 		err = -ENOMEM;
 		goto err_put_fence2;
@@ -542,15 +548,15 @@ static long sync_fence_ioctl_merge(struct sync_fence *fence, unsigned long arg)
 		goto err_put_fence3;
 	}
 
-	sync_fence_install(fence3, fd);
-	sync_fence_put(fence2);
+	sync_file_install(fence3, fd);
+	sync_file_put(fence2);
 	return 0;
 
 err_put_fence3:
-	sync_fence_put(fence3);
+	sync_file_put(fence3);
 
 err_put_fence2:
-	sync_fence_put(fence2);
+	sync_file_put(fence2);
 
 err_put_fd:
 	put_unused_fd(fd);
@@ -589,10 +595,10 @@ static int sync_fill_pt_info(struct fence *fence, void *data, int size)
 	return info->len;
 }
 
-static long sync_fence_ioctl_fence_info(struct sync_fence *fence,
+static long sync_file_ioctl_fence_info(struct sync_file *sync_file,
 					unsigned long arg)
 {
-	struct sync_fence_info_data *data;
+	struct sync_file_info_data *data;
 	__u32 size;
 	__u32 len = 0;
 	int ret, i;
@@ -600,7 +606,7 @@ static long sync_fence_ioctl_fence_info(struct sync_fence *fence,
 	if (copy_from_user(&size, (void __user *)arg, sizeof(size)))
 		return -EFAULT;
 
-	if (size < sizeof(struct sync_fence_info_data))
+	if (size < sizeof(struct sync_file_info_data))
 		return -EINVAL;
 
 	if (size > 4096)
@@ -610,15 +616,15 @@ static long sync_fence_ioctl_fence_info(struct sync_fence *fence,
 	if (!data)
 		return -ENOMEM;
 
-	strlcpy(data->name, fence->name, sizeof(data->name));
-	data->status = atomic_read(&fence->status);
+	strlcpy(data->name, sync_file->name, sizeof(data->name));
+	data->status = atomic_read(&sync_file->status);
 	if (data->status >= 0)
 		data->status = !data->status;
 
-	len = sizeof(struct sync_fence_info_data);
+	len = sizeof(struct sync_file_info_data);
 
-	for (i = 0; i < fence->num_fences; ++i) {
-		struct fence *pt = fence->cbs[i].sync_pt;
+	for (i = 0; i < sync_file->num_fences; ++i) {
+		struct fence *pt = sync_file->cbs[i].sync_pt;
 
 		ret = sync_fill_pt_info(pt, (u8 *)data + len, size - len);
 
@@ -641,30 +647,30 @@ out:
 	return ret;
 }
 
-static long sync_fence_ioctl(struct file *file, unsigned int cmd,
+static long sync_file_ioctl(struct file *file, unsigned int cmd,
 			     unsigned long arg)
 {
-	struct sync_fence *fence = file->private_data;
+	struct sync_file *sync_file = file->private_data;
 
 	switch (cmd) {
 	case SYNC_IOC_WAIT:
-		return sync_fence_ioctl_wait(fence, arg);
+		return sync_file_ioctl_wait(sync_file, arg);
 
 	case SYNC_IOC_MERGE:
-		return sync_fence_ioctl_merge(fence, arg);
+		return sync_file_ioctl_merge(sync_file, arg);
 
 	case SYNC_IOC_FENCE_INFO:
-		return sync_fence_ioctl_fence_info(fence, arg);
+		return sync_file_ioctl_fence_info(sync_file, arg);
 
 	default:
 		return -ENOTTY;
 	}
 }
 
-static const struct file_operations sync_fence_fops = {
-	.release = sync_fence_release,
-	.poll = sync_fence_poll,
-	.unlocked_ioctl = sync_fence_ioctl,
-	.compat_ioctl = sync_fence_ioctl,
+static const struct file_operations sync_file_fops = {
+	.release = sync_file_release,
+	.poll = sync_file_poll,
+	.unlocked_ioctl = sync_file_ioctl,
+	.compat_ioctl = sync_file_ioctl,
 };
 
diff --git a/drivers/staging/android/sync.h b/drivers/staging/android/sync.h
index b47058fbe8af..bec62c37ec7c 100644
--- a/drivers/staging/android/sync.h
+++ b/drivers/staging/android/sync.h
@@ -25,7 +25,7 @@
 
 struct sync_timeline;
 struct sync_pt;
-struct sync_fence;
+struct sync_file;
 
 /**
  * struct sync_timeline_ops - sync object implementation ops
@@ -108,36 +108,36 @@ static inline struct sync_timeline *sync_pt_parent(struct sync_pt *pt)
 			    child_list_lock);
 }
 
-struct sync_fence_cb {
+struct sync_file_cb {
 	struct fence_cb cb;
 	struct fence *sync_pt;
-	struct sync_fence *fence;
+	struct sync_file *sync_file;
 };
 
 /**
- * struct sync_fence - sync fence
+ * struct sync_file - sync file to export to the userspace
  * @file:		file representing this fence
  * @kref:		reference count on fence.
- * @name:		name of sync_fence.  Useful for debugging
- * @sync_fence_list:	membership in global fence list
+ * @name:		name of sync_file.  Useful for debugging
+ * @sync_file_list:	membership in global file list
  * @num_fences		number of sync_pts in the fence
  * @wq:			wait queue for fence signaling
  * @status:		0: signaled, >0:active, <0: error
  * @cbs:		sync_pts callback information
  */
-struct sync_fence {
+struct sync_file {
 	struct file		*file;
 	struct kref		kref;
 	char			name[32];
 #ifdef CONFIG_DEBUG_FS
-	struct list_head	sync_fence_list;
+	struct list_head	sync_file_list;
 #endif
 	int num_fences;
 
 	wait_queue_head_t	wq;
 	atomic_t		status;
 
-	struct sync_fence_cb	cbs[];
+	struct sync_file_cb	cbs[];
 };
 
 /*
@@ -199,95 +199,95 @@ struct sync_pt *sync_pt_create(struct sync_timeline *parent, int size);
 void sync_pt_free(struct sync_pt *pt);
 
 /**
- * sync_fence_create() - creates a sync fence
- * @name:	name of fence to create
- * @pt:		sync_pt to add to the fence
+ * sync_file_create() - creates a sync file
+ * @name:	name of file to create
+ * @pt:		sync_pt to add to the file
  *
- * Creates a fence containg @pt.  Once this is called, the fence takes
+ * Creates a sync_file containg @pt. Once this is called, the sync_file takes
  * ownership of @pt.
  */
-struct sync_fence *sync_fence_create(const char *name, struct sync_pt *pt);
+struct sync_file *sync_file_create(const char *name, struct sync_pt *pt);
 
 /**
- * sync_fence_create_dma() - creates a sync fence from dma-fence
- * @name:	name of fence to create
- * @pt:	dma-fence to add to the fence
+ * sync_file_create_dma() - creates a sync file from dma-fence
+ * @name:	name of file to create
+ * @pt:	dma-fence to add to the file
  *
- * Creates a fence containg @pt.  Once this is called, the fence takes
+ * Creates a sync_file containg @pt.  Once this is called, the fence takes
  * ownership of @pt.
  */
-struct sync_fence *sync_fence_create_dma(const char *name, struct fence *pt);
+struct sync_file *sync_file_create_dma(const char *name, struct fence *pt);
 
 /*
- * API for sync_fence consumers
+ * API for sync_file consumers
  */
 
 /**
- * sync_fence_merge() - merge two fences
+ * sync_file_merge() - merge two sync_files
  * @name:	name of new fence
- * @a:		fence a
- * @b:		fence b
+ * @a:		sync_file a
+ * @b:		sync_file b
  *
- * Creates a new fence which contains copies of all the sync_pts in both
- * @a and @b.  @a and @b remain valid, independent fences. Returns the
- * new merged fence or NULL in case of error.
+ * Creates a new sync_file which contains copies of all the sync_pts in both
+ * @a and @b.  @a and @b remain valid, independent sync_file. Returns the
+ * new merged sync_file or NULL in case of error.
  */
-struct sync_fence *sync_fence_merge(const char *name,
-				    struct sync_fence *a, struct sync_fence *b);
+struct sync_file *sync_file_merge(const char *name,
+				    struct sync_file *a, struct sync_file *b);
 
 /**
- * sync_fence_fdget() - get a fence from an fd
+ * sync_file_fdget() - get a sync_file from an fd
  * @fd:		fd referencing a fence
  *
- * Ensures @fd references a valid fence, increments the refcount of the backing
- * file, and returns the fence. Returns the fence or NULL in case of error.
+ * Ensures @fd references a valid sync_file, increments the refcount of the
+ * backing file. Returns the sync_file or NULL in case of error.
  */
-struct sync_fence *sync_fence_fdget(int fd);
+struct sync_file *sync_file_fdget(int fd);
 
 /**
- * sync_fence_put() - puts a reference of a sync fence
- * @fence:	fence to put
+ * sync_file_put() - puts a reference of a sync_file
+ * @sync_file:	sync_file to put
  *
- * Puts a reference on @fence.  If this is the last reference, the fence and
- * all it's sync_pts will be freed
+ * Puts a reference on @sync_fence.  If this is the last reference, the
+ * sync_fil and all it's sync_pts will be freed
  */
-void sync_fence_put(struct sync_fence *fence);
+void sync_file_put(struct sync_file *sync_file);
 
 /**
- * sync_fence_install() - installs a fence into a file descriptor
- * @fence:	fence to install
+ * sync_file_install() - installs a sync_file into a file descriptor
+ * @sync_file:	sync_file to install
  * @fd:		file descriptor in which to install the fence
  *
- * Installs @fence into @fd.  @fd's should be acquired through
+ * Installs @sync_file into @fd.  @fd's should be acquired through
  * get_unused_fd_flags(O_CLOEXEC).
  */
-void sync_fence_install(struct sync_fence *fence, int fd);
+void sync_file_install(struct sync_file *sync_file, int fd);
 
 /**
- * sync_fence_wait() - wait on fence
- * @fence:	fence to wait on
+ * sync_file_wait() - wait on sync file
+ * @sync_file:	file to wait on
  * @tiemout:	timeout in ms
  *
- * Wait for @fence to be signaled or have an error.  Waits indefinitely
+ * Wait for @sync_file to be signaled or have an error. Waits indefinitely
  * if @timeout < 0.
  *
  * Returns 0 if fence signaled, > 0 if it is still active and <0 on error
  */
-int sync_fence_wait(struct sync_fence *fence, long timeout);
+int sync_file_wait(struct sync_file *sync_file, long timeout);
 
 #ifdef CONFIG_DEBUG_FS
 
 void sync_timeline_debug_add(struct sync_timeline *obj);
 void sync_timeline_debug_remove(struct sync_timeline *obj);
-void sync_fence_debug_add(struct sync_fence *fence);
-void sync_fence_debug_remove(struct sync_fence *fence);
+void sync_file_debug_add(struct sync_file *fence);
+void sync_file_debug_remove(struct sync_file *fence);
 void sync_dump(void);
 
 #else
 # define sync_timeline_debug_add(obj)
 # define sync_timeline_debug_remove(obj)
-# define sync_fence_debug_add(fence)
-# define sync_fence_debug_remove(fence)
+# define sync_file_debug_add(fence)
+# define sync_file_debug_remove(fence)
 # define sync_dump()
 #endif
 
diff --git a/drivers/staging/android/sync_debug.c b/drivers/staging/android/sync_debug.c
index 33dec4219e99..f1880240973d 100644
--- a/drivers/staging/android/sync_debug.c
+++ b/drivers/staging/android/sync_debug.c
@@ -35,8 +35,8 @@ static struct dentry *dbgfs;
 
 static LIST_HEAD(sync_timeline_list_head);
 static DEFINE_SPINLOCK(sync_timeline_list_lock);
-static LIST_HEAD(sync_fence_list_head);
-static DEFINE_SPINLOCK(sync_fence_list_lock);
+static LIST_HEAD(sync_file_list_head);
+static DEFINE_SPINLOCK(sync_file_list_lock);
 
 void sync_timeline_debug_add(struct sync_timeline *obj)
 {
@@ -56,22 +56,22 @@ void sync_timeline_debug_remove(struct sync_timeline *obj)
 	spin_unlock_irqrestore(&sync_timeline_list_lock, flags);
 }
 
-void sync_fence_debug_add(struct sync_fence *fence)
+void sync_file_debug_add(struct sync_file *sync_file)
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&sync_fence_list_lock, flags);
-	list_add_tail(&fence->sync_fence_list, &sync_fence_list_head);
-	spin_unlock_irqrestore(&sync_fence_list_lock, flags);
+	spin_lock_irqsave(&sync_file_list_lock, flags);
+	list_add_tail(&sync_file->sync_file_list, &sync_file_list_head);
+	spin_unlock_irqrestore(&sync_file_list_lock, flags);
 }
 
-void sync_fence_debug_remove(struct sync_fence *fence)
+void sync_file_debug_remove(struct sync_file *sync_file)
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&sync_fence_list_lock, flags);
-	list_del(&fence->sync_fence_list);
-	spin_unlock_irqrestore(&sync_fence_list_lock, flags);
+	spin_lock_irqsave(&sync_file_list_lock, flags);
+	list_del(&sync_file->sync_file_list);
+	spin_unlock_irqrestore(&sync_file_list_lock, flags);
 }
 
 static const char *sync_status_str(int status)
@@ -152,17 +152,18 @@ static void sync_print_obj(struct seq_file *s, struct sync_timeline *obj)
 	spin_unlock_irqrestore(&obj->child_list_lock, flags);
 }
 
-static void sync_print_fence(struct seq_file *s, struct sync_fence *fence)
-{
+static void sync_print_sync_file(struct seq_file *s,
+				  struct sync_file *sync_file)
+ {
 	int i;
 
-	seq_printf(s, "[%p] %s: %s\n", fence, fence->name,
-		   sync_status_str(atomic_read(&fence->status)));
-
-	for (i = 0; i < fence->num_fences; ++i)
-		sync_print_pt(s, fence->cbs[i].sync_pt, true);
-}
+	seq_printf(s, "[%p] %s: %s\n", sync_file, sync_file->name,
+		   sync_status_str(atomic_read(&sync_file->status)));
 
+	for (i = 0; i < sync_file->num_fences; ++i)
+		sync_print_pt(s, sync_file->cbs[i].sync_pt, true);
+ }
+ 
 static int sync_debugfs_show(struct seq_file *s, void *unused)
 {
 	unsigned long flags;
@@ -183,15 +184,15 @@ static int sync_debugfs_show(struct seq_file *s, void *unused)
 
 	seq_puts(s, "fences:\n--------------\n");
 
-	spin_lock_irqsave(&sync_fence_list_lock, flags);
-	list_for_each(pos, &sync_fence_list_head) {
-		struct sync_fence *fence =
-			container_of(pos, struct sync_fence, sync_fence_list);
+	spin_lock_irqsave(&sync_file_list_lock, flags);
+	list_for_each(pos, &sync_file_list_head) {
+		struct sync_file *sync_file =
+			container_of(pos, struct sync_file, sync_file_list);
 
-		sync_print_fence(s, fence);
+		sync_print_sync_file(s, sync_file);
 		seq_puts(s, "\n");
 	}
-	spin_unlock_irqrestore(&sync_fence_list_lock, flags);
+	spin_unlock_irqrestore(&sync_file_list_lock, flags);
 	return 0;
 }
 
@@ -244,7 +245,7 @@ static long sw_sync_ioctl_create_fence(struct sw_sync_timeline *obj,
 	int fd = get_unused_fd_flags(O_CLOEXEC);
 	int err;
 	struct sync_pt *pt;
-	struct sync_fence *fence;
+	struct sync_file *sync_file;
 	struct sw_sync_create_fence_data data;
 
 	if (fd < 0)
@@ -262,8 +263,8 @@ static long sw_sync_ioctl_create_fence(struct sw_sync_timeline *obj,
 	}
 
 	data.name[sizeof(data.name) - 1] = '\0';
-	fence = sync_fence_create(data.name, pt);
-	if (!fence) {
+	sync_file = sync_file_create(data.name, pt);
+	if (!sync_file) {
 		sync_pt_free(pt);
 		err = -ENOMEM;
 		goto err;
@@ -271,12 +272,12 @@ static long sw_sync_ioctl_create_fence(struct sw_sync_timeline *obj,
 
 	data.fence = fd;
 	if (copy_to_user((void __user *)arg, &data, sizeof(data))) {
-		sync_fence_put(fence);
+		sync_file_put(sync_file);
 		err = -EFAULT;
 		goto err;
 	}
 
-	sync_fence_install(fence, fd);
+	sync_file_install(sync_file, fd);
 
 	return 0;
 
diff --git a/drivers/staging/android/trace/sync.h b/drivers/staging/android/trace/sync.h
index 77edb977a7bf..80f5da4f2aa5 100644
--- a/drivers/staging/android/trace/sync.h
+++ b/drivers/staging/android/trace/sync.h
@@ -33,19 +33,19 @@ TRACE_EVENT(sync_timeline,
 );
 
 TRACE_EVENT(sync_wait,
-	TP_PROTO(struct sync_fence *fence, int begin),
+	TP_PROTO(struct sync_file *sync_file, int begin),
 
-	TP_ARGS(fence, begin),
+	TP_ARGS(sync_file, begin),
 
 	TP_STRUCT__entry(
-			__string(name, fence->name)
+			__string(name, sync_file->name)
 			__field(s32, status)
 			__field(u32, begin)
 	),
 
 	TP_fast_assign(
-			__assign_str(name, fence->name);
-			__entry->status = atomic_read(&fence->status);
+			__assign_str(name, sync_file->name);
+			__entry->status = atomic_read(&sync_file->status);
 			__entry->begin = begin;
 	),
 
diff --git a/drivers/staging/android/uapi/sync.h b/drivers/staging/android/uapi/sync.h
index e964c751f6b8..73deb6907ce1 100644
--- a/drivers/staging/android/uapi/sync.h
+++ b/drivers/staging/android/uapi/sync.h
@@ -46,15 +46,15 @@ struct sync_pt_info {
 };
 
 /**
- * struct sync_fence_info_data - data returned from fence info ioctl
+ * struct sync_file_info_data - data returned from fence info ioctl
  * @len:	ioctl caller writes the size of the buffer its passing in.
- *		ioctl returns length of sync_fence_data returned to userspace
- *		including pt_info.
+ *		ioctl returns length of sync_file_info_data returned to
+ *		userspace including pt_info.
  * @name:	name of fence
  * @status:	status of fence. 1: signaled 0:active <0:error
  * @pt_info:	a sync_pt_info struct for every sync_pt in the fence
  */
-struct sync_fence_info_data {
+struct sync_file_info_data {
 	__u32	len;
 	char	name[32];
 	__s32	status;
@@ -83,15 +83,15 @@ struct sync_fence_info_data {
 /**
  * DOC: SYNC_IOC_FENCE_INFO - get detailed information on a fence
  *
- * Takes a struct sync_fence_info_data with extra space allocated for pt_info.
+ * Takes a struct sync_file_info_data with extra space allocated for pt_info.
  * Caller should write the size of the buffer into len.  On return, len is
- * updated to reflect the total size of the sync_fence_info_data including
+ * updated to reflect the total size of the sync_file_info_data including
  * pt_info.
  *
  * pt_info is a buffer containing sync_pt_infos for every sync_pt in the fence.
  * To iterate over the sync_pt_infos, use the sync_pt_info.len field.
  */
 #define SYNC_IOC_FENCE_INFO	_IOWR(SYNC_IOC_MAGIC, 2,\
-	struct sync_fence_info_data)
+	struct sync_file_info_data)
 
 #endif /* _UAPI_LINUX_SYNC_H */
-- 
2.12.0
