From: Andrew Rybchenko <Andrew.Rybchenko@oktetlabs.ru>
Date: Wed, 15 Jun 2016 17:45:56 +0100
Subject: sfc: Store unicast and multicast promisc flag with address cache
Patch-mainline: v4.8-rc1
Git-commit: afa4ce125516cc29a8897952d7824a742bd8b4b9
References: bsc#1017967 FATE#321663

These flags are built when address cache is updated.
The information will be required when VLAN filtering is added and address
cache is used without re-sync.

Signed-off-by: Edward Cree <ecree@solarflare.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: David Chang <dchang@suse.com>
---
 drivers/net/ethernet/sfc/ef10.c |   30 +++++++++++++++---------------
 1 file changed, 15 insertions(+), 15 deletions(-)

--- a/drivers/net/ethernet/sfc/ef10.c
+++ b/drivers/net/ethernet/sfc/ef10.c
@@ -89,6 +89,8 @@ struct efx_ef10_filter_table {
 	struct efx_ef10_dev_addr dev_mc_list[EFX_EF10_FILTER_DEV_MC_MAX];
 	int dev_uc_count;
 	int dev_mc_count;
+	bool uc_promisc;
+	bool mc_promisc;
 /* Whether in multicast promiscuous mode when last changed */
 	bool mc_promisc_last;
 	struct efx_ef10_filter_vlan vlan;
@@ -3960,7 +3962,7 @@ static void efx_ef10_filter_mark_old(str
 	spin_unlock_bh(&efx->filter_lock);
 }
 
-static void efx_ef10_filter_uc_addr_list(struct efx_nic *efx, bool *promisc)
+static void efx_ef10_filter_uc_addr_list(struct efx_nic *efx)
 {
 	struct efx_ef10_filter_table *table = efx->filter_state;
 	struct net_device *net_dev = efx->net_dev;
@@ -3969,14 +3971,13 @@ static void efx_ef10_filter_uc_addr_list
 	unsigned int i;
 
 	addr_count = netdev_uc_count(net_dev);
-	if (net_dev->flags & IFF_PROMISC)
-		*promisc = true;
+	table->uc_promisc = !!(net_dev->flags & IFF_PROMISC);
 	table->dev_uc_count = 1 + addr_count;
 	ether_addr_copy(table->dev_uc_list[0].addr, net_dev->dev_addr);
 	i = 1;
 	netdev_for_each_uc_addr(uc, net_dev) {
 		if (i >= EFX_EF10_FILTER_DEV_UC_MAX) {
-			*promisc = true;
+			table->uc_promisc = true;
 			break;
 		}
 		ether_addr_copy(table->dev_uc_list[i].addr, uc->addr);
@@ -3984,21 +3985,20 @@ static void efx_ef10_filter_uc_addr_list
 	}
 }
 
-static void efx_ef10_filter_mc_addr_list(struct efx_nic *efx, bool *promisc)
+static void efx_ef10_filter_mc_addr_list(struct efx_nic *efx)
 {
 	struct efx_ef10_filter_table *table = efx->filter_state;
 	struct net_device *net_dev = efx->net_dev;
 	struct netdev_hw_addr *mc;
 	unsigned int i, addr_count;
 
-	if (net_dev->flags & (IFF_PROMISC | IFF_ALLMULTI))
-		*promisc = true;
+	table->mc_promisc = !!(net_dev->flags & (IFF_PROMISC | IFF_ALLMULTI));
 
 	addr_count = netdev_mc_count(net_dev);
 	i = 0;
 	netdev_for_each_mc_addr(mc, net_dev) {
 		if (i >= EFX_EF10_FILTER_DEV_MC_MAX) {
-			*promisc = true;
+			table->mc_promisc = true;
 			break;
 		}
 		ether_addr_copy(table->dev_mc_list[i].addr, mc->addr);
@@ -4264,7 +4264,6 @@ static void efx_ef10_filter_sync_rx_mode
 	struct efx_ef10_filter_table *table = efx->filter_state;
 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
 	struct net_device *net_dev = efx->net_dev;
-	bool uc_promisc = false, mc_promisc = false;
 
 	if (!efx_dev_registered(efx))
 		return;
@@ -4278,12 +4277,12 @@ static void efx_ef10_filter_sync_rx_mode
 	 * address and broadcast address
 	 */
 	netif_addr_lock_bh(net_dev);
-	efx_ef10_filter_uc_addr_list(efx, &uc_promisc);
-	efx_ef10_filter_mc_addr_list(efx, &mc_promisc);
+	efx_ef10_filter_uc_addr_list(efx);
+	efx_ef10_filter_mc_addr_list(efx);
 	netif_addr_unlock_bh(net_dev);
 
 	/* Insert/renew unicast filters */
-	if (uc_promisc) {
+	if (table->uc_promisc) {
 		efx_ef10_filter_insert_def(efx, false, false);
 		efx_ef10_filter_insert_addr_list(efx, false, false);
 	} else {
@@ -4299,9 +4298,10 @@ static void efx_ef10_filter_sync_rx_mode
 	/* If changing promiscuous state with cascaded multicast filters, remove
 	 * old filters first, so that packets are dropped rather than duplicated
 	 */
-	if (nic_data->workaround_26807 && table->mc_promisc_last != mc_promisc)
+	if (nic_data->workaround_26807 &&
+	    table->mc_promisc_last != table->mc_promisc)
 		efx_ef10_filter_remove_old(efx);
-	if (mc_promisc) {
+	if (table->mc_promisc) {
 		if (nic_data->workaround_26807) {
 			/* If we failed to insert promiscuous filters, rollback
 			 * and fall back to individual multicast filters
@@ -4334,7 +4334,7 @@ static void efx_ef10_filter_sync_rx_mode
 	}
 
 	efx_ef10_filter_remove_old(efx);
-	table->mc_promisc_last = mc_promisc;
+	table->mc_promisc_last = table->mc_promisc;
 }
 
 static int efx_ef10_set_mac_address(struct efx_nic *efx)
