From bf69fcaad9e30a2a99256206cf3e1bba606e1f19 Mon Sep 17 00:00:00 2001
From: Christophe Ricard <christophe.ricard@gmail.com>
Date: Thu, 19 May 2016 00:35:48 +0200
Subject: [PATCH] tpm: tpm_tis: Share common data between phys

References: bsc#1020645, fate#321435, fate#321507, fate#321600
Patch-mainline: v4.8-rc1
Git-commit: 57dacc2b4ce5350db3046721dad3d88c3b451aa2

Split priv_data structure in common and phy specific structures. This will
allow in future patches to reuse the same tis logic on top of new phy such
as spi and i2c. Ultimately, other drivers may reuse this tis logic.
(e.g: st33zp24...)

iobase field is specific to TPM addressed on 0xFED4xxxx on LPC/SPI bus.

This commit is based on the initial work by Peter Huewe.

Signed-off-by: Christophe Ricard <christophe-h.ricard@st.com>
Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
Tested-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
Tested-by: Stefan Berger <stefanb@linux.vnet.ibm.com>
Reviewed-by: Stefan Berger <stefanb@linux.vnet.ibm.com>
Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
Acked-by: Michal Suchanek <msuchanek@suse.de>
---
 drivers/char/tpm/tpm_tis.c      |  171 ++++++++++++++++++++++------------------
 drivers/char/tpm/tpm_tis_core.h |   37 ++++++++
 2 files changed, 132 insertions(+), 76 deletions(-)
 create mode 100644 drivers/char/tpm/tpm_tis_core.h

--- a/drivers/char/tpm/tpm_tis.c
+++ b/drivers/char/tpm/tpm_tis.c
@@ -29,6 +29,7 @@
 #include <linux/acpi.h>
 #include <linux/freezer.h>
 #include "tpm.h"
+#include "tpm_tis_core.h"
 
 enum tis_access {
 	TPM_ACCESS_VALID = 0x80,
@@ -93,16 +94,16 @@ struct tpm_info {
 #define	TPM_DID_VID(l)			(0x0F00 | ((l) << 12))
 #define	TPM_RID(l)			(0x0F04 | ((l) << 12))
 
-struct priv_data {
+struct tpm_tis_tcg_phy {
+	struct tpm_tis_data priv;
 	void __iomem *iobase;
-	u16 manufacturer_id;
-	int locality;
-	int irq;
-	bool irq_tested;
-	wait_queue_head_t int_queue;
-	wait_queue_head_t read_queue;
 };
 
+static inline struct tpm_tis_tcg_phy *to_tpm_tis_tcg_phy(struct tpm_tis_data *data)
+{
+	return container_of(data, struct tpm_tis_tcg_phy, priv);
+}
+
 #if defined(CONFIG_PNP) && defined(CONFIG_ACPI)
 static int has_hid(struct acpi_device *dev, const char *hid)
 {
@@ -132,10 +133,11 @@ static inline int is_itpm(struct acpi_de
  * correct values in the other bits.' */
 static int wait_startup(struct tpm_chip *chip, int l)
 {
-	struct priv_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(priv);
 	unsigned long stop = jiffies + chip->timeout_a;
 	do {
-		if (ioread8(priv->iobase + TPM_ACCESS(l)) &
+		if (ioread8(phy->iobase + TPM_ACCESS(l)) &
 		    TPM_ACCESS_VALID)
 			return 0;
 		msleep(TPM_TIMEOUT);
@@ -145,9 +147,10 @@ static int wait_startup(struct tpm_chip
 
 static int check_locality(struct tpm_chip *chip, int l)
 {
-	struct priv_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(priv);
 
-	if ((ioread8(priv->iobase + TPM_ACCESS(l)) &
+	if ((ioread8(phy->iobase + TPM_ACCESS(l)) &
 	     (TPM_ACCESS_ACTIVE_LOCALITY | TPM_ACCESS_VALID)) ==
 	    (TPM_ACCESS_ACTIVE_LOCALITY | TPM_ACCESS_VALID))
 		return priv->locality = l;
@@ -157,18 +160,20 @@ static int check_locality(struct tpm_chi
 
 static void release_locality(struct tpm_chip *chip, int l, int force)
 {
-	struct priv_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(priv);
 
-	if (force || (ioread8(priv->iobase + TPM_ACCESS(l)) &
+	if (force || (ioread8(phy->iobase + TPM_ACCESS(l)) &
 		      (TPM_ACCESS_REQUEST_PENDING | TPM_ACCESS_VALID)) ==
 	    (TPM_ACCESS_REQUEST_PENDING | TPM_ACCESS_VALID))
 		iowrite8(TPM_ACCESS_ACTIVE_LOCALITY,
-			 priv->iobase + TPM_ACCESS(l));
+			 phy->iobase + TPM_ACCESS(l));
 }
 
 static int request_locality(struct tpm_chip *chip, int l)
 {
-	struct priv_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(priv);
 	unsigned long stop, timeout;
 	long rc;
 
@@ -176,7 +181,7 @@ static int request_locality(struct tpm_c
 		return l;
 
 	iowrite8(TPM_ACCESS_REQUEST_USE,
-		 priv->iobase + TPM_ACCESS(l));
+		 phy->iobase + TPM_ACCESS(l));
 
 	stop = jiffies + chip->timeout_a;
 
@@ -209,24 +214,27 @@ again:
 
 static u8 tpm_tis_status(struct tpm_chip *chip)
 {
-	struct priv_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(priv);
 
-	return ioread8(priv->iobase +
+	return ioread8(phy->iobase +
 		       TPM_STS(priv->locality));
 }
 
 static void tpm_tis_ready(struct tpm_chip *chip)
 {
-	struct priv_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(priv);
 
 	/* this causes the current command to be aborted */
 	iowrite8(TPM_STS_COMMAND_READY,
-		 priv->iobase + TPM_STS(priv->locality));
+		 phy->iobase + TPM_STS(priv->locality));
 }
 
 static int get_burstcount(struct tpm_chip *chip)
 {
-	struct priv_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(priv);
 	unsigned long stop;
 	int burstcnt;
 
@@ -234,9 +242,9 @@ static int get_burstcount(struct tpm_chi
 	/* which timeout value, spec has 2 answers (c & d) */
 	stop = jiffies + chip->timeout_d;
 	do {
-		burstcnt = ioread8(priv->iobase +
+		burstcnt = ioread8(phy->iobase +
 				   TPM_STS(priv->locality) + 1);
-		burstcnt += ioread8(priv->iobase +
+		burstcnt += ioread8(phy->iobase +
 				    TPM_STS(priv->locality) +
 				    2) << 8;
 		if (burstcnt)
@@ -248,7 +256,8 @@ static int get_burstcount(struct tpm_chi
 
 static int recv_data(struct tpm_chip *chip, u8 *buf, size_t count)
 {
-	struct priv_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(priv);
 	int size = 0, burstcnt;
 	while (size < count &&
 	       wait_for_tpm_stat(chip,
@@ -258,7 +267,7 @@ static int recv_data(struct tpm_chip *ch
 	       == 0) {
 		burstcnt = get_burstcount(chip);
 		for (; burstcnt > 0 && size < count; burstcnt--)
-			buf[size++] = ioread8(priv->iobase +
+			buf[size++] = ioread8(phy->iobase +
 					      TPM_DATA_FIFO(priv->locality));
 	}
 	return size;
@@ -266,7 +275,7 @@ static int recv_data(struct tpm_chip *ch
 
 static int tpm_tis_recv(struct tpm_chip *chip, u8 *buf, size_t count)
 {
-	struct priv_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
 	int size = 0;
 	int status;
 	u32 expected;
@@ -323,7 +332,8 @@ MODULE_PARM_DESC(itpm, "Force iTPM worka
  */
 static int tpm_tis_send_data(struct tpm_chip *chip, u8 *buf, size_t len)
 {
-	struct priv_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(priv);
 	int rc, status, burstcnt;
 	size_t count = 0;
 
@@ -344,7 +354,7 @@ static int tpm_tis_send_data(struct tpm_
 	while (count < len - 1) {
 		burstcnt = get_burstcount(chip);
 		for (; burstcnt > 0 && count < len - 1; burstcnt--) {
-			iowrite8(buf[count], priv->iobase +
+			iowrite8(buf[count], phy->iobase +
 				 TPM_DATA_FIFO(priv->locality));
 			count++;
 		}
@@ -360,7 +370,7 @@ static int tpm_tis_send_data(struct tpm_
 
 	/* write last byte */
 	iowrite8(buf[count],
-		 priv->iobase + TPM_DATA_FIFO(priv->locality));
+		 phy->iobase + TPM_DATA_FIFO(priv->locality));
 	wait_for_tpm_stat(chip, TPM_STS_VALID, chip->timeout_c,
 			  &priv->int_queue, false);
 	status = tpm_tis_status(chip);
@@ -379,15 +389,16 @@ out_err:
 
 static void disable_interrupts(struct tpm_chip *chip)
 {
-	struct priv_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(priv);
 	u32 intmask;
 
 	intmask =
-	    ioread32(priv->iobase +
+	    ioread32(phy->iobase +
 		     TPM_INT_ENABLE(priv->locality));
 	intmask &= ~TPM_GLOBAL_INT_ENABLE;
 	iowrite32(intmask,
-		  priv->iobase + TPM_INT_ENABLE(priv->locality));
+		  phy->iobase + TPM_INT_ENABLE(priv->locality));
 	devm_free_irq(chip->dev.parent, priv->irq, chip);
 	priv->irq = 0;
 	chip->flags &= ~TPM_CHIP_FLAG_IRQ;
@@ -400,7 +411,8 @@ static void disable_interrupts(struct tp
  */
 static int tpm_tis_send_main(struct tpm_chip *chip, u8 *buf, size_t len)
 {
-	struct priv_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(priv);
 	int rc;
 	u32 ordinal;
 	unsigned long dur;
@@ -411,7 +423,7 @@ static int tpm_tis_send_main(struct tpm_
 
 	/* go and do it */
 	iowrite8(TPM_STS_GO,
-		 priv->iobase + TPM_STS(priv->locality));
+		 phy->iobase + TPM_STS(priv->locality));
 
 	if (chip->flags & TPM_CHIP_FLAG_IRQ) {
 		ordinal = be32_to_cpu(*((__be32 *) (buf + 6)));
@@ -437,8 +449,8 @@ out_err:
 
 static int tpm_tis_send(struct tpm_chip *chip, u8 *buf, size_t len)
 {
+	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
 	int rc, irq;
-	struct priv_data *priv = dev_get_drvdata(&chip->dev);
 
 	if (!(chip->flags & TPM_CHIP_FLAG_IRQ) || priv->irq_tested)
 		return tpm_tis_send_main(chip, buf, len);
@@ -472,11 +484,12 @@ static const struct tis_vendor_timeout_o
 static bool tpm_tis_update_timeouts(struct tpm_chip *chip,
 				    unsigned long *timeout_cap)
 {
-	struct priv_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(priv);
 	int i;
 	u32 did_vid;
 
-	did_vid = ioread32(priv->iobase + TPM_DID_VID(0));
+	did_vid = ioread32(phy->iobase + TPM_DID_VID(0));
 
 	for (i = 0; i != ARRAY_SIZE(vendor_timeout_overrides); i++) {
 		if (vendor_timeout_overrides[i].did_vid != did_vid)
@@ -496,7 +509,8 @@ static bool tpm_tis_update_timeouts(stru
  */
 static int probe_itpm(struct tpm_chip *chip)
 {
-	struct priv_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(priv);
 	int rc = 0;
 	u8 cmd_getticks[] = {
 		0x00, 0xc1, 0x00, 0x00, 0x00, 0x0a,
@@ -504,7 +518,7 @@ static int probe_itpm(struct tpm_chip *c
 	};
 	size_t len = sizeof(cmd_getticks);
 	bool rem_itpm = itpm;
-	u16 vendor = ioread16(priv->iobase + TPM_DID_VID(0));
+	u16 vendor = ioread16(phy->iobase + TPM_DID_VID(0));
 
 	/* probe only iTPMS */
 	if (vendor != TPM_VID_INTEL)
@@ -538,7 +552,7 @@ out:
 
 static bool tpm_tis_req_canceled(struct tpm_chip *chip, u8 status)
 {
-	struct priv_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
 
 	switch (priv->manufacturer_id) {
 	case TPM_VID_WINBOND:
@@ -565,11 +579,12 @@ static const struct tpm_class_ops tpm_ti
 static irqreturn_t tis_int_handler(int dummy, void *dev_id)
 {
 	struct tpm_chip *chip = dev_id;
-	struct priv_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(priv);
 	u32 interrupt;
 	int i;
 
-	interrupt = ioread32(priv->iobase +
+	interrupt = ioread32(phy->iobase +
 			     TPM_INT_STATUS(priv->locality));
 
 	if (interrupt == 0)
@@ -589,9 +604,9 @@ static irqreturn_t tis_int_handler(int d
 
 	/* Clear interrupts handled with TPM_EOI */
 	iowrite32(interrupt,
-		  priv->iobase +
+		  phy->iobase +
 		  TPM_INT_STATUS(priv->locality));
-	ioread32(priv->iobase + TPM_INT_STATUS(priv->locality));
+	ioread32(phy->iobase + TPM_INT_STATUS(priv->locality));
 	return IRQ_HANDLED;
 }
 
@@ -602,7 +617,8 @@ static irqreturn_t tis_int_handler(int d
 static int tpm_tis_probe_irq_single(struct tpm_chip *chip, u32 intmask,
 				    int flags, int irq)
 {
-	struct priv_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(priv);
 	u8 original_int_vec;
 
 	if (devm_request_irq(chip->dev.parent, irq, tis_int_handler, flags,
@@ -613,19 +629,19 @@ static int tpm_tis_probe_irq_single(stru
 	}
 	priv->irq = irq;
 
-	original_int_vec = ioread8(priv->iobase +
+	original_int_vec = ioread8(phy->iobase +
 				   TPM_INT_VECTOR(priv->locality));
 	iowrite8(irq,
-		 priv->iobase + TPM_INT_VECTOR(priv->locality));
+		 phy->iobase + TPM_INT_VECTOR(priv->locality));
 
 	/* Clear all existing */
-	iowrite32(ioread32(priv->iobase +
+	iowrite32(ioread32(phy->iobase +
 			   TPM_INT_STATUS(priv->locality)),
-		  priv->iobase + TPM_INT_STATUS(priv->locality));
+		  phy->iobase + TPM_INT_STATUS(priv->locality));
 
 	/* Turn on */
 	iowrite32(intmask | TPM_GLOBAL_INT_ENABLE,
-		  priv->iobase + TPM_INT_ENABLE(priv->locality));
+		  phy->iobase + TPM_INT_ENABLE(priv->locality));
 
 	priv->irq_tested = false;
 
@@ -642,7 +658,7 @@ static int tpm_tis_probe_irq_single(stru
 	 */
 	if (!(chip->flags & TPM_CHIP_FLAG_IRQ)) {
 		iowrite8(original_int_vec,
-			 priv->iobase + TPM_INT_VECTOR(priv->locality));
+			 phy->iobase + TPM_INT_VECTOR(priv->locality));
 		return 1;
 	}
 
@@ -655,11 +671,12 @@ static int tpm_tis_probe_irq_single(stru
  */
 static void tpm_tis_probe_irq(struct tpm_chip *chip, u32 intmask)
 {
-	struct priv_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(priv);
 	u8 original_int_vec;
 	int i;
 
-	original_int_vec = ioread8(priv->iobase +
+	original_int_vec = ioread8(phy->iobase +
 				   TPM_INT_VECTOR(priv->locality));
 
 	if (!original_int_vec) {
@@ -679,8 +696,9 @@ MODULE_PARM_DESC(interrupts, "Enable int
 
 static void tpm_tis_remove(struct tpm_chip *chip)
 {
-	struct priv_data *priv = dev_get_drvdata(&chip->dev);
-	void __iomem *reg = priv->iobase + TPM_INT_ENABLE(priv->locality);
+	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(priv);
+	void __iomem *reg = phy->iobase + TPM_INT_ENABLE(priv->locality);
 
 	iowrite32(~TPM_GLOBAL_INT_ENABLE & ioread32(reg), reg);
 	release_locality(chip, priv->locality, 1);
@@ -692,10 +710,10 @@ static int tpm_tis_init(struct device *d
 	u32 vendor, intfcaps, intmask;
 	int rc, probe;
 	struct tpm_chip *chip;
-	struct priv_data *priv;
+	struct tpm_tis_tcg_phy *phy;
 
-	priv = devm_kzalloc(dev, sizeof(struct priv_data), GFP_KERNEL);
-	if (priv == NULL)
+	phy = devm_kzalloc(dev, sizeof(struct tpm_tis_tcg_phy), GFP_KERNEL);
+	if (phy == NULL)
 		return -ENOMEM;
 
 	chip = tpmm_chip_alloc(dev, &tpm_tis);
@@ -706,9 +724,9 @@ static int tpm_tis_init(struct device *d
 	chip->acpi_dev_handle = acpi_dev_handle;
 #endif
 
-	priv->iobase = devm_ioremap_resource(dev, &tpm_info->res);
-	if (IS_ERR(priv->iobase))
-		return PTR_ERR(priv->iobase);
+	phy->iobase = devm_ioremap_resource(dev, &tpm_info->res);
+	if (IS_ERR(phy->iobase))
+		return PTR_ERR(phy->iobase);
 
 	/* Maximum timeouts */
 	chip->timeout_a = TIS_TIMEOUT_A_MAX;
@@ -716,7 +734,7 @@ static int tpm_tis_init(struct device *d
 	chip->timeout_c = TIS_TIMEOUT_C_MAX;
 	chip->timeout_d = TIS_TIMEOUT_D_MAX;
 
-	dev_set_drvdata(&chip->dev, priv);
+	dev_set_drvdata(&chip->dev, &phy->priv);
 
 	if (wait_startup(chip, 0) != 0) {
 		rc = -ENODEV;
@@ -724,13 +742,13 @@ static int tpm_tis_init(struct device *d
 	}
 
 	/* Take control of the TPM's interrupt hardware and shut it off */
-	intmask = ioread32(priv->iobase +
-			   TPM_INT_ENABLE(priv->locality));
+	intmask = ioread32(phy->iobase +
+			   TPM_INT_ENABLE(phy->priv.locality));
 	intmask |= TPM_INTF_CMD_READY_INT | TPM_INTF_LOCALITY_CHANGE_INT |
 		   TPM_INTF_DATA_AVAIL_INT | TPM_INTF_STS_VALID_INT;
 	intmask &= ~TPM_GLOBAL_INT_ENABLE;
 	iowrite32(intmask,
-		  priv->iobase + TPM_INT_ENABLE(priv->locality));
+		  phy->iobase + TPM_INT_ENABLE(phy->priv.locality));
 
 	if (request_locality(chip, 0) != 0) {
 		rc = -ENODEV;
@@ -741,12 +759,12 @@ static int tpm_tis_init(struct device *d
 	if (rc)
 		goto out_err;
 
-	vendor = ioread32(priv->iobase + TPM_DID_VID(0));
-	priv->manufacturer_id = vendor;
+	vendor = ioread32(phy->iobase + TPM_DID_VID(0));
+	phy->priv.manufacturer_id = vendor;
 
 	dev_info(dev, "%s TPM (device-id 0x%X, rev-id %d)\n",
 		 (chip->flags & TPM_CHIP_FLAG_TPM2) ? "2.0" : "1.2",
-		 vendor >> 16, ioread8(priv->iobase + TPM_RID(0)));
+		 vendor >> 16, ioread8(phy->iobase + TPM_RID(0)));
 
 	if (!itpm) {
 		probe = probe_itpm(chip);
@@ -763,8 +781,8 @@ static int tpm_tis_init(struct device *d
 
 	/* Figure out the capabilities */
 	intfcaps =
-	    ioread32(priv->iobase +
-		     TPM_INTF_CAPS(priv->locality));
+	    ioread32(phy->iobase +
+		     TPM_INTF_CAPS(phy->priv.locality));
 	dev_dbg(dev, "TPM interface capabilities (0x%x):\n",
 		intfcaps);
 	if (intfcaps & TPM_INTF_BURST_COUNT_STATIC)
@@ -797,8 +815,8 @@ static int tpm_tis_init(struct device *d
 	}
 
 	/* INTERRUPT Setup */
-	init_waitqueue_head(&priv->read_queue);
-	init_waitqueue_head(&priv->int_queue);
+	init_waitqueue_head(&phy->priv.read_queue);
+	init_waitqueue_head(&phy->priv.int_queue);
 	if (interrupts && tpm_info->irq != -1) {
 		if (tpm_info->irq) {
 			tpm_tis_probe_irq_single(chip, intmask, IRQF_SHARED,
@@ -842,23 +860,24 @@ out_err:
 #ifdef CONFIG_PM_SLEEP
 static void tpm_tis_reenable_interrupts(struct tpm_chip *chip)
 {
-	struct priv_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_data *priv = dev_get_drvdata(&chip->dev);
+	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(priv);
 	u32 intmask;
 
 	/* reenable interrupts that device may have lost or
 	   BIOS/firmware may have disabled */
-	iowrite8(priv->irq, priv->iobase +
+	iowrite8(priv->irq, phy->iobase +
 		 TPM_INT_VECTOR(priv->locality));
 
 	intmask =
-	    ioread32(priv->iobase + TPM_INT_ENABLE(priv->locality));
+	    ioread32(phy->iobase + TPM_INT_ENABLE(priv->locality));
 
 	intmask |= TPM_INTF_CMD_READY_INT
 	    | TPM_INTF_LOCALITY_CHANGE_INT | TPM_INTF_DATA_AVAIL_INT
 	    | TPM_INTF_STS_VALID_INT | TPM_GLOBAL_INT_ENABLE;
 
 	iowrite32(intmask,
-		  priv->iobase + TPM_INT_ENABLE(priv->locality));
+		  phy->iobase + TPM_INT_ENABLE(priv->locality));
 }
 
 static int tpm_tis_resume(struct device *dev)
--- /dev/null
+++ b/drivers/char/tpm/tpm_tis_core.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2005, 2006 IBM Corporation
+ * Copyright (C) 2014, 2015 Intel Corporation
+ *
+ * Authors:
+ * Leendert van Doorn <leendert@watson.ibm.com>
+ * Kylene Hall <kjhall@us.ibm.com>
+ *
+ * Maintained by: <tpmdd-devel@lists.sourceforge.net>
+ *
+ * Device driver for TCG/TCPA TPM (trusted platform module).
+ * Specifications at www.trustedcomputinggroup.org
+ *
+ * This device driver implements the TPM interface as defined in
+ * the TCG TPM Interface Spec version 1.2, revision 1.0.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2 of the
+ * License.
+ */
+
+#ifndef __TPM_TIS_CORE_H__
+#define __TPM_TIS_CORE_H__
+
+#include "tpm.h"
+
+struct tpm_tis_data {
+	u16 manufacturer_id;
+	int locality;
+	int irq;
+	bool irq_tested;
+	wait_queue_head_t int_queue;
+	wait_queue_head_t read_queue;
+};
+
+#endif
