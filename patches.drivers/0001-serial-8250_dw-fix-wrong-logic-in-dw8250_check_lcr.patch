From: Kefeng Wang <wangkefeng.wang@huawei.com>
Date: Mon, 2 May 2016 17:19:46 +0800
Subject: serial: 8250_dw: fix wrong logic in dw8250_check_lcr()
Git-commit: 6550be9f62bfc4dacbdbd8cb7afe0df661da77bf
Patch-mainline: v4.7-rc1
References: bsc#1032150

Commit cdcea058e510 ("serial: 8250_dw: Avoid serial_outx code duplicate
with new dw8250_check_lcr()") introduce a wrong logic when write val to
LCR reg. When CONFIG_64BIT enabled, __raw_writeq is used unconditionally.

The __raw_readq/__raw_writeq is introduced by commit bca2092d7897 ("serial:
8250_dw: Use 64-bit access for OCTEON.") for OCTEON.

So for 64BIT && !PORT_OCTEON, we better to use coincident write function.

Fixes: cdcea058e510("serial: 8250_dw: Avoid serial_outx code duplicate with new dw8250_check_lcr()")
Signed-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Matthias Brugger <mbrugger@suse.com>
---
 drivers/tty/serial/8250/8250_dw.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/drivers/tty/serial/8250/8250_dw.c b/drivers/tty/serial/8250/8250_dw.c
index 5364de35447b..e19969614203 100644
--- a/drivers/tty/serial/8250/8250_dw.c
+++ b/drivers/tty/serial/8250/8250_dw.c
@@ -104,15 +104,16 @@ static void dw8250_check_lcr(struct uart_port *p, int value)
 		dw8250_force_idle(p);
 
 #ifdef CONFIG_64BIT
-		__raw_writeq(value & 0xff, offset);
-#else
+		if (p->type == PORT_OCTEON)
+			__raw_writeq(value & 0xff, offset);
+		else
+#endif
 		if (p->iotype == UPIO_MEM32)
 			writel(value, offset);
 		else if (p->iotype == UPIO_MEM32BE)
 			iowrite32be(value, offset);
 		else
 			writeb(value, offset);
-#endif
 	}
 	/*
 	 * FIXME: this deadlocks if port->lock is already held
-- 
2.12.0

