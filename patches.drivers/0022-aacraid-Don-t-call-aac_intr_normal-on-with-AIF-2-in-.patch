From fe51e8c9e372216d2f6715343f448f7751e8522a Mon Sep 17 00:00:00 2001
From: Johannes Thumshirn <jthumshirn@suse.de>
Date: Fri, 13 May 2016 15:22:09 +0200
Subject: [PATCH] aacraid: Don't call aac_intr_normal() with AIF == 2 in driver probe
Patch-mainline: Not yet, RFC quality
References: bsc#979497

Don't unconditionally call aac_intr_normal in new AIF mode on driver probe but
check if the adapter actually is capable of handling the AIF mode.

This will result in aac_fib_adapter_complete() getting called with a bogus value
in hw_fib->header.XferState which causes the BUG() in commsup.c:814 to fire.

Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
---
 drivers/scsi/aacraid/aacraid.h  | 14 ++++++++++++++
 drivers/scsi/aacraid/comminit.c | 38 ++++++++++++++++++++++++++++++++++++++
 drivers/scsi/aacraid/linit.c    |  7 ++++++-
 drivers/scsi/aacraid/src.c      | 31 +++----------------------------
 4 files changed, 61 insertions(+), 29 deletions(-)

diff --git a/drivers/scsi/aacraid/aacraid.h b/drivers/scsi/aacraid/aacraid.h
index 194063e..0e91eb2 100644
--- a/drivers/scsi/aacraid/aacraid.h
+++ b/drivers/scsi/aacraid/aacraid.h
@@ -2119,6 +2119,18 @@ static inline unsigned int cap_to_cyls(sector_t capacity, unsigned divisor)
 	return capacity;
 }
 
+static unsigned long __maybe_unused aac_get_bellbits(struct aac_dev *dev)
+{
+	unsigned long bellbits;
+
+	if (dev->msi_enabled)
+		bellbits = src_readl(dev, MUnit.ODR_MSI);
+	else
+		bellbits = src_readl(dev, MUnit.ODR_R);
+
+	return bellbits;
+}
+
 /* SCp.phase values */
 #define AAC_OWNER_MIDLEVEL	0x101
 #define AAC_OWNER_LOWLEVEL	0x102
@@ -2142,6 +2154,8 @@ void aac_consumer_free(struct aac_dev * dev, struct aac_queue * q, u32 qnum);
 int aac_fib_complete(struct fib * context);
 #define fib_data(fibctx) ((void *)(fibctx)->hw_fib_va->data)
 struct aac_dev *aac_init_adapter(struct aac_dev *dev);
+int aac_get_intr_mode(struct aac_dev *dev, int vector_no,
+		      unsigned long bellbits);
 void aac_src_access_devreg(struct aac_dev *dev, int mode);
 int aac_get_config_status(struct aac_dev *dev, int commit_flag);
 int aac_get_containers(struct aac_dev *dev);
diff --git a/drivers/scsi/aacraid/comminit.c b/drivers/scsi/aacraid/comminit.c
index 341ea32..9466f49 100644
--- a/drivers/scsi/aacraid/comminit.c
+++ b/drivers/scsi/aacraid/comminit.c
@@ -588,3 +588,41 @@ struct aac_dev *aac_init_adapter(struct aac_dev *dev)
 	return dev;
 }
 
+
+int aac_get_intr_mode(struct aac_dev *dev, int vector_no,
+				    unsigned long bellbits)
+{
+	int mode;
+
+	if (dev->msi_enabled) {
+		mode = AAC_INT_MODE_MSI;
+		if (vector_no == 0) {
+			bellbits = src_readl(dev, MUnit.ODR_MSI);
+			if (bellbits & 0x40000)
+				mode |= AAC_INT_MODE_AIF;
+			if (bellbits & 0x1000)
+				mode |= AAC_INT_MODE_SYNC;
+		}
+	} else {
+		mode = AAC_INT_MODE_INTX;
+		bellbits = src_readl(dev, MUnit.ODR_R);
+		if (bellbits & PmDoorBellResponseSent) {
+			bellbits = PmDoorBellResponseSent;
+			src_writel(dev, MUnit.ODR_C, bellbits);
+			src_readl(dev, MUnit.ODR_C);
+		} else {
+			unsigned long bellbits_shifted;
+
+			bellbits_shifted = (bellbits >> SRC_ODR_SHIFT);
+			src_writel(dev, MUnit.ODR_C, bellbits);
+			src_readl(dev, MUnit.ODR_C);
+
+			if (bellbits_shifted & DoorBellAifPending)
+				mode |= AAC_INT_MODE_AIF;
+			else if (bellbits_shifted & OUTBOUNDDOORBELL_0)
+				mode |= AAC_INT_MODE_SYNC;
+		}
+	}
+
+	return mode;
+}
diff --git a/drivers/scsi/aacraid/linit.c b/drivers/scsi/aacraid/linit.c
index 2203062..346a9b9 100644
--- a/drivers/scsi/aacraid/linit.c
+++ b/drivers/scsi/aacraid/linit.c
@@ -1136,6 +1136,8 @@ static int aac_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	int unique_id = 0;
 	u64 dmamask;
 	extern int aac_sync_mode;
+	unsigned long bellbits;
+	int mode;
 
 	/*
 	 * Only series 7 needs freset.
@@ -1298,7 +1300,10 @@ static int aac_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	else
 		shost->this_id = shost->max_id;
 
-	aac_intr_normal(aac, 0, 2, 0, NULL);
+	bellbits = aac_get_bellbits(aac);
+	mode = aac_get_intr_mode(aac, 0, bellbits);
+	if (mode & AAC_INT_MODE_AIF)
+		aac_intr_normal(aac, 0, 2, 0, NULL);
 
 	/*
 	 * dmb - we may need to move the setting of these parms somewhere else once
diff --git a/drivers/scsi/aacraid/src.c b/drivers/scsi/aacraid/src.c
index 28f8b8a..11bf22d 100644
--- a/drivers/scsi/aacraid/src.c
+++ b/drivers/scsi/aacraid/src.c
@@ -50,7 +50,7 @@ static irqreturn_t aac_src_intr_message(int irq, void *dev_id)
 {
 	struct aac_msix_ctx *ctx;
 	struct aac_dev *dev;
-	unsigned long bellbits, bellbits_shifted;
+	unsigned long bellbits;
 	int vector_no;
 	int isFastResponse, mode;
 	u32 index, handle;
@@ -59,34 +59,9 @@ static irqreturn_t aac_src_intr_message(int irq, void *dev_id)
 	dev = ctx->dev;
 	vector_no = ctx->vector_no;
 
-	if (dev->msi_enabled) {
-		mode = AAC_INT_MODE_MSI;
-		if (vector_no == 0) {
-			bellbits = src_readl(dev, MUnit.ODR_MSI);
-			if (bellbits & 0x40000)
-				mode |= AAC_INT_MODE_AIF;
-			if (bellbits & 0x1000)
-				mode |= AAC_INT_MODE_SYNC;
-		}
-	} else {
-		mode = AAC_INT_MODE_INTX;
-		bellbits = src_readl(dev, MUnit.ODR_R);
-		if (bellbits & PmDoorBellResponseSent) {
-			bellbits = PmDoorBellResponseSent;
-			src_writel(dev, MUnit.ODR_C, bellbits);
-			src_readl(dev, MUnit.ODR_C);
-		} else {
-			bellbits_shifted = (bellbits >> SRC_ODR_SHIFT);
-			src_writel(dev, MUnit.ODR_C, bellbits);
-			src_readl(dev, MUnit.ODR_C);
-
-			if (bellbits_shifted & DoorBellAifPending)
-				mode |= AAC_INT_MODE_AIF;
-			else if (bellbits_shifted & OUTBOUNDDOORBELL_0)
-				mode |= AAC_INT_MODE_SYNC;
-		}
-	}
+	bellbits = aac_get_bellbits(dev);
 
+	mode = aac_get_intr_mode(dev, vector_no, bellbits);
 	if (mode & AAC_INT_MODE_SYNC) {
 		unsigned long sflags;
 		struct list_head *entry;
-- 
1.8.5.6

