From: Heinz Mauelshagen <heinzm@redhat.com>
Date: Thu, 19 May 2016 18:49:29 +0200
Subject: dm raid: use rt_is_raid*() in all appropriate checks
References: bnc#1023798,FATE#321463
Patch-Mainline: v4.8-rc1
Git-commit: 676fa5ad6e96e5704b0f2d5bb56ea115c807eef4

Make use if raid type rt_is_*() bool functions for simplification and
consistency reasons.

Signed-off-by: Heinz Mauelshagen <heinzm@redhat.com>
Signed-off-by: Mike Snitzer <snitzer@redhat.com>
Acked-by: Hannes Reinecke <hare@suse.de>
---
 drivers/md/dm-raid.c | 30 ++++++++++++++++++------------
 1 file changed, 18 insertions(+), 12 deletions(-)

diff --git a/drivers/md/dm-raid.c b/drivers/md/dm-raid.c
index 668398d..7196124 100644
--- a/drivers/md/dm-raid.c
+++ b/drivers/md/dm-raid.c
@@ -260,6 +260,12 @@ static bool rt_is_raid6(struct raid_type *rt)
 {
 	return rt->level == 6;
 }
+
+/* Return true, if raid type in @rt is raid4/5/6 */
+static bool rt_is_raid456(struct raid_type *rt)
+{
+	return _in_range(rt->level, 4, 6);
+}
 /* END: raid level bools */
 
 /*
@@ -723,7 +729,7 @@ static int parse_raid_params(struct raid_set *rs, struct dm_arg_set *as,
 	 * First, parse the in-order required arguments
 	 * "chunk_size" is the only argument of this type.
 	 */
-	if (rs->raid_type->level == 1) {
+	if (rt_is_raid1(rs->raid_type)) {
 		if (value)
 			DMERR("Ignoring chunk size parameter for RAID 1");
 		value = 0;
@@ -788,7 +794,7 @@ static int parse_raid_params(struct raid_set *rs, struct dm_arg_set *as,
 		if (!strcasecmp(key, _argname_by_flag(CTR_FLAG_RAID10_FORMAT))) {
 			if (_test_and_set_flag(CTR_FLAG_RAID10_FORMAT, &rs->ctr_flags))
 				return ti_error_einval(rs->ti, "Only one raid10_format argument pair allowed");
-			if (rs->raid_type->level != 10)
+			if (!rt_is_raid10(rs->raid_type))
 				return ti_error_einval(rs->ti, "'raid10_format' is an invalid parameter for this RAID type");
 			if (strcmp("near", arg) &&
 			    strcmp("far", arg) &&
@@ -817,7 +823,7 @@ static int parse_raid_params(struct raid_set *rs, struct dm_arg_set *as,
 			rd->rdev.recovery_offset = 0;
 			_set_flag(CTR_FLAG_REBUILD, &rs->ctr_flags);
 		} else if (!strcasecmp(key, _argname_by_flag(CTR_FLAG_WRITE_MOSTLY))) {
-			if (rs->raid_type->level != 1)
+			if (!rt_is_raid1(rs->raid_type))
 				return ti_error_einval(rs->ti, "write_mostly option is only valid for RAID1");
 
 			if (!_in_range(value, 0, rs->md.raid_disks - 1))
@@ -826,7 +832,7 @@ static int parse_raid_params(struct raid_set *rs, struct dm_arg_set *as,
 			set_bit(WriteMostly, &rs->dev[value].rdev.flags);
 			_set_flag(CTR_FLAG_WRITE_MOSTLY, &rs->ctr_flags);
 		} else if (!strcasecmp(key, _argname_by_flag(CTR_FLAG_MAX_WRITE_BEHIND))) {
-			if (rs->raid_type->level != 1)
+			if (!rt_is_raid1(rs->raid_type))
 				return ti_error_einval(rs->ti, "max_write_behind option is only valid for RAID1");
 
 			if (_test_and_set_flag(CTR_FLAG_MAX_WRITE_BEHIND, &rs->ctr_flags))
@@ -856,7 +862,7 @@ static int parse_raid_params(struct raid_set *rs, struct dm_arg_set *as,
 			 */
 			value /= 2;
 
-			if (!_in_range(rs->raid_type->level, 4, 6))
+			if (!rt_is_raid456(rs->raid_type))
 				return ti_error_einval(rs->ti, "Inappropriate argument: stripe_cache");
 			if (raid5_set_cache_size(&rs->md, (int)value))
 				return ti_error_einval(rs->ti, "Bad stripe_cache size");
@@ -903,7 +909,7 @@ static int parse_raid_params(struct raid_set *rs, struct dm_arg_set *as,
 	if (dm_set_target_max_io_len(rs->ti, max_io_len))
 		return -EINVAL;
 
-	if (rs->raid_type->level == 10) {
+	if (rt_is_raid10(rs->raid_type)) {
 		if (raid10_copies > rs->md.raid_disks)
 			return ti_error_einval(rs->ti, "Not enough devices to satisfy specification");
 
@@ -921,7 +927,7 @@ static int parse_raid_params(struct raid_set *rs, struct dm_arg_set *as,
 		rs->md.layout = raid10_format_to_md_layout(raid10_format,
 							   raid10_copies);
 		rs->md.new_layout = rs->md.layout;
-	} else if ((!rs->raid_type->level || rs->raid_type->level > 1) &&
+	} else if (!rt_is_raid1(rs->raid_type) &&
 		   sector_div(sectors_per_dev,
 			      (rs->md.raid_disks - rs->raid_type->parity_devs)))
 		return ti_error_einval(rs->ti, "Target length not divisible by number of data devices");
@@ -1142,7 +1148,7 @@ static int super_init_validation(struct mddev *mddev, struct md_rdev *rdev)
 	}
 
 	/* We can only change the number of devices in RAID1 right now */
-	if ((rs->raid_type->level != 1) &&
+	if (!rt_is_raid1(rs->raid_type) &&
 	    (le32_to_cpu(sb->num_devices) != mddev->raid_disks)) {
 		DMERR("Reshaping arrays not yet supported. (device count change)");
 		return -EINVAL;
@@ -1206,7 +1212,7 @@ static int super_init_validation(struct mddev *mddev, struct md_rdev *rdev)
 		if (!test_bit(FirstUse, &r->flags) && (r->raid_disk >= 0)) {
 			role = le32_to_cpu(sb2->array_position);
 			if (role != r->raid_disk) {
-				if (rs->raid_type->level != 1)
+				if (!rt_is_raid1(rs->raid_type))
 					return ti_error_einval(rs->ti, "Cannot change device "
 								       "positions in RAID array");
 				DMINFO("RAID1 device #%d now at position #%d",
@@ -1243,7 +1249,7 @@ static int super_validate(struct raid_set *rs, struct md_rdev *rdev)
 	}
 
 	/* Enable bitmap creation for RAID levels != 0 */
-	mddev->bitmap_info.offset = (rs->raid_type->level) ? to_sector(4096) : 0;
+	mddev->bitmap_info.offset = rt_is_raid0(rs->raid_type) ? 0 : to_sector(4096);
 	rdev->mddev->bitmap_info.default_offset = mddev->bitmap_info.offset;
 
 	if (!test_bit(FirstUse, &rdev->flags)) {
@@ -1564,7 +1570,7 @@ static void raid_status(struct dm_target *ti, status_type_t type,
 	case STATUSTYPE_INFO:
 		DMEMIT("%s %d ", rs->raid_type->name, rs->md.raid_disks);
 
-		if (rs->raid_type->level) {
+		if (!rt_is_raid0(rs->raid_type)) {
 			if (test_bit(MD_RECOVERY_RUNNING, &rs->md.recovery))
 				sync = rs->md.curr_resync_completed;
 			else
@@ -1887,7 +1893,7 @@ static void raid_resume(struct dm_target *ti)
 {
 	struct raid_set *rs = ti->private;
 
-	if (rs->raid_type->level) {
+	if (!rt_is_raid0(rs->raid_type)) {
 		set_bit(MD_CHANGE_DEVS, &rs->md.flags);
 
 		if (!rs->bitmap_loaded) {
-- 
1.8.5.6

