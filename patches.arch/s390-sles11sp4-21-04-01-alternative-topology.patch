From: Heiko Carstens <heiko.carstens@de.ibm.com>
Subject: s390/topology: alternative topology for topology-less machines
Patch-mainline: v4.14-rc2
Git-commit: 1b25fda0533462c9cee3a22e8a7bea68fa670af2
References: bnc#1060245, LTC#159177

Description:  kernel: alternative topology
Symptom:      Overall performance is lower than expected.
Problem:      When running within a z/VM guest the Linux scheduling domains
              are configured in such a way that each CPU is far away from
              all other CPUs. This way the kernel tries to avoid to send
              expensive inter processor interrupts to other CPUs. As a
              downside sometimes this also leads to the situation where
              idle CPUs won't be woken up even if there is a runable process
              waiting for execution. It depends on the workload if this
              behavior is good or not.
Solution:     Add a sysctl file /proc/sys/s390/topology which allows to
              change the default configuration. When running within a
              z/VM guest writing 1 to the file will result in a different
              topology where all CPUs are configured to be close to each
              other. This may increase overall performance depending on
              the workload.
              The used default topology within a z/VM guest can also be
              changed with the kernel command line parameter 'topology=on'.
Reproduction: -

Upstream-Description:

              s390/topology: alternative topology for topology-less machines

              If running on machines that do not provide topology information we
              currently generate a "fake" topology which defines the maximum
              distance between each cpu: each cpu will be put into an own drawer.

              Historically this used to be the best option for (virtual) machines in
              overcommited hypervisors.

              For some workloads however it is better to generate a different
              topology where all cpus are siblings within a package (all cpus are
              core siblings). This shows performance improvements of up to 10%,
              depending on the workload.

              In order to keep the current behaviour, but also allow to switch to
              the different core sibling topology use the existing "topology="
              kernel parameter:

              Specifying "topology=on" on machines without topology information will
              generate the core siblings (fake) topology information, instead of the
              default topology information where all cpus have the maximum distance.

              On machines which provide topology information specifying
              "topology=on" does not have any effect.

              Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
              Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>


Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
---
 arch/s390/kernel/topology.c |   70 ++++++++++++++++++++++++++++++++------------
 1 file changed, 52 insertions(+), 18 deletions(-)

--- a/arch/s390/kernel/topology.c
+++ b/arch/s390/kernel/topology.c
@@ -22,13 +22,20 @@
 #define PTF_VERTICAL	(1UL)
 #define PTF_CHECK	(2UL)
 
+enum {
+	TOPOLOGY_MODE_HW,
+	TOPOLOGY_MODE_SINGLE,
+	TOPOLOGY_MODE_PACKAGE,
+	TOPOLOGY_MODE_UNINITIALIZED
+};
+
 struct mask_info {
 	struct mask_info *next;
 	unsigned char id;
 	cpumask_t mask;
 };
 
-static int topology_enabled = 1;
+static int topology_mode = TOPOLOGY_MODE_UNINITIALIZED;
 static void topology_work_fn(struct work_struct *work);
 static struct sysinfo_15_1_x *tl_info;
 static struct timer_list topology_timer;
@@ -51,20 +58,28 @@ static cpumask_t cpu_group_map(struct ma
 {
 	cpumask_t mask;
 
-	cpumask_clear(&mask);
-	if (!topology_enabled || !MACHINE_HAS_TOPOLOGY) {
-		cpumask_copy(&mask, cpumask_of(cpu));
-		return mask;
-	}
-	while (info) {
-		if (cpumask_test_cpu(cpu, &info->mask)) {
-			mask = info->mask;
-			break;
+	cpumask_copy(&mask, cpumask_of(cpu));
+	switch (topology_mode) {
+	case TOPOLOGY_MODE_HW:
+		while (info) {
+			if (cpumask_test_cpu(cpu, &info->mask)) {
+				mask = info->mask;
+				break;
+			}
+			info = info->next;
 		}
-		info = info->next;
-	}
-	if (cpumask_empty(&mask))
+		if (cpumask_empty(&mask))
+			cpumask_copy(&mask, cpumask_of(cpu));
+		break;
+	case TOPOLOGY_MODE_PACKAGE:
+		cpumask_copy(&mask, cpu_present_mask);
+		break;
+	default:
+		/* fallthrough */
+	case TOPOLOGY_MODE_SINGLE:
 		cpumask_copy(&mask, cpumask_of(cpu));
+		break;
+	}
 	return mask;
 }
 
@@ -304,14 +319,27 @@ static void set_topology_timer(void)
 	add_timer(&topology_timer);
 }
 
-static int __init early_parse_topology(char *p)
+static inline int topology_get_mode(int enabled)
 {
-	if (strncmp(p, "off", 3))
-		return 0;
-	topology_enabled = 0;
+	if (!enabled)
+		return TOPOLOGY_MODE_SINGLE;
+	return MACHINE_HAS_TOPOLOGY ? TOPOLOGY_MODE_HW : TOPOLOGY_MODE_PACKAGE;
+}
+
+static int __init topology_setup(char *str)
+{
+	int enabled;
+
+	if (!strncmp(str, "off", 3))
+		enabled = 0;
+	else if (!strncmp(str, "on", 2))
+		enabled = 1;
+	else
+		return -EINVAL;
+	topology_mode = topology_get_mode(enabled);
 	return 0;
 }
-early_param("topology", early_parse_topology);
+early_param("topology", topology_setup);
 
 static int __init init_topology_update(void)
 {
@@ -350,6 +378,12 @@ void __init s390_init_cpu_topology(void)
 	struct sysinfo_15_1_x *info;
 	int i;
 
+	if (topology_mode == TOPOLOGY_MODE_UNINITIALIZED) {
+		if (MACHINE_HAS_TOPOLOGY)
+			topology_mode = TOPOLOGY_MODE_HW;
+		else
+			topology_mode = TOPOLOGY_MODE_SINGLE;
+	}
 	if (!MACHINE_HAS_TOPOLOGY)
 		return;
 	tl_info = alloc_bootmem_pages(PAGE_SIZE);
