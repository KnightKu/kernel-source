From: Janosch Frank <frankja@linux.vnet.ibm.com>
Subject: s390: Make cpc_name accessible
Patch-mainline: v4.8-rc1
Git-commit: e435dc31398e63b992639cf62024d959219db191
References: FATE#324070, LTC#158959

Summary:     kernel: Implement Store Hypervisor Information instruction in KVM
Description: Store Hypervisor Information is an emulated z/VM
             instruction that provides a guest with basic information about the
             layers it is running on. This includes information about the cpu
             configuration of both the machine and the lpar, as well as their
             names, machine model and machine type. This information enables an
             application to determine the maximum capacity of CPs and IFLs
             available to software.

Upstream-Description:

             s390: Make cpc_name accessible

             sclp_ocf.c is the only way to get the cpc name, as it registers the
             sole event handler for the ocf event. By creating a new global
             function that copies that name, we make it accessible to the world
             which longs to retrieve it.

             Additionally we now also store the cpc name as EBCDIC, so we don't
             have to convert it to and from ASCII if it is requested in native
             encoding.

             Signed-off-by: Janosch Frank <frankja@linux.vnet.ibm.com>
             Reviewed-by: David Hildenbrand <dahi@linux.vnet.ibm.com>
             Acked-by: Heiko Carstens <heiko.carstens@de.ibm.com>
             Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>


Signed-off-by: Janosch Frank <frankja@linux.vnet.ibm.com>
Acked-by: Johannes Thumshirn <jthumshirn@suse.de>
---
 arch/s390/include/asm/sclp.h |    1 +
 drivers/s390/char/sclp_ocf.c |   23 +++++++++++++++--------
 2 files changed, 16 insertions(+), 8 deletions(-)

--- a/arch/s390/include/asm/sclp.h
+++ b/arch/s390/include/asm/sclp.h
@@ -97,5 +97,6 @@ int sclp_pci_report(struct zpci_report_e
 int memcpy_hsa(void *dest, unsigned long src, size_t count, int mode);
 void sclp_early_detect(void);
 int _sclp_print_early(const char *);
+void sclp_ocf_cpc_name_copy(char *dst);
 
 #endif /* _ASM_S390_SCLP_H */
--- a/drivers/s390/char/sclp_ocf.c
+++ b/drivers/s390/char/sclp_ocf.c
@@ -26,7 +26,7 @@
 #define OCF_LENGTH_CPC_NAME 8UL
 
 static char hmc_network[OCF_LENGTH_HMC_NETWORK + 1];
-static char cpc_name[OCF_LENGTH_CPC_NAME + 1];
+static char cpc_name[OCF_LENGTH_CPC_NAME]; /* in EBCDIC */
 
 static DEFINE_SPINLOCK(sclp_ocf_lock);
 static struct work_struct sclp_ocf_change_work;
@@ -72,9 +72,8 @@ static void sclp_ocf_handler(struct evbu
 	}
 	if (cpc) {
 		size = min(OCF_LENGTH_CPC_NAME, (size_t) cpc->length);
+		memset(cpc_name, 0, OCF_LENGTH_CPC_NAME);
 		memcpy(cpc_name, cpc + 1, size);
-		EBCASC(cpc_name, size);
-		cpc_name[size] = 0;
 	}
 	spin_unlock(&sclp_ocf_lock);
 	schedule_work(&sclp_ocf_change_work);
@@ -85,15 +84,23 @@ static struct sclp_register sclp_ocf_eve
 	.receiver_fn = sclp_ocf_handler,
 };
 
+void sclp_ocf_cpc_name_copy(char *dst)
+{
+	spin_lock_irq(&sclp_ocf_lock);
+	memcpy(dst, cpc_name, OCF_LENGTH_CPC_NAME);
+	spin_unlock_irq(&sclp_ocf_lock);
+}
+EXPORT_SYMBOL(sclp_ocf_cpc_name_copy);
+
 static ssize_t cpc_name_show(struct kobject *kobj,
 			     struct kobj_attribute *attr, char *page)
 {
-	int rc;
+	char name[OCF_LENGTH_CPC_NAME + 1];
 
-	spin_lock_irq(&sclp_ocf_lock);
-	rc = snprintf(page, PAGE_SIZE, "%s\n", cpc_name);
-	spin_unlock_irq(&sclp_ocf_lock);
-	return rc;
+	sclp_ocf_cpc_name_copy(name);
+	name[OCF_LENGTH_CPC_NAME] = 0;
+	EBCASC(name, OCF_LENGTH_CPC_NAME);
+	return snprintf(page, PAGE_SIZE, "%s\n", name);
 }
 
 static struct kobj_attribute cpc_name_attr =
