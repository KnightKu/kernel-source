From: Martin Schwidefsky <schwidefsky@de.ibm.com>
Subject: s390: add automatic detection of the spectre defense
Patch-mainline: not yet, under development
References: bnc#1089386, LTC#166572

Description:  kernel: expoline defense against the spectre attack
Symptom:      None
Problem:      The spectre attack may be used to read restricted kernel
              data from user space.
Solution:     Provide execute trampolines for indirect branches
Reproduction: None

Upstream-Description:

              s390: add automatic detection of the spectre defense

              Automatically decide between nobp vs. expolines if the spectre_v2=auto
              kernel parameter is specified or CONFIG_EXPOLINE_AUTO=y is set.

              The decision made at boot time due to CONFIG_EXPOLINE_AUTO=y being set
              can be overruled with the nobp, nospec and spectre_v2 kernel parameters.

              Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>


Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
Acked-by: Johannes Thumshirn <jthumshirn@suse.de>
---
 arch/s390/Kconfig                     |    2 
 arch/s390/Makefile                    |    2 
 arch/s390/include/asm/nospec-branch.h |    6 --
 arch/s390/kernel/alternative.c        |    1 
 arch/s390/kernel/module.c             |   10 ++--
 arch/s390/kernel/nospec-branch.c      |   75 +++++++++++++++++++---------------
 6 files changed, 54 insertions(+), 42 deletions(-)

--- a/arch/s390/Kconfig
+++ b/arch/s390/Kconfig
@@ -732,7 +732,7 @@ choice
 config EXPOLINE_OFF
 	bool "spectre_v2=off"
 
-config EXPOLINE_MEDIUM
+config EXPOLINE_AUTO
 	bool "spectre_v2=auto"
 
 config EXPOLINE_FULL
--- a/arch/s390/Makefile
+++ b/arch/s390/Makefile
@@ -91,7 +91,7 @@ ifdef CONFIG_EXPOLINE
     CC_FLAGS_EXPOLINE += -mfunction-return=thunk
     CC_FLAGS_EXPOLINE += -mindirect-branch-table
     export CC_FLAGS_EXPOLINE
-    cflags-y += $(CC_FLAGS_EXPOLINE)
+    cflags-y += $(CC_FLAGS_EXPOLINE) -DCC_USING_EXPOLINE
   endif
 endif
 
--- a/arch/s390/include/asm/nospec-branch.h
+++ b/arch/s390/include/asm/nospec-branch.h
@@ -6,12 +6,10 @@
 
 #include <linux/types.h>
 
-extern int nospec_call_disable;
-extern int nospec_return_disable;
+extern int nospec_disable;
 
 void nospec_init_branches(void);
-void nospec_call_revert(s32 *start, s32 *end);
-void nospec_return_revert(s32 *start, s32 *end);
+void nospec_revert(s32 *start, s32 *end);
 
 #endif /* __ASSEMBLY__ */
 
--- a/arch/s390/kernel/alternative.c
+++ b/arch/s390/kernel/alternative.c
@@ -1,6 +1,7 @@
 #include <linux/module.h>
 #include <linux/uaccess.h>
 #include <asm/alternative.h>
+#include <asm/nospec-branch.h>
 
 #define MAX_PATCH_LEN (255 - 1)
 
--- a/arch/s390/kernel/module.c
+++ b/arch/s390/kernel/module.c
@@ -176,7 +176,7 @@ module_frob_arch_sections(Elf_Ehdr *hdr,
 	me->arch.plt_offset = me->core_size;
 	if (me->arch.plt_size) {
 #ifdef CONFIG_EXPOLINE
-		if (!nospec_call_disable)
+		if (!nospec_disable)
 			me->arch.plt_size += PLT_ENTRY_SIZE;
 #endif
 		me->core_size += me->arch.plt_size;
@@ -317,7 +317,7 @@ apply_rela(Elf_Rela *rela, Elf_Addr base
 			ip[1] = 0x100a0004;	/* lg	1,10(1) */
 			ip[2] = 0x07f10000;	/* br %r1 */
 #ifdef CONFIG_EXPOLINE
-			if (!nospec_call_disable) {
+			if (!nospec_disable) {
 				unsigned int *ij;
 				ij = me->module_core +
 					me->arch.plt_offset +
@@ -432,7 +432,7 @@ int module_finalize(const Elf_Ehdr *hdr,
 	void *aseg;
 
 #ifdef CONFIG_EXPOLINE
-	if (!nospec_call_disable && me->arch.plt_size) {
+	if (!nospec_disable && me->arch.plt_size) {
 		unsigned int *ij;
 
 		ij = me->module_core + me->arch.plt_offset +
@@ -460,10 +460,10 @@ int module_finalize(const Elf_Ehdr *hdr,
 
 #ifdef CONFIG_EXPOLINE
 		if (!strcmp(".nospec_call_table", secname))
-			nospec_call_revert(aseg, aseg + s->sh_size);
+			nospec_revert(aseg, aseg + s->sh_size);
 
 		if (!strcmp(".nospec_return_table", secname))
-			nospec_return_revert(aseg, aseg + s->sh_size);
+			nospec_revert(aseg, aseg + s->sh_size);
 #endif
 	}
 
--- a/arch/s390/kernel/nospec-branch.c
+++ b/arch/s390/kernel/nospec-branch.c
@@ -11,10 +11,18 @@ static int __init nobp_setup_early(char
 	rc = strtobool(str, &enabled);
 	if (rc)
 		return rc;
-	if (enabled && test_facility(82))
+	if (enabled && test_facility(82)) {
+		/*
+		 * The user explicitely requested nobp=1, enable it and
+		 * disable the expoline support.
+		 */
 		__set_facility(82, S390_lowcore.alt_stfle_fac_list);
-	else
+#ifdef CONFIG_EXPOLINE
+		nospec_disable = 1;
+#endif
+	} else {
 		__clear_facility(82, S390_lowcore.alt_stfle_fac_list);
+	}
 	return 0;
 }
 early_param("nobp", nobp_setup_early);
@@ -36,38 +44,49 @@ early_param("nogmb", nogmb_setup_early);
 #ifdef CONFIG_EXPOLINE
 
 #ifdef CONFIG_EXPOLINE_OFF
-int nospec_call_disable = 1;
-#else
-int nospec_call_disable = 0;
-#endif
-#ifdef CONFIG_EXPOLINE_FULL
-int nospec_return_disable = 0;
+int nospec_disable = 1;
 #else
-int nospec_return_disable = 1;
+int nospec_disable = 0;
 #endif
 
 static int __init nospectre_v2_setup_early(char *str)
 {
-	nospec_call_disable = 1;
-	nospec_return_disable = 1;
+	nospec_disable = 1;
 	return 0;
 }
 early_param("nospectre_v2", nospectre_v2_setup_early);
 
+static int __init spectre_v2_auto_early(void)
+{
+#ifdef CC_USING_EXPOLINE
+	/*
+	 * The kernel has been compiled with expolines.
+	 * Keep expolines enabled and disable nobp.
+	 */
+	nospec_disable = 0;
+	__clear_facility(82, S390_lowcore.alt_stfle_fac_list);
+#endif
+	/*
+	 * If the kernel has not been compiled with expolines the
+	 * nobp setting decides what is done, this depends on the
+	 * CONFIG_KERNEL_NP option and the nobp/nospec parameters.
+	 */
+	return 0;
+}
+#ifdef CONFIG_EXPOLINE_AUTO
+early_initcall(spectre_v2_auto_early);
+#endif
+
 static int __init spectre_v2_setup_early(char *str)
 {
 	if (str && !strncmp(str, "on", 2)) {
-		nospec_call_disable = 0;
-		nospec_return_disable = 0;
-	}
-	if (str && !strncmp(str, "off", 3)) {
-		nospec_call_disable = 1;
-		nospec_return_disable = 1;
-	}
-	if (str && !strncmp(str, "auto", 4)) {
-		nospec_call_disable = 0;
-		nospec_return_disable = 1;
+		nospec_disable = 0;
+		__clear_facility(82, S390_lowcore.alt_stfle_fac_list);
 	}
+	if (str && !strncmp(str, "off", 3))
+		nospec_disable = 1;
+	if (str && !strncmp(str, "auto", 4))
+		spectre_v2_auto_early();
 	return 0;
 }
 early_param("spectre_v2", spectre_v2_setup_early);
@@ -120,15 +139,9 @@ static void __init_or_module __nospec_re
 	}
 }
 
-void __init_or_module nospec_call_revert(s32 *start, s32 *end)
-{
-	if (nospec_call_disable)
-		__nospec_revert(start, end);
-}
-
-void __init_or_module nospec_return_revert(s32 *start, s32 *end)
+void __init_or_module nospec_revert(s32 *start, s32 *end)
 {
-	if (nospec_return_disable)
+	if (nospec_disable)
 		__nospec_revert(start, end);
 }
 
@@ -136,8 +149,8 @@ extern s32 __nospec_call_start[], __nosp
 extern s32 __nospec_return_start[], __nospec_return_end[];
 void __init nospec_init_branches(void)
 {
-	nospec_call_revert(__nospec_call_start, __nospec_call_end);
-	nospec_return_revert(__nospec_return_start, __nospec_return_end);
+	nospec_revert(__nospec_call_start, __nospec_call_end);
+	nospec_revert(__nospec_return_start, __nospec_return_end);
 }
 
 #endif /* CONFIG_EXPOLINE */
