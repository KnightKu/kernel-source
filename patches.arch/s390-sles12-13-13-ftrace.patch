From: Heiko Carstens <heiko.carstens@de.ibm.com>
Subject: s390/ftrace: revert mcount_adjust change
Patch-mainline: never, sles12 specific
References: bnc#903279, LTC#118177

Description:  kernel: reduce function tracer overhead
Symptom:      The kernel uses more cpu cycles for each function being
              executed.
Problem:      The kGraft feature requires to instrument the kernel. In
              order to do that the kernel gets compiled with the function
              tracer enabled which causes the compiler to emit code that
              adds an "mcount" call to the prologue of each function.
              This code will be modified by the kernel for function tracing.
              However the implementation was not optimal, since even if
              disabled each function stored a value on the stack and
              afterwards contained an unconditional branch which skipped
              the rest of the mcount prologue code.
              So more instructions than necessary will be executed which
              results in a reduced performance.
Solution:     Patch the mcount prologue code so that only a single
              instruction of the mcount code will be executed. It's either
              a branch that skips the rest of the mcount prologue code or
              a branch to the function tracer.
Reproduction: Compile the kernel with and without function tracer enabled
              and compare cpu time spent in the kernel for identical
              workloads.

Upstream-Description:

              s390/ftrace: revert mcount_adjust change

              Revert the mcount_adjust change so it stays the same as for GA of
              of SLES12. Otherwise the recorded mcount offsets within the
              __mcount_loc section would point to different instruction offsets
              within the mcount prologue for out of tree built modules at GA
              time and freshly built in kernel modules.
              To keep things working adjust the ftrace code to deal with the
              offset.

              Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>

Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 arch/s390/include/asm/ftrace.h |   12 ++++++++++++
 arch/s390/kernel/ftrace.c      |   16 +++++++++-------
 arch/s390/kernel/kprobes.c     |    2 +-
 arch/s390/kernel/mcount.S      |    4 ++--
 scripts/recordmcount.c         |    2 +-
 5 files changed, 25 insertions(+), 11 deletions(-)

--- a/arch/s390/include/asm/ftrace.h
+++ b/arch/s390/include/asm/ftrace.h
@@ -6,6 +6,18 @@
 #define MCOUNT_INSN_SIZE	24
 #define MCOUNT_RETURN_FIXUP	18
 
+/*
+ * This is a SLES12 GA hack only:
+ * After GA the ftrace code got changed to convert the first instead of
+ * the second instruction. However we cannot change the recorded offsets
+ * within the __mcount_loc section, due to out of tree built modules.
+ * Therefore all (struct dyn_ftrace *) rec->ip passed instruction
+ * addresses do not point to the instruction being changed, but six bytes
+ * further.
+ * The MCOUNT_IP_FIXUP define must be used everywhere to fixup the address.
+ */
+#define MCOUNT_IP_FIXUP		6
+
 #ifndef __ASSEMBLY__
 
 void _mcount(void);
--- a/arch/s390/kernel/ftrace.c
+++ b/arch/s390/kernel/ftrace.c
@@ -59,9 +59,10 @@ int ftrace_modify_call(struct dyn_ftrace
 int ftrace_make_nop(struct module *mod, struct dyn_ftrace *rec,
 		    unsigned long addr)
 {
+	void *ip = (void *) rec->ip - MCOUNT_IP_FIXUP;
 	struct ftrace_insn orig, new, old;
 
-	if (probe_kernel_read(&old, (void *) rec->ip, sizeof(old)))
+	if (probe_kernel_read(&old, ip, sizeof(old)))
 		return -EFAULT;
 	if (addr == MCOUNT_ADDR) {
 		/* Initial code replacement; we expect to see stg r14,8(r15) */
@@ -81,22 +82,23 @@ int ftrace_make_nop(struct module *mod,
 		new.disp = KPROBE_ON_FTRACE_NOP;
 	} else {
 		/* Replace ftrace call with a nop. */
-		ftrace_generate_call_insn(&orig, rec->ip);
+		ftrace_generate_call_insn(&orig, (unsigned long) ip);
 		ftrace_generate_nop_insn(&new);
 	}
 	/* Verify that the to be replaced code matches what we expect. */
 	if (memcmp(&orig, &old, sizeof(old)))
 		return -EINVAL;
-	if (probe_kernel_write((void *) rec->ip, &new, sizeof(new)))
+	if (probe_kernel_write(ip, &new, sizeof(new)))
 		return -EPERM;
 	return 0;
 }
 
 int ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)
 {
+	void *ip = (void *) rec->ip - MCOUNT_IP_FIXUP;
 	struct ftrace_insn orig, new, old;
 
-	if (probe_kernel_read(&old, (void *) rec->ip, sizeof(old)))
+	if (probe_kernel_read(&old, ip, sizeof(old)))
 		return -EFAULT;
 	if (old.opc == BREAKPOINT_INSTRUCTION) {
 		/*
@@ -112,12 +114,12 @@ int ftrace_make_call(struct dyn_ftrace *
 	} else {
 		/* Replace nop with an ftrace call. */
 		ftrace_generate_nop_insn(&orig);
-		ftrace_generate_call_insn(&new, rec->ip);
+		ftrace_generate_call_insn(&new, (unsigned long) ip);
 	}
 	/* Verify that the to be replaced code matches what we expect. */
 	if (memcmp(&orig, &old, sizeof(old)))
 		return -EINVAL;
-	if (probe_kernel_write((void *) rec->ip, &new, sizeof(new)))
+	if (probe_kernel_write(ip, &new, sizeof(new)))
 		return -EPERM;
 	return 0;
 }
@@ -163,7 +165,7 @@ unsigned long __kprobes prepare_ftrace_r
 
 	if (unlikely(atomic_read(&current->tracing_graph_pause)))
 		goto out;
-	ip = (ip & PSW_ADDR_INSN) - MCOUNT_INSN_SIZE;
+	ip = (ip & PSW_ADDR_INSN) - MCOUNT_INSN_SIZE + MCOUNT_IP_FIXUP;
 	if (ftrace_push_return_trace(parent, ip, &trace.depth, 0) == -EBUSY)
 		goto out;
 	trace.func = ip;
--- a/arch/s390/kernel/kprobes.c
+++ b/arch/s390/kernel/kprobes.c
@@ -210,7 +210,7 @@ static void __kprobes copy_instruction(s
 	s64 disp, new_disp;
 	u64 addr, new_addr;
 
-	if (ftrace_location(ip) == ip) {
+	if (ftrace_location(ip + MCOUNT_IP_FIXUP) == ip + MCOUNT_IP_FIXUP) {
 		/*
 		 * If kprobes patches the instruction that is morphed by
 		 * ftrace make sure that kprobes always sees the branch
--- a/arch/s390/kernel/mcount.S
+++ b/arch/s390/kernel/mcount.S
@@ -34,12 +34,12 @@ ENTRY(ftrace_caller)
 	stg	%r0,(STACK_PTREGS_PSW+8)(%r15)
 	stmg	%r2,%r14,(STACK_PTREGS_GPRS+2*8)(%r15)
 #ifdef CONFIG_HAVE_MARCH_Z196_FEATURES
-	aghik	%r2,%r0,-MCOUNT_INSN_SIZE
+	aghik	%r2,%r0,-(MCOUNT_INSN_SIZE-MCOUNT_IP_FIXUP)
 	lgrl	%r4,function_trace_op
 	lgrl	%r1,ftrace_trace_function
 #else
 	lgr	%r2,%r0
-	aghi	%r2,-MCOUNT_INSN_SIZE
+	aghi	%r2,-(MCOUNT_INSN_SIZE-MCOUNT_IP_FIXUP)
 	larl	%r4,function_trace_op
 	lg	%r4,0(%r4)
 	larl	%r1,ftrace_trace_function
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -397,7 +397,7 @@ do_file(char const *const fname)
 		}
 		if (w2(ghdr->e_machine) == EM_S390) {
 			reltype = R_390_64;
-			mcount_adjust_64 = -14;
+			mcount_adjust_64 = -8;
 		}
 		if (w2(ghdr->e_machine) == EM_MIPS) {
 			reltype = R_MIPS_64;
