From: Gerald Schaefer <gerald.schaefer@de.ibm.com>
Subject: s390/mm: no local TLB flush for clearing-by-ASCE IDTE
Patch-mainline: v4.9-rc1
Git-commit: d5dcafee5f183e9aedddb147a89cb46ab038f26b
References: bnc#1088324, LTC#166470

Description:  s390/mm: fix races in TLB flushing code
Symptom:      Kernel panic (e.g. "Low-address protection") or possible data
              corruption.
Problem:      There are two race conditions in the TLB flushing code,
              related to mm_cpumask reset vs. mm detach, and unserialized
              setting of the mm->context.flush_mm bit.
Solution:     Add a spinlock to serialize __tlb_flush_mm_lazy, and fix
              the ordering of mm_cpumask reset.
Reproduction: TLB flushing bugs are hard to hit, there are no known steps
              to reproduce.

Upstream-Description:

              s390/mm: no local TLB flush for clearing-by-ASCE IDTE

              The local-clearing control of the IDTE instruction does not have any effect
              for the clearing-by-ASCE operation. Only the invalidation-and-clearing
              operation respects the local-clearing bit.

              Remove __tlb_flush_idte_local and simplify the batched TLB flushing code.

              Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
              Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>


Signed-off-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>
Acked-by: Johannes Thumshirn <jthumshirn@suse.de>
---
 arch/s390/include/asm/tlbflush.h |   46 ++++++++-------------------------------
 1 file changed, 10 insertions(+), 36 deletions(-)

--- a/arch/s390/include/asm/tlbflush.h
+++ b/arch/s390/include/asm/tlbflush.h
@@ -26,17 +26,6 @@ static inline void __tlb_flush_idte(unsi
 		: : "a" (2048), "a" (asce) : "cc");
 }
 
-/*
- * Flush TLB entries for a specific ASCE on the local CPU
- */
-static inline void __tlb_flush_idte_local(unsigned long asce)
-{
-	/* Local TLB flush for the mm */
-	asm volatile(
-		"	.insn	rrf,0xb98e0000,0,%0,%1,1"
-		: : "a" (2048), "a" (asce) : "cc");
-}
-
 #ifdef CONFIG_SMP
 void smp_ptlb_all(void);
 
@@ -79,24 +68,15 @@ static inline void __tlb_flush_full(stru
  */
 static inline void __tlb_flush_asce(struct mm_struct *mm, unsigned long asce)
 {
-	int active, count;
-
 	preempt_disable();
-	active = (mm == current->active_mm) ? 1 : 0;
-	count = atomic_add_return(0x10000, &mm->context.attach_count);
-	if (MACHINE_HAS_TLB_LC && (count & 0xffff) <= active &&
-	    cpumask_equal(mm_cpumask(mm), cpumask_of(smp_processor_id()))) {
-		__tlb_flush_idte_local(asce);
-	} else {
-		if (MACHINE_HAS_IDTE)
-			__tlb_flush_idte(asce);
-		else
-			__tlb_flush_global();
-		/* Reset TLB flush mask */
-		if (MACHINE_HAS_TLB_LC)
-			cpumask_copy(mm_cpumask(mm),
-				     &mm->context.cpu_attach_mask);
-	}
+	atomic_add(0x10000, &mm->context.attach_count);
+	if (MACHINE_HAS_IDTE)
+		__tlb_flush_idte(asce);
+	else
+		__tlb_flush_global();
+	/* Reset TLB flush mask */
+	if (MACHINE_HAS_TLB_LC)
+		cpumask_copy(mm_cpumask(mm), &mm->context.cpu_attach_mask);
 	atomic_sub(0x10000, &mm->context.attach_count);
 	preempt_enable();
 }
@@ -117,18 +97,12 @@ static inline void __tlb_flush_kernel(vo
  */
 static inline void __tlb_flush_asce(struct mm_struct *mm, unsigned long asce)
 {
-	if (MACHINE_HAS_TLB_LC)
-		__tlb_flush_idte_local(asce);
-	else
-		__tlb_flush_local();
+	__tlb_flush_local();
 }
 
 static inline void __tlb_flush_kernel(void)
 {
-	if (MACHINE_HAS_TLB_LC)
-		__tlb_flush_idte_local(init_mm.context.asce);
-	else
-		__tlb_flush_local();
+	__tlb_flush_local();
 }
 #endif
 
