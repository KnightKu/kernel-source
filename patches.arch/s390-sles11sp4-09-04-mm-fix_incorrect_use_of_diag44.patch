From: Maxim Samoylov <max7255@linux.vnet.ibm.com>
Subject: kernel: fix incorrect use of DIAG44 in continue_trylock_relax()
Patch-mainline: Never, SLES 11 only
References: bnc#946214, LTC#132100

Description:  kernel: fix incorrect use of DIAG44 in continue_trylock_relax()
Symptom:      High lpar mgm value observed in hyptop, elevated PR/SM overhead
Problem:      There is an issue with the "adaptive spinlock" implementation in
              __lock_page() in some distributions.
              If kernel thread observed that needed shared page is locked,
              it started to spin for 2 jiffies waiting for page to be unlocked
              instead of going to sleep.
              While waiting for unlock, cpu_relax() function is used to delay
              execution in a loop.
              On s390x cpu_relax() just executes DIAG 44 right away, which is
              probably too "heavy handed" for __lock_page(), and may manifest
              as elevated PR/SM overhead in some situations.
Solution:     Replace cpu_relax() with arch_mutex_cpu_relax()
Reproduction: Run perf bench futex hash test, which stresses shared futexes.
              1) Obtain recent version of perf (shipped with upstream Linux
                 kernel source v4.1.10) and build it.
                  #cd linux-4.1.10/tools/perf; make
              2) Run perf
                  #linux-4.1.10/tools/perf/perf bench futex hash -S -f 1
              3) Verify that hyptop reports elevated mgm time associated
                 with the current system while perf bench is running


Signed-off-by: Maxim Samoylov <max7255@linux.vnet.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 mm/filemap.c |    4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -34,6 +34,8 @@
 #include <linux/hardirq.h> /* for BUG_ON(!in_atomic()) only */
 #include <linux/memcontrol.h>
 #include <linux/cleancache.h>
+#include <linux/mutex.h>
+#include <asm/mutex.h>
 #ifndef __GENKSYMS__
 #include <linux/hugetlb.h>
 #endif
@@ -689,7 +691,7 @@ enum trylock_page_status {
 /* Returns true if spinning should continue */
 static bool continue_trylock_relax(unsigned long expires)
 {
-	cpu_relax();
+	arch_mutex_cpu_relax();
 	return !(need_resched() || time_after(jiffies, expires));
 }
 #else
