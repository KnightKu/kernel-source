From b378fa7ef60aa1fbc860955082e2512af50237ac Mon Sep 17 00:00:00 2001
From: Russell King <rmk+kernel@arm.linux.org.uk>
Date: Tue, 3 Nov 2015 14:51:03 +0000
Subject: [PATCH 374/447] tty: amba-pl011: convert accessor functions to take
 uart_amba_port

Git-commit: b2a4e24c2efd76a2c25478836fb35951e00d5b52
Patch-mainline: v4.5-rc1
References: fate#320512

Convert the new accessor functions to take the uart_amba_port instead
of the port base address.

Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
Reviewed-by: Peter Hurley <peter@hurleysoftware.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Mian Yousaf Kaukab <yousaf.kaukab@suse.com>
---
 drivers/tty/serial/amba-pl011.c | 199 ++++++++++++++++++++--------------------
 1 file changed, 97 insertions(+), 102 deletions(-)

diff --git a/drivers/tty/serial/amba-pl011.c b/drivers/tty/serial/amba-pl011.c
index 47e517b..11e1dc5 100644
--- a/drivers/tty/serial/amba-pl011.c
+++ b/drivers/tty/serial/amba-pl011.c
@@ -184,14 +184,16 @@ struct uart_amba_port {
 #endif
 };
 
-static unsigned int pl011_read(void __iomem *base, unsigned int reg)
+static unsigned int pl011_read(const struct uart_amba_port *uap,
+	unsigned int reg)
 {
-	return readw(base + reg);
+	return readw(uap->port.membase + reg);
 }
 
-static void pl011_write(unsigned int val, void __iomem *base, unsigned int reg)
+static void pl011_write(unsigned int val, const struct uart_amba_port *uap,
+	unsigned int reg)
 {
-	writew(val, base + reg);
+	writew(val, uap->port.membase + reg);
 }
 
 /*
@@ -206,13 +208,12 @@ static int pl011_fifo_to_tty(struct uart_amba_port *uap)
 	int fifotaken = 0;
 
 	while (max_count--) {
-		status = pl011_read(uap->port.membase, UART01x_FR);
+		status = pl011_read(uap, UART01x_FR);
 		if (status & UART01x_FR_RXFE)
 			break;
 
 		/* Take chars from the FIFO and update status */
-		ch = pl011_read(uap->port.membase, UART01x_DR) |
-			UART_DUMMY_DR_RX;
+		ch = pl011_read(uap, UART01x_DR) | UART_DUMMY_DR_RX;
 		flag = TTY_NORMAL;
 		uap->port.icount.rx++;
 		fifotaken++;
@@ -448,7 +449,7 @@ static void pl011_dma_tx_callback(void *data)
 
 	dmacr = uap->dmacr;
 	uap->dmacr = dmacr & ~UART011_TXDMAE;
-	pl011_write(uap->dmacr, uap->port.membase, UART011_DMACR);
+	pl011_write(uap->dmacr, uap, UART011_DMACR);
 
 	/*
 	 * If TX DMA was disabled, it means that we've stopped the DMA for
@@ -562,7 +563,7 @@ static int pl011_dma_tx_refill(struct uart_amba_port *uap)
 	dma_dev->device_issue_pending(chan);
 
 	uap->dmacr |= UART011_TXDMAE;
-	pl011_write(uap->dmacr, uap->port.membase, UART011_DMACR);
+	pl011_write(uap->dmacr, uap, UART011_DMACR);
 	uap->dmatx.queued = true;
 
 	/*
@@ -598,9 +599,9 @@ static bool pl011_dma_tx_irq(struct uart_amba_port *uap)
 	 */
 	if (uap->dmatx.queued) {
 		uap->dmacr |= UART011_TXDMAE;
-		pl011_write(uap->dmacr, uap->port.membase, UART011_DMACR);
+		pl011_write(uap->dmacr, uap, UART011_DMACR);
 		uap->im &= ~UART011_TXIM;
-		pl011_write(uap->im, uap->port.membase, UART011_IMSC);
+		pl011_write(uap->im, uap, UART011_IMSC);
 		return true;
 	}
 
@@ -610,7 +611,7 @@ static bool pl011_dma_tx_irq(struct uart_amba_port *uap)
 	 */
 	if (pl011_dma_tx_refill(uap) > 0) {
 		uap->im &= ~UART011_TXIM;
-		pl011_write(uap->im, uap->port.membase, UART011_IMSC);
+		pl011_write(uap->im, uap, UART011_IMSC);
 		return true;
 	}
 	return false;
@@ -624,7 +625,7 @@ static inline void pl011_dma_tx_stop(struct uart_amba_port *uap)
 {
 	if (uap->dmatx.queued) {
 		uap->dmacr &= ~UART011_TXDMAE;
-		pl011_write(uap->dmacr, uap->port.membase, UART011_DMACR);
+		pl011_write(uap->dmacr, uap, UART011_DMACR);
 	}
 }
 
@@ -650,14 +651,12 @@ static inline bool pl011_dma_tx_start(struct uart_amba_port *uap)
 		if (!uap->dmatx.queued) {
 			if (pl011_dma_tx_refill(uap) > 0) {
 				uap->im &= ~UART011_TXIM;
-				pl011_write(uap->im, uap->port.membase,
-					    UART011_IMSC);
+				pl011_write(uap->im, uap, UART011_IMSC);
 			} else
 				ret = false;
 		} else if (!(uap->dmacr & UART011_TXDMAE)) {
 			uap->dmacr |= UART011_TXDMAE;
-			pl011_write(uap->dmacr, uap->port.membase,
-				    UART011_DMACR);
+			pl011_write(uap->dmacr, uap, UART011_DMACR);
 		}
 		return ret;
 	}
@@ -668,9 +667,9 @@ static inline bool pl011_dma_tx_start(struct uart_amba_port *uap)
 	 */
 	dmacr = uap->dmacr;
 	uap->dmacr &= ~UART011_TXDMAE;
-	pl011_write(uap->dmacr, uap->port.membase, UART011_DMACR);
+	pl011_write(uap->dmacr, uap, UART011_DMACR);
 
-	if (pl011_read(uap->port.membase, UART01x_FR) & UART01x_FR_TXFF) {
+	if (pl011_read(uap, UART01x_FR) & UART01x_FR_TXFF) {
 		/*
 		 * No space in the FIFO, so enable the transmit interrupt
 		 * so we know when there is space.  Note that once we've
@@ -679,13 +678,13 @@ static inline bool pl011_dma_tx_start(struct uart_amba_port *uap)
 		return false;
 	}
 
-	pl011_write(uap->port.x_char, uap->port.membase, UART01x_DR);
+	pl011_write(uap->port.x_char, uap, UART01x_DR);
 	uap->port.icount.tx++;
 	uap->port.x_char = 0;
 
 	/* Success - restore the DMA state */
 	uap->dmacr = dmacr;
-	pl011_write(dmacr, uap->port.membase, UART011_DMACR);
+	pl011_write(dmacr, uap, UART011_DMACR);
 
 	return true;
 }
@@ -713,7 +712,7 @@ __acquires(&uap->port.lock)
 			     DMA_TO_DEVICE);
 		uap->dmatx.queued = false;
 		uap->dmacr &= ~UART011_TXDMAE;
-		pl011_write(uap->dmacr, uap->port.membase, UART011_DMACR);
+		pl011_write(uap->dmacr, uap, UART011_DMACR);
 	}
 }
 
@@ -753,11 +752,11 @@ static int pl011_dma_rx_trigger_dma(struct uart_amba_port *uap)
 	dma_async_issue_pending(rxchan);
 
 	uap->dmacr |= UART011_RXDMAE;
-	pl011_write(uap->dmacr, uap->port.membase, UART011_DMACR);
+	pl011_write(uap->dmacr, uap, UART011_DMACR);
 	uap->dmarx.running = true;
 
 	uap->im &= ~UART011_RXIM;
-	pl011_write(uap->im, uap->port.membase, UART011_IMSC);
+	pl011_write(uap->im, uap, UART011_IMSC);
 
 	return 0;
 }
@@ -816,7 +815,7 @@ static void pl011_dma_rx_chars(struct uart_amba_port *uap,
 	if (dma_count == pending && readfifo) {
 		/* Clear any error flags */
 		pl011_write(UART011_OEIS | UART011_BEIS | UART011_PEIS |
-			    UART011_FEIS, uap->port.membase, UART011_ICR);
+			    UART011_FEIS, uap, UART011_ICR);
 
 		/*
 		 * If we read all the DMA'd characters, and we had an
@@ -864,7 +863,7 @@ static void pl011_dma_rx_irq(struct uart_amba_port *uap)
 
 	/* Disable RX DMA - incoming data will wait in the FIFO */
 	uap->dmacr &= ~UART011_RXDMAE;
-	pl011_write(uap->dmacr, uap->port.membase, UART011_DMACR);
+	pl011_write(uap->dmacr, uap, UART011_DMACR);
 	uap->dmarx.running = false;
 
 	pending = sgbuf->sg.length - state.residue;
@@ -884,7 +883,7 @@ static void pl011_dma_rx_irq(struct uart_amba_port *uap)
 		dev_dbg(uap->port.dev, "could not retrigger RX DMA job "
 			"fall back to interrupt mode\n");
 		uap->im |= UART011_RXIM;
-		pl011_write(uap->im, uap->port.membase, UART011_IMSC);
+		pl011_write(uap->im, uap, UART011_IMSC);
 	}
 }
 
@@ -932,7 +931,7 @@ static void pl011_dma_rx_callback(void *data)
 		dev_dbg(uap->port.dev, "could not retrigger RX DMA job "
 			"fall back to interrupt mode\n");
 		uap->im |= UART011_RXIM;
-		pl011_write(uap->im, uap->port.membase, UART011_IMSC);
+		pl011_write(uap->im, uap, UART011_IMSC);
 	}
 }
 
@@ -945,7 +944,7 @@ static inline void pl011_dma_rx_stop(struct uart_amba_port *uap)
 {
 	/* FIXME.  Just disable the DMA enable */
 	uap->dmacr &= ~UART011_RXDMAE;
-	pl011_write(uap->dmacr, uap->port.membase, UART011_DMACR);
+	pl011_write(uap->dmacr, uap, UART011_DMACR);
 }
 
 /*
@@ -989,7 +988,7 @@ static void pl011_dma_rx_poll(unsigned long args)
 		spin_lock_irqsave(&uap->port.lock, flags);
 		pl011_dma_rx_stop(uap);
 		uap->im |= UART011_RXIM;
-		pl011_write(uap->im, uap->port.membase, UART011_IMSC);
+		pl011_write(uap->im, uap, UART011_IMSC);
 		spin_unlock_irqrestore(&uap->port.lock, flags);
 
 		uap->dmarx.running = false;
@@ -1051,7 +1050,7 @@ static void pl011_dma_startup(struct uart_amba_port *uap)
 skip_rx:
 	/* Turn on DMA error (RX/TX will be enabled on demand) */
 	uap->dmacr |= UART011_DMAONERR;
-	pl011_write(uap->dmacr, uap->port.membase, UART011_DMACR);
+	pl011_write(uap->dmacr, uap, UART011_DMACR);
 
 	/*
 	 * ST Micro variants has some specific dma burst threshold
@@ -1060,7 +1059,7 @@ skip_rx:
 	 */
 	if (uap->vendor->dma_threshold)
 		pl011_write(ST_UART011_DMAWM_RX_16 | ST_UART011_DMAWM_TX_16,
-			    uap->port.membase, ST_UART011_DMAWM);
+			    uap, ST_UART011_DMAWM);
 
 	if (uap->using_rx_dma) {
 		if (pl011_dma_rx_trigger_dma(uap))
@@ -1085,12 +1084,12 @@ static void pl011_dma_shutdown(struct uart_amba_port *uap)
 		return;
 
 	/* Disable RX and TX DMA */
-	while (pl011_read(uap->port.membase, UART01x_FR) & UART01x_FR_BUSY)
+	while (pl011_read(uap, UART01x_FR) & UART01x_FR_BUSY)
 		barrier();
 
 	spin_lock_irq(&uap->port.lock);
 	uap->dmacr &= ~(UART011_DMAONERR | UART011_RXDMAE | UART011_TXDMAE);
-	pl011_write(uap->dmacr, uap->port.membase, UART011_DMACR);
+	pl011_write(uap->dmacr, uap, UART011_DMACR);
 	spin_unlock_irq(&uap->port.lock);
 
 	if (uap->using_tx_dma) {
@@ -1191,7 +1190,7 @@ static void pl011_stop_tx(struct uart_port *port)
 	    container_of(port, struct uart_amba_port, port);
 
 	uap->im &= ~UART011_TXIM;
-	pl011_write(uap->im, uap->port.membase, UART011_IMSC);
+	pl011_write(uap->im, uap, UART011_IMSC);
 	pl011_dma_tx_stop(uap);
 }
 
@@ -1201,7 +1200,7 @@ static void pl011_tx_chars(struct uart_amba_port *uap, bool from_irq);
 static void pl011_start_tx_pio(struct uart_amba_port *uap)
 {
 	uap->im |= UART011_TXIM;
-	pl011_write(uap->im, uap->port.membase, UART011_IMSC);
+	pl011_write(uap->im, uap, UART011_IMSC);
 	pl011_tx_chars(uap, false);
 }
 
@@ -1221,7 +1220,7 @@ static void pl011_stop_rx(struct uart_port *port)
 
 	uap->im &= ~(UART011_RXIM|UART011_RTIM|UART011_FEIM|
 		     UART011_PEIM|UART011_BEIM|UART011_OEIM);
-	pl011_write(uap->im, uap->port.membase, UART011_IMSC);
+	pl011_write(uap->im, uap, UART011_IMSC);
 
 	pl011_dma_rx_stop(uap);
 }
@@ -1232,7 +1231,7 @@ static void pl011_enable_ms(struct uart_port *port)
 	    container_of(port, struct uart_amba_port, port);
 
 	uap->im |= UART011_RIMIM|UART011_CTSMIM|UART011_DCDMIM|UART011_DSRMIM;
-	pl011_write(uap->im, uap->port.membase, UART011_IMSC);
+	pl011_write(uap->im, uap, UART011_IMSC);
 }
 
 static void pl011_rx_chars(struct uart_amba_port *uap)
@@ -1252,7 +1251,7 @@ __acquires(&uap->port.lock)
 			dev_dbg(uap->port.dev, "could not trigger RX DMA job "
 				"fall back to interrupt mode again\n");
 			uap->im |= UART011_RXIM;
-			pl011_write(uap->im, uap->port.membase, UART011_IMSC);
+			pl011_write(uap->im, uap, UART011_IMSC);
 		} else {
 #ifdef CONFIG_DMA_ENGINE
 			/* Start Rx DMA poll */
@@ -1273,10 +1272,10 @@ static bool pl011_tx_char(struct uart_amba_port *uap, unsigned char c,
 			  bool from_irq)
 {
 	if (unlikely(!from_irq) &&
-	    pl011_read(uap->port.membase, UART01x_FR) & UART01x_FR_TXFF)
+	    pl011_read(uap, UART01x_FR) & UART01x_FR_TXFF)
 		return false; /* unable to transmit character */
 
-	pl011_write(c, uap->port.membase, UART01x_DR);
+	pl011_write(c, uap, UART01x_DR);
 	uap->port.icount.tx++;
 
 	return true;
@@ -1323,8 +1322,7 @@ static void pl011_modem_status(struct uart_amba_port *uap)
 {
 	unsigned int status, delta;
 
-	status = pl011_read(uap->port.membase, UART01x_FR);
-	status &= UART01x_FR_MODEM_ANY;
+	status = pl011_read(uap, UART01x_FR) & UART01x_FR_MODEM_ANY;
 
 	delta = status ^ uap->old_status;
 	uap->old_status = status;
@@ -1352,15 +1350,15 @@ static void check_apply_cts_event_workaround(struct uart_amba_port *uap)
 		return;
 
 	/* workaround to make sure that all bits are unlocked.. */
-	pl011_write(0x00, uap->port.membase, UART011_ICR);
+	pl011_write(0x00, uap, UART011_ICR);
 
 	/*
 	 * WA: introduce 26ns(1 uart clk) delay before W1C;
 	 * single apb access will incur 2 pclk(133.12Mhz) delay,
 	 * so add 2 dummy reads
 	 */
-	dummy_read = pl011_read(uap->port.membase, UART011_ICR);
-	dummy_read = pl011_read(uap->port.membase, UART011_ICR);
+	dummy_read = pl011_read(uap, UART011_ICR);
+	dummy_read = pl011_read(uap, UART011_ICR);
 }
 
 static irqreturn_t pl011_int(int irq, void *dev_id)
@@ -1372,15 +1370,15 @@ static irqreturn_t pl011_int(int irq, void *dev_id)
 	int handled = 0;
 
 	spin_lock_irqsave(&uap->port.lock, flags);
-	imsc = pl011_read(uap->port.membase, UART011_IMSC);
-	status = pl011_read(uap->port.membase, UART011_RIS) & imsc;
+	imsc = pl011_read(uap, UART011_IMSC);
+	status = pl011_read(uap, UART011_RIS) & imsc;
 	if (status) {
 		do {
 			check_apply_cts_event_workaround(uap);
 
 			pl011_write(status & ~(UART011_TXIS|UART011_RTIS|
 					       UART011_RXIS),
-				    uap->port.membase, UART011_ICR);
+				    uap, UART011_ICR);
 
 			if (status & (UART011_RTIS|UART011_RXIS)) {
 				if (pl011_dma_rx_running(uap))
@@ -1397,7 +1395,7 @@ static irqreturn_t pl011_int(int irq, void *dev_id)
 			if (pass_counter-- == 0)
 				break;
 
-			status = pl011_read(uap->port.membase, UART011_RIS) & imsc;
+			status = pl011_read(uap, UART011_RIS) & imsc;
 		} while (status != 0);
 		handled = 1;
 	}
@@ -1411,7 +1409,7 @@ static unsigned int pl011_tx_empty(struct uart_port *port)
 {
 	struct uart_amba_port *uap =
 	    container_of(port, struct uart_amba_port, port);
-	unsigned int status = pl011_read(uap->port.membase, UART01x_FR);
+	unsigned int status = pl011_read(uap, UART01x_FR);
 	return status & (UART01x_FR_BUSY|UART01x_FR_TXFF) ? 0 : TIOCSER_TEMT;
 }
 
@@ -1420,7 +1418,7 @@ static unsigned int pl011_get_mctrl(struct uart_port *port)
 	struct uart_amba_port *uap =
 	    container_of(port, struct uart_amba_port, port);
 	unsigned int result = 0;
-	unsigned int status = pl011_read(uap->port.membase, UART01x_FR);
+	unsigned int status = pl011_read(uap, UART01x_FR);
 
 #define TIOCMBIT(uartbit, tiocmbit)	\
 	if (status & uartbit)		\
@@ -1440,7 +1438,7 @@ static void pl011_set_mctrl(struct uart_port *port, unsigned int mctrl)
 	    container_of(port, struct uart_amba_port, port);
 	unsigned int cr;
 
-	cr = pl011_read(uap->port.membase, UART011_CR);
+	cr = pl011_read(uap, UART011_CR);
 
 #define	TIOCMBIT(tiocmbit, uartbit)		\
 	if (mctrl & tiocmbit)		\
@@ -1460,7 +1458,7 @@ static void pl011_set_mctrl(struct uart_port *port, unsigned int mctrl)
 	}
 #undef TIOCMBIT
 
-	pl011_write(cr, uap->port.membase, UART011_CR);
+	pl011_write(cr, uap, UART011_CR);
 }
 
 static void pl011_break_ctl(struct uart_port *port, int break_state)
@@ -1471,12 +1469,12 @@ static void pl011_break_ctl(struct uart_port *port, int break_state)
 	unsigned int lcr_h;
 
 	spin_lock_irqsave(&uap->port.lock, flags);
-	lcr_h = pl011_read(uap->port.membase, uap->lcrh_tx);
+	lcr_h = pl011_read(uap, uap->lcrh_tx);
 	if (break_state == -1)
 		lcr_h |= UART01x_LCRH_BRK;
 	else
 		lcr_h &= ~UART01x_LCRH_BRK;
-	pl011_write(lcr_h, uap->port.membase, uap->lcrh_tx);
+	pl011_write(lcr_h, uap, uap->lcrh_tx);
 	spin_unlock_irqrestore(&uap->port.lock, flags);
 }
 
@@ -1486,9 +1484,8 @@ static void pl011_quiesce_irqs(struct uart_port *port)
 {
 	struct uart_amba_port *uap =
 	    container_of(port, struct uart_amba_port, port);
-	unsigned char __iomem *regs = uap->port.membase;
 
-	pl011_write(pl011_read(regs, UART011_MIS), regs, UART011_ICR);
+	pl011_write(pl011_read(uap, UART011_MIS), uap, UART011_ICR);
 	/*
 	 * There is no way to clear TXIM as this is "ready to transmit IRQ", so
 	 * we simply mask it. start_tx() will unmask it.
@@ -1502,8 +1499,8 @@ static void pl011_quiesce_irqs(struct uart_port *port)
 	 * (including tx queue), so we're also fine with start_tx()'s caller
 	 * side.
 	 */
-	pl011_write(pl011_read(regs, UART011_IMSC) & ~UART011_TXIM,
-		    regs, UART011_IMSC);
+	pl011_write(pl011_read(uap, UART011_IMSC) & ~UART011_TXIM, uap,
+		    UART011_IMSC);
 }
 
 static int pl011_get_poll_char(struct uart_port *port)
@@ -1518,11 +1515,11 @@ static int pl011_get_poll_char(struct uart_port *port)
 	 */
 	pl011_quiesce_irqs(port);
 
-	status = pl011_read(uap->port.membase, UART01x_FR);
+	status = pl011_read(uap, UART01x_FR);
 	if (status & UART01x_FR_RXFE)
 		return NO_POLL_CHAR;
 
-	return pl011_read(uap->port.membase, UART01x_DR);
+	return pl011_read(uap, UART01x_DR);
 }
 
 static void pl011_put_poll_char(struct uart_port *port,
@@ -1531,10 +1528,10 @@ static void pl011_put_poll_char(struct uart_port *port,
 	struct uart_amba_port *uap =
 	    container_of(port, struct uart_amba_port, port);
 
-	while (pl011_read(uap->port.membase, UART01x_FR) & UART01x_FR_TXFF)
+	while (pl011_read(uap, UART01x_FR) & UART01x_FR_TXFF)
 		barrier();
 
-	pl011_write(ch, uap->port.membase, UART01x_DR);
+	pl011_write(ch, uap, UART01x_DR);
 }
 
 #endif /* CONFIG_CONSOLE_POLL */
@@ -1560,15 +1557,14 @@ static int pl011_hwinit(struct uart_port *port)
 	/* Clear pending error and receive interrupts */
 	pl011_write(UART011_OEIS | UART011_BEIS | UART011_PEIS |
 		    UART011_FEIS | UART011_RTIS | UART011_RXIS,
-		    uap->port.membase, UART011_ICR);
+		    uap, UART011_ICR);
 
 	/*
 	 * Save interrupts enable mask, and enable RX interrupts in case if
 	 * the interrupt is used for NMI entry.
 	 */
-	uap->im = pl011_read(uap->port.membase, UART011_IMSC);
-	pl011_write(UART011_RTIM | UART011_RXIM, uap->port.membase,
-		    UART011_IMSC);
+	uap->im = pl011_read(uap, UART011_IMSC);
+	pl011_write(UART011_RTIM | UART011_RXIM, uap, UART011_IMSC);
 
 	if (dev_get_platdata(uap->port.dev)) {
 		struct amba_pl011_data *plat;
@@ -1582,7 +1578,7 @@ static int pl011_hwinit(struct uart_port *port)
 
 static void pl011_write_lcr_h(struct uart_amba_port *uap, unsigned int lcr_h)
 {
-	pl011_write(lcr_h, uap->port.membase, uap->lcrh_rx);
+	pl011_write(lcr_h, uap, uap->lcrh_rx);
 	if (uap->lcrh_rx != uap->lcrh_tx) {
 		int i;
 		/*
@@ -1590,14 +1586,14 @@ static void pl011_write_lcr_h(struct uart_amba_port *uap, unsigned int lcr_h)
 		 * to get this delay write read only register 10 times
 		 */
 		for (i = 0; i < 10; ++i)
-			pl011_write(0xff, uap->port.membase, UART011_MIS);
-		pl011_write(lcr_h, uap->port.membase, uap->lcrh_tx);
+			pl011_write(0xff, uap, UART011_MIS);
+		pl011_write(lcr_h, uap, uap->lcrh_tx);
 	}
 }
 
 static int pl011_allocate_irq(struct uart_amba_port *uap)
 {
-	pl011_write(uap->im, uap->port.membase, UART011_IMSC);
+	pl011_write(uap->im, uap, UART011_IMSC);
 
 	return request_irq(uap->port.irq, pl011_int, 0, "uart-pl011", uap);
 }
@@ -1612,12 +1608,11 @@ static void pl011_enable_interrupts(struct uart_amba_port *uap)
 	spin_lock_irq(&uap->port.lock);
 
 	/* Clear out any spuriously appearing RX interrupts */
-	pl011_write(UART011_RTIS | UART011_RXIS, uap->port.membase,
-	            UART011_ICR);
+	pl011_write(UART011_RTIS | UART011_RXIS, uap, UART011_ICR);
 	uap->im = UART011_RTIM;
 	if (!pl011_dma_rx_running(uap))
 		uap->im |= UART011_RXIM;
-	pl011_write(uap->im, uap->port.membase, UART011_IMSC);
+	pl011_write(uap->im, uap, UART011_IMSC);
 	spin_unlock_irq(&uap->port.lock);
 }
 
@@ -1636,21 +1631,21 @@ static int pl011_startup(struct uart_port *port)
 	if (retval)
 		goto clk_dis;
 
-	pl011_write(uap->vendor->ifls, uap->port.membase, UART011_IFLS);
+	pl011_write(uap->vendor->ifls, uap, UART011_IFLS);
 
 	spin_lock_irq(&uap->port.lock);
 
 	/* restore RTS and DTR */
 	cr = uap->old_cr & (UART011_CR_RTS | UART011_CR_DTR);
 	cr |= UART01x_CR_UARTEN | UART011_CR_RXE | UART011_CR_TXE;
-	pl011_write(cr, uap->port.membase, UART011_CR);
+	pl011_write(cr, uap, UART011_CR);
 
 	spin_unlock_irq(&uap->port.lock);
 
 	/*
 	 * initialise the old status of the modem signals
 	 */
-	uap->old_status = pl011_read(uap->port.membase, UART01x_FR) & UART01x_FR_MODEM_ANY;
+	uap->old_status = pl011_read(uap, UART01x_FR) & UART01x_FR_MODEM_ANY;
 
 	/* Startup DMA */
 	pl011_dma_startup(uap);
@@ -1691,9 +1686,9 @@ static void pl011_shutdown_channel(struct uart_amba_port *uap,
 {
       unsigned long val;
 
-      val = pl011_read(uap->port.membase, lcrh);
+      val = pl011_read(uap, lcrh);
       val &= ~(UART01x_LCRH_BRK | UART01x_LCRH_FEN);
-      pl011_write(val, uap->port.membase, lcrh);
+      pl011_write(val, uap, lcrh);
 }
 
 /*
@@ -1707,11 +1702,11 @@ static void pl011_disable_uart(struct uart_amba_port *uap)
 
 	uap->autorts = false;
 	spin_lock_irq(&uap->port.lock);
-	cr = pl011_read(uap->port.membase, UART011_CR);
+	cr = pl011_read(uap, UART011_CR);
 	uap->old_cr = cr;
 	cr &= UART011_CR_RTS | UART011_CR_DTR;
 	cr |= UART01x_CR_UARTEN | UART011_CR_TXE;
-	pl011_write(cr, uap->port.membase, UART011_CR);
+	pl011_write(cr, uap, UART011_CR);
 	spin_unlock_irq(&uap->port.lock);
 
 	/*
@@ -1728,8 +1723,8 @@ static void pl011_disable_interrupts(struct uart_amba_port *uap)
 
 	/* mask all interrupts and clear all pending ones */
 	uap->im = 0;
-	pl011_write(uap->im, uap->port.membase, UART011_IMSC);
-	pl011_write(0xffff, uap->port.membase, UART011_ICR);
+	pl011_write(uap->im, uap, UART011_IMSC);
+	pl011_write(0xffff, uap, UART011_ICR);
 
 	spin_unlock_irq(&uap->port.lock);
 }
@@ -1881,8 +1876,8 @@ pl011_set_termios(struct uart_port *port, struct ktermios *termios,
 		pl011_enable_ms(port);
 
 	/* first, disable everything */
-	old_cr = pl011_read(port->membase, UART011_CR);
-	pl011_write(0, port->membase, UART011_CR);
+	old_cr = pl011_read(uap, UART011_CR);
+	pl011_write(0, uap, UART011_CR);
 
 	if (termios->c_cflag & CRTSCTS) {
 		if (old_cr & UART011_CR_RTS)
@@ -1915,8 +1910,8 @@ pl011_set_termios(struct uart_port *port, struct ktermios *termios,
 			quot -= 2;
 	}
 	/* Set baud rate */
-	pl011_write(quot & 0x3f, port->membase, UART011_FBRD);
-	pl011_write(quot >> 6, port->membase, UART011_IBRD);
+	pl011_write(quot & 0x3f, uap, UART011_FBRD);
+	pl011_write(quot >> 6, uap, UART011_IBRD);
 
 	/*
 	 * ----------v----------v----------v----------v-----
@@ -1925,7 +1920,7 @@ pl011_set_termios(struct uart_port *port, struct ktermios *termios,
 	 * ----------^----------^----------^----------^-----
 	 */
 	pl011_write_lcr_h(uap, lcr_h);
-	pl011_write(old_cr, port->membase, UART011_CR);
+	pl011_write(old_cr, uap, UART011_CR);
 
 	spin_unlock_irqrestore(&port->lock, flags);
 }
@@ -2066,9 +2061,9 @@ static void pl011_console_putchar(struct uart_port *port, int ch)
 	struct uart_amba_port *uap =
 	    container_of(port, struct uart_amba_port, port);
 
-	while (pl011_read(uap->port.membase, UART01x_FR) & UART01x_FR_TXFF)
+	while (pl011_read(uap, UART01x_FR) & UART01x_FR_TXFF)
 		barrier();
-	pl011_write(ch, uap->port.membase, UART01x_DR);
+	pl011_write(ch, uap, UART01x_DR);
 }
 
 static void
@@ -2093,10 +2088,10 @@ pl011_console_write(struct console *co, const char *s, unsigned int count)
 	 *	First save the CR then disable the interrupts
 	 */
 	if (!uap->vendor->always_enabled) {
-		old_cr = pl011_read(uap->port.membase, UART011_CR);
+		old_cr = pl011_read(uap, UART011_CR);
 		new_cr = old_cr & ~UART011_CR_CTSEN;
 		new_cr |= UART01x_CR_UARTEN | UART011_CR_TXE;
-		pl011_write(new_cr, uap->port.membase, UART011_CR);
+		pl011_write(new_cr, uap, UART011_CR);
 	}
 
 	uart_console_write(&uap->port, s, count, pl011_console_putchar);
@@ -2106,10 +2101,10 @@ pl011_console_write(struct console *co, const char *s, unsigned int count)
 	 *	and restore the TCR
 	 */
 	do {
-		status = pl011_read(uap->port.membase, UART01x_FR);
+		status = pl011_read(uap, UART01x_FR);
 	} while (status & UART01x_FR_BUSY);
 	if (!uap->vendor->always_enabled)
-		pl011_write(old_cr, uap->port.membase, UART011_CR);
+		pl011_write(old_cr, uap, UART011_CR);
 
 	if (locked)
 		spin_unlock(&uap->port.lock);
@@ -2122,10 +2117,10 @@ static void __init
 pl011_console_get_options(struct uart_amba_port *uap, int *baud,
 			     int *parity, int *bits)
 {
-	if (pl011_read(uap->port.membase, UART011_CR) & UART01x_CR_UARTEN) {
+	if (pl011_read(uap, UART011_CR) & UART01x_CR_UARTEN) {
 		unsigned int lcr_h, ibrd, fbrd;
 
-		lcr_h = pl011_read(uap->port.membase, uap->lcrh_tx);
+		lcr_h = pl011_read(uap, uap->lcrh_tx);
 
 		*parity = 'n';
 		if (lcr_h & UART01x_LCRH_PEN) {
@@ -2140,13 +2135,13 @@ pl011_console_get_options(struct uart_amba_port *uap, int *baud,
 		else
 			*bits = 8;
 
-		ibrd = pl011_read(uap->port.membase, UART011_IBRD);
-		fbrd = pl011_read(uap->port.membase, UART011_FBRD);
+		ibrd = pl011_read(uap, UART011_IBRD);
+		fbrd = pl011_read(uap, UART011_FBRD);
 
 		*baud = uap->port.uartclk * 4 / (64 * ibrd + fbrd);
 
 		if (uap->vendor->oversampling) {
-			if (pl011_read(uap->port.membase, UART011_CR)
+			if (pl011_read(uap, UART011_CR)
 				  & ST_UART011_CR_OVSFACT)
 				*baud *= 2;
 		}
@@ -2402,8 +2397,8 @@ static int pl011_register_port(struct uart_amba_port *uap)
 	int ret;
 
 	/* Ensure interrupts from this UART are masked and cleared */
-	pl011_write(0, uap->port.membase, UART011_IMSC);
-	pl011_write(0xffff, uap->port.membase, UART011_ICR);
+	pl011_write(0, uap, UART011_IMSC);
+	pl011_write(0xffff, uap, UART011_ICR);
 
 	if (!amba_reg.state) {
 		ret = uart_register_driver(&amba_reg);
-- 
2.11.0

