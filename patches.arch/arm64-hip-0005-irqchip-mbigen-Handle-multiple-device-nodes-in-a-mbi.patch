From: MaJun <majun258@huawei.com>
Date: Thu, 17 Mar 2016 16:34:01 +0800
Subject: irqchip/mbigen: Handle multiple device nodes in a mbigen module
Git-commit: ed2a1002d25ccdb6606c8ccb608524118bd30614
Patch-mainline: v4.6-rc1
References: fate#322061

Each mbigen device is represented as a independent platform device. If the
devices belong to the same mbigen hardware module, then the register space for
these devices is the same. That leads to a resource conflict.

The solution for this is to represent the mbigen module as a platform device
and make the mbigen devices subdevices of that. The register space is
associated to the mbigen module and therefor the resource conflict is avoided.

[ tglx: Massaged changelog, cleaned up the code and removed the silly printk ]

Signed-off-by: Ma Jun <majun258@huawei.com>
Cc: mark.rutland@arm.com
Cc: jason@lakedaemon.net
Cc: marc.zyngier@arm.com
Cc: Catalin.Marinas@arm.com
Cc: guohanjun@huawei.com
Cc: Will.Deacon@arm.com
Cc: huxinwei@huawei.com
Cc: lizefan@huawei.com
Cc: dingtianhong@huawei.com
Cc: zhaojunhua@hisilicon.com
Cc: liguozhu@hisilicon.com
Cc: linux-arm-kernel@lists.infradead.org
Link: http://lkml.kernel.org/r/1458203641-17172-3-git-send-email-majun258@huawei.com
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Signed-off-by: Matthias Brugger <mbrugger@suse.com>
---
 drivers/irqchip/irq-mbigen.c | 38 ++++++++++++++++++++++++--------------
 1 file changed, 24 insertions(+), 14 deletions(-)

diff --git a/drivers/irqchip/irq-mbigen.c b/drivers/irqchip/irq-mbigen.c
index 4dd3eb8..d67baa2 100644
--- a/drivers/irqchip/irq-mbigen.c
+++ b/drivers/irqchip/irq-mbigen.c
@@ -239,8 +239,11 @@ static struct irq_domain_ops mbigen_domain_ops = {
 static int mbigen_device_probe(struct platform_device *pdev)
 {
 	struct mbigen_device *mgn_chip;
-	struct resource *res;
+	struct platform_device *child;
 	struct irq_domain *domain;
+	struct device_node *np;
+	struct device *parent;
+	struct resource *res;
 	u32 num_pins;
 
 	mgn_chip = devm_kzalloc(&pdev->dev, sizeof(*mgn_chip), GFP_KERNEL);
@@ -254,23 +257,30 @@ static int mbigen_device_probe(struct platform_device *pdev)
 	if (IS_ERR(mgn_chip->base))
 		return PTR_ERR(mgn_chip->base);
 
-	if (of_property_read_u32(pdev->dev.of_node, "num-pins", &num_pins) < 0) {
-		dev_err(&pdev->dev, "No num-pins property\n");
-		return -EINVAL;
-	}
+	for_each_child_of_node(pdev->dev.of_node, np) {
+		if (!of_property_read_bool(np, "interrupt-controller"))
+			continue;
 
-	domain = platform_msi_create_device_domain(&pdev->dev, num_pins,
-							mbigen_write_msg,
-							&mbigen_domain_ops,
-							mgn_chip);
+		parent = platform_bus_type.dev_root;
+		child = of_platform_device_create(np, NULL, parent);
+		if (IS_ERR(child))
+			return PTR_ERR(child);
 
-	if (!domain)
-		return -ENOMEM;
+		if (of_property_read_u32(child->dev.of_node, "num-pins",
+					 &num_pins) < 0) {
+			dev_err(&pdev->dev, "No num-pins property\n");
+			return -EINVAL;
+		}
+
+		domain = platform_msi_create_device_domain(&child->dev, num_pins,
+							   mbigen_write_msg,
+							   &mbigen_domain_ops,
+							   mgn_chip);
+		if (!domain)
+			return -ENOMEM;
+	}
 
 	platform_set_drvdata(pdev, mgn_chip);
-
-	dev_info(&pdev->dev, "Allocated %d MSIs\n", num_pins);
-
 	return 0;
 }
 
-- 
2.6.6

