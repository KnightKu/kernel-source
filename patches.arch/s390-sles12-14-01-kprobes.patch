From: Heiko Carstens <heiko.carstens@de.ibm.com>
Subject: kernel: kprobes instruction corruption
Patch-mainline: not yet
References: bnc#908057, LTC#119330

Description:  kernel: kprobes instruction corruption
Symptom:      System crashes or data corruption after a kprobe has been hit.
Problem:      The code that copies an instruction for kprobes out of line
              execution used the wrong memory location to figure out the
              length of the instruction. Therefore too few bytes may be
              copied to the out of line execution area which may result in
              random behaviour after the potentially corrupt instruction
              was executed.
Solution:     Use correct memory location to derive instruction length.
Reproduction: -

Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 arch/s390/kernel/kprobes.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

--- a/arch/s390/kernel/kprobes.c
+++ b/arch/s390/kernel/kprobes.c
@@ -219,7 +219,7 @@ static void __kprobes copy_instruction(s
 		ftrace_generate_nop_insn((struct ftrace_insn *)p->ainsn.insn);
 		p->ainsn.is_ftrace_insn = 1;
 	} else
-		memcpy(p->ainsn.insn, p->addr, ((p->opcode >> 14) + 3) & -2);
+		memcpy(p->ainsn.insn, p->addr, ((*p->addr >> 14) + 3) & -2);
 	p->opcode = p->ainsn.insn[0];
 	if (!is_insn_relative_long(p->ainsn.insn))
 		return;
