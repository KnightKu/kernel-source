From: Sebastian Ott <sebott@linux.vnet.ibm.com>
Subject: s390/pci: improve pci hotplug
Patch-mainline: v4.13-rc1
Git-commit: 623bd44d3f277b7bbe16e0e091bd361e75964b5d
References: bnc#1054247, LTC#157731

Description:  PCI: fix hotplug related issues
Symptom:      After serveral cycles of hot-unplug/hotplug the affected
              function stops working or the kernel oopses.
Problem:      Hotplug notifications happen after the fact, meaning it's
              not possible to issue instructions to the function for
              cleanup purposes. Thus we never release the associated
              resources and at some point fail to allocate new ones.
Solution:     During clean up treat some errors as success (e.g. a
              function that's gone can't create an interrupt).
Reproduction: vmcp att pcif XXX to \* ;vmcp det pcif XXX #in a loop

Upstream-Description:

              s390/pci: improve pci hotplug

              PCI hotplug events basically notify about the new state of a
              function. Unfortunately some hypervisors implement hotplug
              events in a way where it is not clear what the new state of
              the function should be.

              Use clp_get_state to find the current state of the function
              and handle accordingly.

              Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
              Reviewed-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>
              Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>


Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
Acked-by: Hannes Reinecke <hare@suse.com>
---
 arch/s390/include/asm/pci.h |    1 +
 arch/s390/pci/pci.c         |   10 ++++++++++
 arch/s390/pci/pci_event.c   |   16 ++++++++++++----
 3 files changed, 23 insertions(+), 4 deletions(-)

--- a/arch/s390/include/asm/pci.h
+++ b/arch/s390/include/asm/pci.h
@@ -138,6 +138,7 @@ static inline bool zdev_enabled(struct z
 ----------------------------------------------------------------------------- */
 /* Base stuff */
 int zpci_create_device(struct zpci_dev *);
+void zpci_remove_device(struct zpci_dev *zdev);
 int zpci_enable_device(struct zpci_dev *);
 int zpci_disable_device(struct zpci_dev *);
 void zpci_stop_device(struct zpci_dev *);
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@ -1044,6 +1044,16 @@ void zpci_stop_device(struct zpci_dev *z
 }
 EXPORT_SYMBOL_GPL(zpci_stop_device);
 
+void zpci_remove_device(struct zpci_dev *zdev)
+{
+	if (!zdev->bus)
+		return;
+
+	device_unregister(zdev->bus->bridge);
+	__pcibios_remove_bus(zdev->bus);
+	pci_remove_bus(zdev->bus);
+}
+
 static inline int barsize(u8 size)
 {
 	return (size) ? (1 << size) >> 10 : 0;
--- a/arch/s390/pci/pci_event.c
+++ b/arch/s390/pci/pci_event.c
@@ -73,6 +73,7 @@ static void __devinit __zpci_event_avail
 {
 	struct zpci_dev *zdev = get_zdev_by_fid(ccdf->fid);
 	struct pci_dev *pdev = NULL;
+	enum zpci_state state;
 	int ret;
 
 	if (zdev)
@@ -105,6 +106,8 @@ static void __devinit __zpci_event_avail
 			clp_add_pci_device(ccdf->fid, ccdf->fh, 0);
 		break;
 	case 0x0303: /* Deconfiguration requested */
+		if (!zdev)
+			break;
 		if (pdev)
 			pci_remove_bus_device(pdev);
 
@@ -118,7 +121,9 @@ static void __devinit __zpci_event_avail
 			zdev->state = ZPCI_FN_STATE_STANDBY;
 
 		break;
-	case 0x0304: /* Configured -> Standby */
+	case 0x0304: /* Configured -> Standby|Reserved */
+		if (!zdev)
+			break;
 		if (pdev) {
 			/* Give the driver a hint that the function is
 			 * already unusable. */
@@ -129,6 +134,10 @@ static void __devinit __zpci_event_avail
 		zdev->fh = ccdf->fh;
 		zpci_disable_device(zdev);
 		zdev->state = ZPCI_FN_STATE_STANDBY;
+		if (!clp_get_state(ccdf->fid, &state) &&
+		    state == ZPCI_FN_STATE_RESERVED) {
+			zpci_remove_device(zdev);
+		}
 		break;
 	case 0x0306: /* 0x308 or 0x302 for multiple devices */
 		clp_rescan_pci_devices();
@@ -140,9 +149,8 @@ static void __devinit __zpci_event_avail
 		 */
 		if (!zdev)
 			break;
-		device_unregister(zdev->bus->bridge);
-		__pcibios_remove_bus(zdev->bus);
-		pci_remove_bus(zdev->bus);
+
+		zpci_remove_device(zdev);
 		break;
 	default:
 		break;
