From: Steffen Maier <maier@linux.vnet.ibm.com>
Subject: zfcp: retain trace level for SCSI and HBA FSF response records
Patch-mainline: v4.9-rc1
Git-commit: 35f040df97fa0e94c7851c054ec71533c88b4b81
References: bnc#1003677, LTC#144312

Description:  zfcp: fix tracing regressions
Symptom:      Cannot distinguish trace level of trace records written with
              different trace levels.

              RECovery trace records do not show obviously if the LUN
              record field has a valid value or is n/a.

              Cannot interpret HBA error trace records for failed port
              actions, if it's for WKA (well known address) ports such as
              the fabric nameserver used for zfcp auto port scan.

              Cannot debug invalid handle situations with ports or LUNs.

              Especially if a request SAN trace record was lost due to
              trace buffer wrapping, we cannot see from which N_Port-ID the
              corresponding SAN response came from.

              Wrong payload length and confusing random payload data for
              RSPN (register symbolic port name) FC-GS responses
              (SAN trace area response tag: fsscth2).

              Cannot debug issues with larger SAN requests/responses
              such as with zfcp auto port scan where we need to see
              the currently active zone set.
Problem:      While retaining the actual filtering according to trace
              level, the following commits started to write such
              filtered records with a hardcoded record level of 1:
              commit 250a1352b95e1db3216e5c5d4f4365bea5122f4a
              [SCSI] zfcp: Redesign of the debug tracing for SCSI records.
              commit a54ca0f62f953898b05549391ac2a8a4dad6482b
              [SCSI] zfcp: Redesign of the debug tracing for HBA records.

              Explicit marking of an invalid LUN was lost with
              commit ae0904f60fab7cb20c48d32eefdd735e478b91fb
              zfcp: Redesign of the debug tracing for recovery actions.

              Since commit a54ca0f62f953898b05549391ac2a8a4dad6482b
              [SCSI] zfcp: Redesign of the debug tracing for HBA records.
              HBA records no longer contain WWPN, D_ID, or LUN to reduce
              duplicate information which is already in REC records. In
              contrast to "regular" target ports, we don't use recovery to
              open WKA ports such as directory/nameserver, so we don't get
              REC records.

              Handle information was lost with
              commit a54ca0f62f953898b05549391ac2a8a4dad6482b
              [SCSI] zfcp: Redesign of the debug tracing for HBA records.

              With commit 2c55b750a884b86dea8b4cc5f15e1484cc47a25c
              [SCSI] zfcp: Redesign of the debug tracing for SAN records.
              we lost the N_Port-ID where an ELS response comes from.
              With commit 7c7dc196814b9e1d5cc254dc579a5fa78ae524f7
              [SCSI] zfcp: Simplify handling of ct and els requests
              we lost the N_Port-ID where a CT response comes from.

              Commit 2c55b750a884b86dea8b4cc5f15e1484cc47a25c
              [SCSI] zfcp: Redesign of the debug tracing for SAN records.
              started to add FC_CT_HDR_LEN which made zfcp dump random data
              out of bounds for RSPN GS responses because u.rspn.rsp is the
              largest and last field in the union of struct zfcp_fc_req.
              Other request/response types only happened to stay within
              bounds due to the padding of the union or due to the trace
              capping of u.gspn.rsp to ZFCP_DBF_SAN_MAX_PAYLOAD.
              |
              Timestamp      : ...
              Area           : SAN
              Subarea        : 00
              Level          : 1
              Exception      : -
              CPU id         : ..
              Caller         : ...
              Record id      : 2
              Tag            : fsscth2
              Request id     : 0x...
              Destination ID : 0x00fffffc
              Payload short  : 01000000 fc020000 80020000 00000000
                               xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx <===
                               00000000 00000000 00000000 00000000
              Payload length : 32                                  <===
              |
              struct zfcp_fc_req {
                  [0] struct zfcp_fsf_ct_els ct_els;
                 [56] struct scatterlist sg_req;
                 [96] struct scatterlist sg_rsp;
                      union {
                          struct {req; rsp;} adisc;    SIZE: 28+28=   56
                          struct {req; rsp;} gid_pn;   SIZE: 24+20=   44
                          struct {rspsg; req;} gpn_ft; SIZE: 40*4+20=180
                          struct {req; rsp;} gspn;     SIZE: 20+273= 293
                          struct {req; rsp;} rspn;     SIZE: 277+16= 293
                [136] } u;
              }
              SIZE: 432

              The full payload of SAN trace records was lost with
              commit 2c55b750a884b86dea8b4cc5f15e1484cc47a25c
              [SCSI] zfcp: Redesign of the debug tracing for SAN records.
Solution:     Write records with their actual record level.

              Bring back
              commit d21e9daa63e009ce5b87bbcaa6d11ce48e07bbbe
              [SCSI] zfcp: Dont use 0 to indicate invalid LUN in rec trace.

              Introduce pseudo REC running records without any actual
              recovery action but including D_ID of WKA port on open/close.

              Restore tracing of handle for port and LUN with HBA records.

              GS uses an open WKA port handle and ELS just a D_ID, and only
              for ELS we could get D_ID from QTCB bottom via zfcp_fsf_req.
              To cover both cases, add a new field to zfcp_fsf_ct_els and
              fill it in on request to use in SAN response trace. Strictly
              speaking the D_ID on SAN response is the FC frame's S_ID. We
              don't need a field for the other end which is always us.

              Fix payload trace length for SAN request&response.

              Trace full payload of all SAN records (req,resp,iels) in
              associated PAYload trace record(s) if data spills SAN record.
              For the large GPN_FT response (4 pages), save space by not
              dumping any empty residual entries.
Reproduction: Increase the trace level of the HBA and SCSI trace area to
              the maximum of 6. Set an NPIV-enabled FCP device online in a
              SAN zone with other initiator ports. Perform some I/O.

Upstream-Description:

              zfcp: retain trace level for SCSI and HBA FSF response records

              While retaining the actual filtering according to trace level,
              the following commits started to write such filtered records
              with a hardcoded record level of 1 instead of the actual record level:
              commit 250a1352b95e1db3216e5c5d4f4365bea5122f4a
              ("[SCSI] zfcp: Redesign of the debug tracing for SCSI records.")
              commit a54ca0f62f953898b05549391ac2a8a4dad6482b
              ("[SCSI] zfcp: Redesign of the debug tracing for HBA records.")

              Now we can distinguish written records again for offline level filtering.

              Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
              Fixes: 250a1352b95e ("[SCSI] zfcp: Redesign of the debug tracing for SCSI records.")
              Fixes: a54ca0f62f95 ("[SCSI] zfcp: Redesign of the debug tracing for HBA records.")
              Cc: <stable@vger.kernel.org> #2.6.38+
              Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
              Reviewed-by: Hannes Reinecke <hare@suse.com>
              Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>


Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
Acked-by: John Jolly <jjolly@suse.com>
---
 drivers/s390/scsi/zfcp_dbf.c |   11 ++++++-----
 drivers/s390/scsi/zfcp_dbf.h |    4 ++--
 drivers/s390/scsi/zfcp_ext.h |    7 ++++---
 3 files changed, 12 insertions(+), 10 deletions(-)

--- a/drivers/s390/scsi/zfcp_dbf.c
+++ b/drivers/s390/scsi/zfcp_dbf.c
@@ -3,7 +3,7 @@
  *
  * Debug traces for zfcp.
  *
- * Copyright IBM Corporation 2002, 2010
+ * Copyright IBM Corp. 2002, 2015
  */
 
 #define KMSG_COMPONENT "zfcp"
@@ -57,7 +57,7 @@ void zfcp_dbf_pl_write(struct zfcp_dbf *
  * @tag: tag indicating which kind of unsolicited status has been received
  * @req: request for which a response was received
  */
-void zfcp_dbf_hba_fsf_res(char *tag, struct zfcp_fsf_req *req)
+void zfcp_dbf_hba_fsf_res(char *tag, int level, struct zfcp_fsf_req *req)
 {
 	struct zfcp_dbf *dbf = req->adapter->dbf;
 	struct fsf_qtcb_prefix *q_pref = &req->qtcb->prefix;
@@ -89,7 +89,7 @@ void zfcp_dbf_hba_fsf_res(char *tag, str
 				  rec->pl_len, "fsf_res", req->req_id);
 	}
 
-	debug_event(dbf->hba, 1, rec, sizeof(*rec));
+	debug_event(dbf->hba, level, rec, sizeof(*rec));
 	spin_unlock_irqrestore(&dbf->hba_lock, flags);
 }
 
@@ -391,7 +391,8 @@ void zfcp_dbf_san_in_els(char *tag, stru
  * @sc: pointer to struct scsi_cmnd
  * @fsf: pointer to struct zfcp_fsf_req
  */
-void zfcp_dbf_scsi(char *tag, struct scsi_cmnd *sc, struct zfcp_fsf_req *fsf)
+void zfcp_dbf_scsi(char *tag, int level, struct scsi_cmnd *sc,
+		   struct zfcp_fsf_req *fsf)
 {
 	struct zfcp_adapter *adapter =
 		(struct zfcp_adapter *) sc->device->host->hostdata[0];
@@ -433,7 +434,7 @@ void zfcp_dbf_scsi(char *tag, struct scs
 		}
 	}
 
-	debug_event(dbf->scsi, 1, rec, sizeof(*rec));
+	debug_event(dbf->scsi, level, rec, sizeof(*rec));
 	spin_unlock_irqrestore(&dbf->scsi_lock, flags);
 }
 
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@ -284,7 +284,7 @@ static inline
 void zfcp_dbf_hba_fsf_resp(char *tag, int level, struct zfcp_fsf_req *req)
 {
 	if (level <= req->adapter->dbf->hba->level)
-		zfcp_dbf_hba_fsf_res(tag, req);
+		zfcp_dbf_hba_fsf_res(tag, level, req);
 }
 
 /**
@@ -323,7 +323,7 @@ void _zfcp_dbf_scsi(char *tag, int level
 					scmd->device->host->hostdata[0];
 
 	if (level <= adapter->dbf->scsi->level)
-		zfcp_dbf_scsi(tag, scmd, req);
+		zfcp_dbf_scsi(tag, level, scmd, req);
 }
 
 /**
--- a/drivers/s390/scsi/zfcp_ext.h
+++ b/drivers/s390/scsi/zfcp_ext.h
@@ -3,7 +3,7 @@
  *
  * External function declarations.
  *
- * Copyright IBM Corporation 2002, 2010
+ * Copyright IBM Corp. 2002, 2015
  */
 
 #ifndef ZFCP_EXT_H
@@ -50,7 +50,7 @@ extern void zfcp_dbf_rec_trig(char *, st
 			      struct zfcp_port *, struct scsi_device *, u8, u8);
 extern void zfcp_dbf_rec_run(char *, struct zfcp_erp_action *);
 extern void zfcp_dbf_hba_fsf_uss(char *, struct zfcp_fsf_req *);
-extern void zfcp_dbf_hba_fsf_res(char *, struct zfcp_fsf_req *);
+extern void zfcp_dbf_hba_fsf_res(char *, int, struct zfcp_fsf_req *);
 extern void zfcp_dbf_hba_bit_err(char *, struct zfcp_fsf_req *);
 extern void zfcp_dbf_hba_berr(struct zfcp_dbf *, struct zfcp_fsf_req *);
 extern void zfcp_dbf_hba_def_err(struct zfcp_adapter *, u64, u16, void **);
@@ -58,7 +58,8 @@ extern void zfcp_dbf_hba_basic(char *, s
 extern void zfcp_dbf_san_req(char *, struct zfcp_fsf_req *, u32);
 extern void zfcp_dbf_san_res(char *, struct zfcp_fsf_req *);
 extern void zfcp_dbf_san_in_els(char *, struct zfcp_fsf_req *);
-extern void zfcp_dbf_scsi(char *, struct scsi_cmnd *, struct zfcp_fsf_req *);
+extern void zfcp_dbf_scsi(char *, int, struct scsi_cmnd *,
+			  struct zfcp_fsf_req *);
 
 /* zfcp_erp.c */
 extern void zfcp_erp_set_adapter_status(struct zfcp_adapter *, u32);
