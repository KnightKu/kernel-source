From: Ursula Braun <ubraun@linux.vnet.ibm.com>
Subject: smc: receive data from RMBE
Patch-mainline: not yet, IBM pushing upstream
References: bsc#978258,FATE#319593,LTC#131290

Summary:     net/smc: Shared Memory Communications - RDMA
Description: Initial part of the implementation of the "Shared Memory
             Communications-RDMA" (SMC-R) protocol. The protocol is defined
             in RFC7609 [1]. It allows transparent transformation of TCP
             connections using the "Remote Direct Memory Access over
             Converged Ethernet" (RoCE) feature of certain communication
             hardware for data center environments. Tested on s390 and x86
             using Mellanox ConnectX-3 cards.

             A new socket protocol family PF_SMC is being introduced. A
             preload shared library will be offered to enable TCP-based
             applications to use SMC-R without changes or recompilation.

             References:
             [1] SMC-R Informational RFC:
             https://tools.ietf.org/rfc/rfc7609

Upstream-Description:

              smc: receive data from RMBE

              move RMBE data into user space buffer and update managing cursors

              Signed-off-by: Ursula Braun <ubraun@linux.vnet.ibm.com>

Signed-off-by: Ursula Braun <ubraun@linux.vnet.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 net/smc/Makefile   |    2 
 net/smc/af_smc.c   |    5 +
 net/smc/smc.h      |    4 +
 net/smc/smc_cdc.c  |    9 ++
 net/smc/smc_core.c |    3 
 net/smc/smc_rx.c   |  184 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 net/smc/smc_rx.h   |   23 ++++++
 net/smc/smc_tx.c   |   32 +++++++++
 net/smc/smc_tx.h   |    1 
 9 files changed, 260 insertions(+), 3 deletions(-)

--- a/net/smc/Makefile
+++ b/net/smc/Makefile
@@ -1,2 +1,2 @@
 obj-$(CONFIG_SMC)	+= smc.o
-smc-y := af_smc.o smc_pnet.o smc_ib.o smc_clc.o smc_core.o smc_wr.o smc_llc.o smc_cdc.o smc_tx.o
+smc-y := af_smc.o smc_pnet.o smc_ib.o smc_clc.o smc_core.o smc_wr.o smc_llc.o smc_cdc.o smc_tx.o smc_rx.o
--- a/net/smc/af_smc.c
+++ b/net/smc/af_smc.c
@@ -36,6 +36,7 @@
 #include "smc_ib.h"
 #include "smc_pnet.h"
 #include "smc_tx.h"
+#include "smc_rx.h"
 
 static DEFINE_MUTEX(smc_create_lgr_pending);	/* serialize link group
 						 * creation
@@ -435,6 +436,7 @@ out_connected:
 	smc_copy_sock_settings_to_clc(smc);
 	smc->sk.sk_state = SMC_ACTIVE;
 	smc_tx_init(smc);
+	smc_rx_init(smc);
 
 	return rc ? rc : local_contact;
 
@@ -774,6 +776,7 @@ out_connected:
 	sk_refcnt_debug_inc(newsmcsk);
 	newsmcsk->sk_state = SMC_ACTIVE;
 	smc_tx_init(new_smc);
+	smc_rx_init(new_smc);
 enqueue:
 	if (local_contact == SMC_FIRST_CONTACT)
 		mutex_unlock(&smc_create_lgr_pending);
@@ -966,7 +969,7 @@ static int smc_recvmsg(struct socket *so
 	if (smc->use_fallback)
 		rc = smc->clcsock->ops->recvmsg(smc->clcsock, msg, len, flags);
 	else
-		rc = sock_no_recvmsg(sock, msg, len, flags);
+		rc = smc_rx_recvmsg(smc, msg, len, flags);
 out:
 	release_sock(sk);
 	return rc;
--- a/net/smc/smc.h
+++ b/net/smc/smc.h
@@ -117,6 +117,10 @@ struct smc_connection {
 	struct smc_buf_desc	*rmb_desc;	/* RMBE descriptor */
 	int			rmbe_size;	/* RMBE size <== sock rmem */
 	int			rmbe_size_short;/* compressed notation */
+	int			rmbe_update_limit;
+						/* lower limit for consumer
+						 * cursor update
+						 */
 
 	struct smc_host_cdc_msg	local_tx_ctrl;	/* host byte order staging
 						 * buffer for CDC msg send
--- a/net/smc/smc_cdc.c
+++ b/net/smc/smc_cdc.c
@@ -15,6 +15,7 @@
 #include "smc_wr.h"
 #include "smc_cdc.h"
 #include "smc_tx.h"
+#include "smc_rx.h"
 
 struct smc_cdc_tx_pend {
 	struct smc_connection	*conn;		/* socket connection */
@@ -161,7 +162,13 @@ static void smc_cdc_msg_recv_action(stru
 		return;
 
 	/* data available */
-	/* subsequent patch: send delayed ack, wake receivers */
+	if ((conn->local_rx_ctrl.prod_flags.write_blocked) ||
+	    (conn->local_rx_ctrl.prod_flags.cons_curs_upd_req))
+		smc_tx_consumer_update(conn);
+	if (diff_prod ||
+	    smc_stop_received(conn) ||
+	    smc->sk.sk_shutdown & RCV_SHUTDOWN)
+		smc->sk.sk_data_ready(&smc->sk);
 }
 
 /* called under tasklet context */
--- a/net/smc/smc_core.c
+++ b/net/smc/smc_core.c
@@ -526,6 +526,9 @@ int smc_rmb_create(struct smc_sock *smc)
 		conn->rmbe_size_short = tmp_bufsize_short;
 		smc->sk.sk_rcvbuf = tmp_bufsize * 2;
 		atomic_set(&conn->bytes_to_rcv, 0);
+		conn->rmbe_update_limit =
+				min_t(int, conn->rmbe_size / 10,
+				      SOCK_MIN_SNDBUF / 2);
 		return 0;
 	} else {
 		return -ENOMEM;
--- /dev/null
+++ b/net/smc/smc_rx.c
@@ -0,0 +1,184 @@
+/*
+ * Shared Memory Communications over RDMA (SMC-R) and RoCE
+ *
+ * Manage RMBE
+ * copy new RMBE data into user space
+ *
+ * Copyright IBM Corp. 2016
+ *
+ * Author(s):  Ursula Braun <ursula.braun@de.ibm.com>
+ */
+
+#include <linux/net.h>
+#include <linux/rcupdate.h>
+#include <net/sock.h>
+
+#include "smc.h"
+#include "smc_core.h"
+#include "smc_cdc.h"
+#include "smc_tx.h" /* smc_tx_consumer_update() */
+#include "smc_rx.h"
+
+/* callback implementation for sk.sk_data_ready()
+ * to wakeup rcvbuf consumers that blocked with smc_rx_wait_data().
+ * indirectly called by smc_cdc_msg_recv_action().
+ */
+static void smc_rx_data_ready(struct sock *sk)
+{
+	struct socket_wq *wq;
+
+	/* derived from sock_def_readable() */
+	/* called already in smc_listen_worker() */
+	rcu_read_lock();
+	wq = rcu_dereference(sk->sk_wq);
+	if (wq_has_sleeper(wq))
+		wake_up_interruptible_sync_poll(&wq->wait, POLLIN | POLLPRI |
+						POLLRDNORM | POLLRDBAND);
+	if ((sk->sk_shutdown == SHUTDOWN_MASK) ||
+	    (sk->sk_state == SMC_CLOSED))
+		sk_wake_async(sk, SOCK_WAKE_WAITD, POLL_HUP);
+	else
+		sk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN);
+	rcu_read_unlock();
+}
+
+/* blocks rcvbuf consumer until >=len bytes available or timeout or interrupted
+ *   @smc    smc socket
+ *   @len    num bytes to wait for
+ *   @timeo  max seconds to wait, 0 for no timeout
+ * Returns:
+ * 1 if at least len bytes available in rcvbuf.
+ * -EAGAIN in case timeout expired.
+ * 0 otherwise (neither enough bytes in rcvbuf nor timeout, e.g. interrupted).
+ */
+static int smc_rx_wait_data(struct smc_sock *smc, int len, long timeo)
+{
+	struct smc_connection *conn = &smc->conn;
+	struct sock *sk = &smc->sk;
+	DEFINE_WAIT(wait);
+	int rc;
+
+	if (atomic_read(&conn->bytes_to_rcv) >= len)
+		return 1;
+	prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
+	sk_set_bit(SOCKWQ_ASYNC_WAITDATA, sk);
+	rc = sk_wait_event(sk, &timeo,
+			   sk->sk_err ||
+			   sk->sk_shutdown & RCV_SHUTDOWN ||
+			   sock_flag(sk, SOCK_DONE) ||
+			   (atomic_read(&conn->bytes_to_rcv) >= len) ||
+			   smc_stop_received(conn));
+	sk_clear_bit(SOCKWQ_ASYNC_WAITDATA, sk);
+	finish_wait(sk_sleep(sk), &wait);
+	return (rc || timeo) ? rc : -EAGAIN;
+}
+
+/* rcvbuf consumer: main API called by socket layer */
+int smc_rx_recvmsg(struct smc_sock *smc, struct msghdr *msg, size_t len,
+		   int flags)
+{
+	size_t read_done = 0, read_remaining = len;
+	struct smc_connection *conn = &smc->conn;
+	union smc_host_cursor_ovl prod, cons;
+	size_t readable, chunk;
+	char *rcvbuf_base;
+	int to_read;
+	long timeo;
+	int target;		/* Read at least these many bytes */
+	int rc;
+
+	msg->msg_namelen = 0;
+	rcvbuf_base = conn->rmb_desc->cpu_addr;
+	read_remaining = min_t(size_t, len, conn->rmbe_size); /* cap rx len */
+
+again:
+	target = sock_rcvlowat(&smc->sk, flags & MSG_WAITALL, read_remaining);
+	timeo = sock_rcvtimeo(&smc->sk, flags & MSG_DONTWAIT);
+	if (signal_pending(current))
+		return timeo ? -EINTR : -EAGAIN;
+	rc = smc_rx_wait_data(smc, target, timeo);
+	if ((rc == -EAGAIN) || (rc == -EINTR))
+		return rc;
+	if (!rc)
+		goto again;
+	to_read = atomic_read(&conn->bytes_to_rcv);
+
+	if ((to_read <= 0) &&
+	    (smc->sk.sk_err ||
+	     smc->sk.sk_shutdown & RCV_SHUTDOWN ||
+	     sock_flag(&smc->sk, SOCK_DONE) ||
+	     smc_stop_received(conn)))
+		return sock_error(&smc->sk);
+
+	if (to_read <= 0)
+		goto check_repeat;
+
+	if ((to_read < target) && !smc_stop_received(conn))
+		goto check_repeat;
+
+	prod.acurs = smc_curs_read(conn->local_rx_ctrl.prod.acurs);
+	cons.acurs = smc_curs_read(conn->local_tx_ctrl.cons.acurs);
+	if (prod.curs.wrap == cons.curs.wrap) {
+		/* unwrapped case: copy 1 single chunk */
+		readable = prod.curs.count - cons.curs.count;
+		chunk = min(read_remaining, readable);
+		if (!(flags & MSG_TRUNC)) {
+			if (memcpy_to_msg(msg, rcvbuf_base + cons.curs.count,
+					  chunk))
+				return -EFAULT;
+		}
+		read_remaining -= chunk;
+		read_done += chunk;
+	} else {
+		/* wrapped case: top chunk */
+		readable = conn->rmbe_size - cons.curs.count;
+		if (readable) {
+			chunk = min(read_remaining, readable);
+			if (!(flags & MSG_TRUNC)) {
+				if (memcpy_to_msg(msg,
+						  rcvbuf_base + cons.curs.count,
+						  chunk))
+					return -EFAULT;
+			}
+			read_remaining -= chunk;
+			read_done += chunk;
+		}
+		/* wrapped case: bottom chunk (if any) */
+		if (read_remaining) {
+			readable = prod.curs.count;
+			chunk = min(read_remaining, readable);
+			if (!(flags & MSG_TRUNC)) {
+				if (memcpy_to_msg(msg, rcvbuf_base, chunk))
+					return -EFAULT;
+			}
+			read_remaining -= chunk;
+			read_done += chunk;
+		}
+	}
+
+	/* update cursors */
+	if (!(flags & MSG_PEEK)) {
+		smc_curs_add(conn->rmbe_size, &cons.curs, read_done);
+		smp_mb__before_atomic();
+		atomic_sub(read_done, &conn->bytes_to_rcv);
+		smp_mb__after_atomic();
+		xchg(&conn->local_tx_ctrl.cons.acurs, cons.acurs);
+		/* send consumer cursor update if required */
+		/* analogon to advertising a new TCP rcv_wnd if required */
+		smc_tx_consumer_update(conn);
+	}
+check_repeat:
+	if ((to_read < target) &&
+	    !smc_stop_received(conn) &&
+	    !conn->local_tx_ctrl.conn_state_flags.abnormal_close) {
+		goto again;
+	}
+
+	return read_done;
+}
+
+/* Initialize receive properties on connection establishment. NB: not __init! */
+void smc_rx_init(struct smc_sock *smc)
+{
+	smc->sk.sk_data_ready = smc_rx_data_ready;
+}
--- /dev/null
+++ b/net/smc/smc_rx.h
@@ -0,0 +1,23 @@
+/*
+ * Shared Memory Communications over RDMA (SMC-R) and RoCE
+ *
+ * Manage RMBE
+ *
+ * Copyright IBM Corp. 2016
+ *
+ * Author(s):  Ursula Braun <ursula.braun@de.ibm.com>
+ */
+
+#ifndef SMC_RX_H
+#define SMC_RX_H
+
+#include <linux/socket.h>
+#include <linux/types.h>
+
+#include "smc.h"
+
+void smc_rx_init(struct smc_sock *);
+int smc_rx_to_read(struct smc_connection *);
+int smc_rx_recvmsg(struct smc_sock *, struct msghdr *, size_t, int);
+
+#endif /* SMC_RX_H */
--- a/net/smc/smc_tx.c
+++ b/net/smc/smc_tx.c
@@ -438,6 +438,38 @@ static void smc_tx_worker(struct work_st
 	release_sock(&smc->sk);
 }
 
+void smc_tx_consumer_update(struct smc_connection *conn)
+{
+	union smc_host_cursor_ovl cfed, cons;
+	struct smc_cdc_tx_pend *pend;
+	struct smc_wr_buf *wr_buf;
+	int to_confirm, rc;
+
+	cons.acurs = smc_curs_read(conn->local_tx_ctrl.cons.acurs);
+	cfed.acurs = smc_curs_read(conn->rx_curs_confirmed.acurs);
+	to_confirm = smc_curs_diff(conn->rmbe_size, &cfed, &cons);
+
+	if (conn->local_rx_ctrl.prod_flags.cons_curs_upd_req ||
+	    ((to_confirm > conn->rmbe_update_limit) &&
+	     ((to_confirm / (conn->rmbe_size / 2) > 0) ||
+	      conn->local_rx_ctrl.prod_flags.write_blocked))) {
+		rc = smc_cdc_get_free_slot(&conn->lgr->lnk[SMC_SINGLE_LINK],
+					   &wr_buf, &pend);
+		if (!rc)
+			rc = smc_cdc_msg_send(conn, wr_buf, pend);
+		if (rc < 0) {
+			schedule_delayed_work(&conn->tx_work, HZ / 10);
+			return;
+		}
+		xchg(&conn->rx_curs_confirmed.acurs,
+		     smc_curs_read(conn->local_tx_ctrl.cons.acurs));
+		conn->local_rx_ctrl.prod_flags.cons_curs_upd_req = 0;
+	}
+	if (conn->local_rx_ctrl.prod_flags.write_blocked &&
+	    !atomic_read(&conn->bytes_to_rcv))
+		conn->local_rx_ctrl.prod_flags.write_blocked = 0;
+}
+
 /***************************** send initialize *******************************/
 
 /* Initialize send properties on connection establishment. NB: not __init! */
--- a/net/smc/smc_tx.h
+++ b/net/smc/smc_tx.h
@@ -20,5 +20,6 @@ void smc_tx_init(struct smc_sock *);
 int smc_tx_sendmsg(struct smc_sock *, struct msghdr *, size_t);
 int smc_tx_sndbuf_nonempty(struct smc_connection *);
 void smc_tx_sndbuf_nonfull(struct smc_sock *);
+void smc_tx_consumer_update(struct smc_connection *);
 
 #endif /* SMC_TX_H */
