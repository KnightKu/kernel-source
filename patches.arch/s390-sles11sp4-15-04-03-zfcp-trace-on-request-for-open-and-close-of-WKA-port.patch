From: Steffen Maier <maier@linux.vnet.ibm.com>
Subject: zfcp: trace on request for open and close of WKA port
Patch-mainline: v4.9-rc1
Git-commit: d27a7cb91960cf1fdd11b10071e601828cbf4b1f
References: bnc#1003677, LTC#144312

Description:  zfcp: fix tracing regressions
Symptom:      Cannot distinguish trace level of trace records written with
              different trace levels.

              RECovery trace records do not show obviously if the LUN
              record field has a valid value or is n/a.

              Cannot interpret HBA error trace records for failed port
              actions, if it's for WKA (well known address) ports such as
              the fabric nameserver used for zfcp auto port scan.

              Cannot debug invalid handle situations with ports or LUNs.

              Especially if a request SAN trace record was lost due to
              trace buffer wrapping, we cannot see from which N_Port-ID the
              corresponding SAN response came from.

              Wrong payload length and confusing random payload data for
              RSPN (register symbolic port name) FC-GS responses
              (SAN trace area response tag: fsscth2).

              Cannot debug issues with larger SAN requests/responses
              such as with zfcp auto port scan where we need to see
              the currently active zone set.
Problem:      While retaining the actual filtering according to trace
              level, the following commits started to write such
              filtered records with a hardcoded record level of 1:
              commit 250a1352b95e1db3216e5c5d4f4365bea5122f4a
              [SCSI] zfcp: Redesign of the debug tracing for SCSI records.
              commit a54ca0f62f953898b05549391ac2a8a4dad6482b
              [SCSI] zfcp: Redesign of the debug tracing for HBA records.

              Explicit marking of an invalid LUN was lost with
              commit ae0904f60fab7cb20c48d32eefdd735e478b91fb
              zfcp: Redesign of the debug tracing for recovery actions.

              Since commit a54ca0f62f953898b05549391ac2a8a4dad6482b
              [SCSI] zfcp: Redesign of the debug tracing for HBA records.
              HBA records no longer contain WWPN, D_ID, or LUN to reduce
              duplicate information which is already in REC records. In
              contrast to "regular" target ports, we don't use recovery to
              open WKA ports such as directory/nameserver, so we don't get
              REC records.

              Handle information was lost with
              commit a54ca0f62f953898b05549391ac2a8a4dad6482b
              [SCSI] zfcp: Redesign of the debug tracing for HBA records.

              With commit 2c55b750a884b86dea8b4cc5f15e1484cc47a25c
              [SCSI] zfcp: Redesign of the debug tracing for SAN records.
              we lost the N_Port-ID where an ELS response comes from.
              With commit 7c7dc196814b9e1d5cc254dc579a5fa78ae524f7
              [SCSI] zfcp: Simplify handling of ct and els requests
              we lost the N_Port-ID where a CT response comes from.

              Commit 2c55b750a884b86dea8b4cc5f15e1484cc47a25c
              [SCSI] zfcp: Redesign of the debug tracing for SAN records.
              started to add FC_CT_HDR_LEN which made zfcp dump random data
              out of bounds for RSPN GS responses because u.rspn.rsp is the
              largest and last field in the union of struct zfcp_fc_req.
              Other request/response types only happened to stay within
              bounds due to the padding of the union or due to the trace
              capping of u.gspn.rsp to ZFCP_DBF_SAN_MAX_PAYLOAD.
              |
              Timestamp      : ...
              Area           : SAN
              Subarea        : 00
              Level          : 1
              Exception      : -
              CPU id         : ..
              Caller         : ...
              Record id      : 2
              Tag            : fsscth2
              Request id     : 0x...
              Destination ID : 0x00fffffc
              Payload short  : 01000000 fc020000 80020000 00000000
                               xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx <===
                               00000000 00000000 00000000 00000000
              Payload length : 32                                  <===
              |
              struct zfcp_fc_req {
                  [0] struct zfcp_fsf_ct_els ct_els;
                 [56] struct scatterlist sg_req;
                 [96] struct scatterlist sg_rsp;
                      union {
                          struct {req; rsp;} adisc;    SIZE: 28+28=   56
                          struct {req; rsp;} gid_pn;   SIZE: 24+20=   44
                          struct {rspsg; req;} gpn_ft; SIZE: 40*4+20=180
                          struct {req; rsp;} gspn;     SIZE: 20+273= 293
                          struct {req; rsp;} rspn;     SIZE: 277+16= 293
                [136] } u;
              }
              SIZE: 432

              The full payload of SAN trace records was lost with
              commit 2c55b750a884b86dea8b4cc5f15e1484cc47a25c
              [SCSI] zfcp: Redesign of the debug tracing for SAN records.
Solution:     Write records with their actual record level.

              Bring back
              commit d21e9daa63e009ce5b87bbcaa6d11ce48e07bbbe
              [SCSI] zfcp: Dont use 0 to indicate invalid LUN in rec trace.

              Introduce pseudo REC running records without any actual
              recovery action but including D_ID of WKA port on open/close.

              Restore tracing of handle for port and LUN with HBA records.

              GS uses an open WKA port handle and ELS just a D_ID, and only
              for ELS we could get D_ID from QTCB bottom via zfcp_fsf_req.
              To cover both cases, add a new field to zfcp_fsf_ct_els and
              fill it in on request to use in SAN response trace. Strictly
              speaking the D_ID on SAN response is the FC frame's S_ID. We
              don't need a field for the other end which is always us.

              Fix payload trace length for SAN request&response.

              Trace full payload of all SAN records (req,resp,iels) in
              associated PAYload trace record(s) if data spills SAN record.
              For the large GPN_FT response (4 pages), save space by not
              dumping any empty residual entries.
Reproduction: Increase the trace level of the HBA and SCSI trace area to
              the maximum of 6. Set an NPIV-enabled FCP device online in a
              SAN zone with other initiator ports. Perform some I/O.

Upstream-Description:

              zfcp: trace on request for open and close of WKA port

              Since commit a54ca0f62f953898b05549391ac2a8a4dad6482b
              ("[SCSI] zfcp: Redesign of the debug tracing for HBA records.")
              HBA records no longer contain WWPN, D_ID, or LUN
              to reduce duplicate information which is already in REC records.
              In contrast to "regular" target ports, we don't use recovery to open
              WKA ports such as directory/nameserver, so we don't get REC records.
              Therefore, introduce pseudo REC running records without any
              actual recovery action but including D_ID of WKA port on open/close.

              Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
              Fixes: a54ca0f62f95 ("[SCSI] zfcp: Redesign of the debug tracing for HBA records.")
              Cc: <stable@vger.kernel.org> #2.6.38+
              Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
              Reviewed-by: Hannes Reinecke <hare@suse.com>
              Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>


Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
Acked-by: John Jolly <jjolly@suse.com>
---
 drivers/s390/scsi/zfcp_dbf.c |   32 ++++++++++++++++++++++++++++++++
 drivers/s390/scsi/zfcp_ext.h |    1 +
 drivers/s390/scsi/zfcp_fsf.c |    8 ++++++--
 3 files changed, 39 insertions(+), 2 deletions(-)

--- a/drivers/s390/scsi/zfcp_dbf.c
+++ b/drivers/s390/scsi/zfcp_dbf.c
@@ -313,6 +313,38 @@ void zfcp_dbf_rec_run(char *tag, struct
 	spin_unlock_irqrestore(&dbf->rec_lock, flags);
 }
 
+/**
+ * zfcp_dbf_rec_run_wka - trace wka port event with info like running recovery
+ * @tag: identifier for event
+ * @wka_port: well known address port
+ * @req_id: request ID to correlate with potential HBA trace record
+ */
+void zfcp_dbf_rec_run_wka(char *tag, struct zfcp_fc_wka_port *wka_port,
+			  u64 req_id)
+{
+	struct zfcp_dbf *dbf = wka_port->adapter->dbf;
+	struct zfcp_dbf_rec *rec = &dbf->rec_buf;
+	unsigned long flags;
+
+	spin_lock_irqsave(&dbf->rec_lock, flags);
+	memset(rec, 0, sizeof(*rec));
+
+	rec->id = ZFCP_DBF_REC_RUN;
+	memcpy(rec->tag, tag, ZFCP_DBF_TAG_LEN);
+	rec->port_status = wka_port->status;
+	rec->d_id = wka_port->d_id;
+	rec->lun = ZFCP_DBF_INVALID_LUN;
+
+	rec->u.run.fsf_req_id = req_id;
+	rec->u.run.rec_status = ~0;
+	rec->u.run.rec_step = ~0;
+	rec->u.run.rec_action = ~0;
+	rec->u.run.rec_count = ~0;
+
+	debug_event(dbf->rec, 1, rec, sizeof(*rec));
+	spin_unlock_irqrestore(&dbf->rec_lock, flags);
+}
+
 static inline
 void zfcp_dbf_san(char *tag, struct zfcp_dbf *dbf, void *data, u8 id, u16 len,
 		  u64 req_id, u32 d_id)
--- a/drivers/s390/scsi/zfcp_ext.h
+++ b/drivers/s390/scsi/zfcp_ext.h
@@ -49,6 +49,7 @@ extern void zfcp_dbf_adapter_unregister(
 extern void zfcp_dbf_rec_trig(char *, struct zfcp_adapter *,
 			      struct zfcp_port *, struct scsi_device *, u8, u8);
 extern void zfcp_dbf_rec_run(char *, struct zfcp_erp_action *);
+extern void zfcp_dbf_rec_run_wka(char *, struct zfcp_fc_wka_port *, u64);
 extern void zfcp_dbf_hba_fsf_uss(char *, struct zfcp_fsf_req *);
 extern void zfcp_dbf_hba_fsf_res(char *, int, struct zfcp_fsf_req *);
 extern void zfcp_dbf_hba_bit_err(char *, struct zfcp_fsf_req *);
--- a/drivers/s390/scsi/zfcp_fsf.c
+++ b/drivers/s390/scsi/zfcp_fsf.c
@@ -1605,7 +1605,7 @@ out:
 int zfcp_fsf_open_wka_port(struct zfcp_fc_wka_port *wka_port)
 {
 	struct zfcp_qdio *qdio = wka_port->adapter->qdio;
-	struct zfcp_fsf_req *req;
+	struct zfcp_fsf_req *req = NULL;
 	int retval = -EIO;
 
 	spin_lock_irq(&qdio->req_q_lock);
@@ -1634,6 +1634,8 @@ int zfcp_fsf_open_wka_port(struct zfcp_f
 		zfcp_fsf_req_free(req);
 out:
 	spin_unlock_irq(&qdio->req_q_lock);
+	if (req && !IS_ERR(req))
+		zfcp_dbf_rec_run_wka("fsowp_1", wka_port, req->req_id);
 	return retval;
 }
 
@@ -1658,7 +1660,7 @@ static void zfcp_fsf_close_wka_port_hand
 int zfcp_fsf_close_wka_port(struct zfcp_fc_wka_port *wka_port)
 {
 	struct zfcp_qdio *qdio = wka_port->adapter->qdio;
-	struct zfcp_fsf_req *req;
+	struct zfcp_fsf_req *req = NULL;
 	int retval = -EIO;
 
 	spin_lock_irq(&qdio->req_q_lock);
@@ -1687,6 +1689,8 @@ int zfcp_fsf_close_wka_port(struct zfcp_
 		zfcp_fsf_req_free(req);
 out:
 	spin_unlock_irq(&qdio->req_q_lock);
+	if (req && !IS_ERR(req))
+		zfcp_dbf_rec_run_wka("fscwp_1", wka_port, req->req_id);
 	return retval;
 }
 
