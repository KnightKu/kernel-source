From: Julian Wiedmann <jwi@linux.vnet.ibm.com>
Subject: s390/qeth: lock IP table while applying takeover changes
Patch-mainline: v4.15-rc4
Git-commit: 8a03a3692b100d84785ee7a834e9215e304c9e00
References: bnc#1085507, LTC#165490

Description:  qeth: fix IP takeover mode for L3 devices
Symptom:      Takeover configuration changes have no effect, or also
              affect non-eligible RXIP addresses.
Problem:      When the Takeover configuration changes, the currently
              configured IP addresses are not re-evaluated for
              Takeover-eligibility.
Solution:     Consistently re-evaluate the IP addresses for
              Takeover-eligibility after changing the configuration.
Reproduction: Toggle takeover mode or change the takeover ranges,
              and check via qethqoat if the TAKEOVER flag is set when
              registering IPs.

Upstream-Description:

              s390/qeth: lock IP table while applying takeover changes

              Modifying the flags of an IP addr object needs to be protected against
              eg. concurrent removal of the same object from the IP table.

              Fixes: 5f78e29ceebf ("qeth: optimize IP handling in rx_mode callback")
              Signed-off-by: Julian Wiedmann <jwi@linux.vnet.ibm.com>
              Signed-off-by: David S. Miller <davem@davemloft.net>


Signed-off-by: Julian Wiedmann <jwi@linux.vnet.ibm.com>
Acked-by: Johannes Thumshirn <jthumshirn@suse.de>
---
 drivers/s390/net/qeth_l3_sys.c |    2 ++
 1 file changed, 2 insertions(+)

--- a/drivers/s390/net/qeth_l3_sys.c
+++ b/drivers/s390/net/qeth_l3_sys.c
@@ -397,6 +397,7 @@ static ssize_t qeth_l3_dev_ipato_enable_
 		goto out;
 	card->ipato.enabled = enable;
 
+	spin_lock_bh(&card->ip_lock);
 	hash_for_each(card->ip_htable, i, addr, hnode) {
 		if (addr->type != QETH_IP_TYPE_NORMAL)
 			continue;
@@ -405,6 +406,7 @@ static ssize_t qeth_l3_dev_ipato_enable_
 		else if (qeth_l3_is_addr_covered_by_ipato(card, addr))
 			addr->set_flags |= QETH_IPA_SETIP_TAKEOVER_FLAG;
 	}
+	spin_unlock_bh(&card->ip_lock);
 out:
 	mutex_unlock(&card->conf_mutex);
 	return rc ? rc : count;
