From: Peter Hurley <peter@hurleysoftware.com>
Date: Sat, 16 Jan 2016 15:23:43 -0800
Subject: of: earlycon: Initialize port fields from DT properties
Git-commit: 088da2a17619cf0113b62a76ad38c6a14470ffa6 (partial)
Patch-mainline: v4.6-rc1
References: fate#322061

Read the optional "reg-offset", "reg-shift", "reg-io-width" and endianness
properties and initialize the respective struct uart_port field if found.

NB: These bindings are common to several drivers and the values merely
indicate the default value; the registering earlycon setup() method can
simply override the values if required.

Acked-by: Rob Herring <robh@kernel.org>
Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
[mb: drop MEM16 parts]
Signed-off-by: Matthias Brugger <mbrugger@suse.com>
---
 drivers/of/fdt.c              |    2 +-
 drivers/tty/serial/earlycon.c |   28 ++++++++++++++++++++++++++++
 include/linux/serial_core.h   |    1 +
 3 files changed, 30 insertions(+), 1 deletion(-)

--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -839,7 +839,7 @@ static int __init early_init_dt_scan_cho
 		if (addr == OF_BAD_ADDR)
 			return -ENXIO;
 
-		of_setup_earlycon(addr, match, options);
+		of_setup_earlycon(addr, match, offset, options);
 		return 0;
 	}
 	return -ENODEV;
--- a/drivers/tty/serial/earlycon.c
+++ b/drivers/tty/serial/earlycon.c
@@ -19,6 +19,7 @@
 #include <linux/io.h>
 #include <linux/serial_core.h>
 #include <linux/sizes.h>
+#include <linux/of_fdt.h>
 
 #ifdef CONFIG_FIX_EARLYCON_MEM
 #include <asm/fixmap.h>
@@ -210,10 +211,13 @@ early_param("earlycon", param_setup_earl
 
 int __init of_setup_earlycon(unsigned long addr,
 			     const struct earlycon_id *match,
+			     unsigned long node,
 			     const char *options)
 {
 	int err;
 	struct uart_port *port = &early_console_dev.port;
+	const __be32 *val;
+	bool big_endian;
 
 	spin_lock_init(&port->lock);
 	port->iotype = UPIO_MEM;
@@ -221,6 +225,30 @@ int __init of_setup_earlycon(unsigned lo
 	port->uartclk = BASE_BAUD * 16;
 	port->membase = earlycon_map(addr, SZ_4K);
 
+	val = of_get_flat_dt_prop(node, "reg-offset", NULL);
+	if (val)
+		port->mapbase += be32_to_cpu(*val);
+	val = of_get_flat_dt_prop(node, "reg-shift", NULL);
+	if (val)
+		port->regshift = be32_to_cpu(*val);
+	big_endian = of_get_flat_dt_prop(node, "big-endian", NULL) != NULL ||
+		(IS_ENABLED(CONFIG_CPU_BIG_ENDIAN) &&
+		 of_get_flat_dt_prop(node, "native-endian", NULL) != NULL);
+	val = of_get_flat_dt_prop(node, "reg-io-width", NULL);
+	if (val) {
+		switch (be32_to_cpu(*val)) {
+		case 1:
+			port->iotype = UPIO_MEM;
+			break;
+		case 4:
+			port->iotype = (big_endian) ? UPIO_MEM32BE : UPIO_MEM32;
+			break;
+		default:
+			pr_warn("[%s] unsupported reg-io-width\n", match->name);
+			return -EINVAL;
+		}
+	}
+
 	if (options) {
 		strlcpy(early_console_dev.options, options,
 			sizeof(early_console_dev.options));
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -359,6 +359,7 @@ extern const struct earlycon_id __earlyc
 
 extern int setup_earlycon(char *buf);
 extern int of_setup_earlycon(unsigned long addr, const struct earlycon_id *match,
+			     unsigned long node,
 			     const char *options);
 
 struct uart_port *uart_get_console(struct uart_port *ports, int nr,
