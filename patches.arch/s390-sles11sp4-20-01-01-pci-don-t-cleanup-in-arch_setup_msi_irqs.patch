From: Sebastian Ott <sebott@linux.vnet.ibm.com>
Subject: s390/pci: don't cleanup in arch_setup_msi_irqs
Patch-mainline: v4.13-rc1
Git-commit: 795818e8bf17dbc791764ba9fb723278ee934676
References: bnc#1054247, LTC#157731

Description:  PCI: fix hotplug related issues
Symptom:      After serveral cycles of hot-unplug/hotplug the affected
              function stops working or the kernel oopses.
Problem:      Hotplug notifications happen after the fact, meaning it's
              not possible to issue instructions to the function for
              cleanup purposes. Thus we never release the associated
              resources and at some point fail to allocate new ones.
Solution:     During clean up treat some errors as success (e.g. a
              function that's gone can't create an interrupt).
Reproduction: vmcp att pcif XXX to \* ;vmcp det pcif XXX #in a loop

Upstream-Description:

              s390/pci: don't cleanup in arch_setup_msi_irqs

              After failures in arch_setup_msi_irqs common code calls
              arch_teardown_msi_irqs. Thus, remove cleanup code from
              arch_setup_msi_irqs.

              Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
              Reviewed-by: Gerald Schaefer <gerald.schaefer@de.ibm.com>
              Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>


Signed-off-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
Acked-by: Hannes Reinecke <hare@suse.com>
---
 arch/s390/include/asm/pci.h |    2 -
 arch/s390/pci/pci.c         |   47 ++++++++++++++++++++------------------------
 arch/s390/pci/pci_msi.c     |    6 +++--
 3 files changed, 27 insertions(+), 28 deletions(-)

--- a/arch/s390/include/asm/pci.h
+++ b/arch/s390/include/asm/pci.h
@@ -95,7 +95,7 @@ struct zpci_dev {
 	struct zdev_irq_map *irq_map;
 	struct msi_map *msi_map;
 	struct airq_iv *aibv;		/* adapter interrupt bit vector */
-	unsigned int	aisb;		/* number of the summary bit */
+	unsigned long	aisb;		/* number of the summary bit */
 
 	/* DMA stuff */
 	unsigned long	*dma_table;
--- a/arch/s390/pci/pci.c
+++ b/arch/s390/pci/pci.c
@@ -460,8 +460,14 @@ out:
 static void zpci_free_msi(struct zpci_dev *zdev)
 {
 	kfree(zdev->msi_map);
-	kfree(zdev->irq_map->cb);
+	zdev->msi_map = NULL;
+
+	if (zdev->irq_map) {
+		kfree(zdev->irq_map->cb);
+		zdev->irq_map->cb = NULL;
+	}
 	kmem_cache_free(zdev_irq_cache, zdev->irq_map);
+	zdev->irq_map = NULL;
 }
 
 int arch_setup_msi_irqs(struct pci_dev *pdev, int nvec, int type)
@@ -472,27 +478,26 @@ int arch_setup_msi_irqs(struct pci_dev *
 	struct msi_desc *msi;
 	int rc;
 
+	zdev->aisb = -1UL;
 	if (type != PCI_CAP_ID_MSIX && type != PCI_CAP_ID_MSI)
 		return -EINVAL;
 	msi_vecs = min(nvec, ZPCI_MSI_VEC_MAX);
 
 	/* Allocate adapter summary indicator bit */
-	rc = -EIO;
 	aisb = airq_iv_alloc_bit(zpci_aisb_iv);
 	if (aisb == -1UL)
-		goto out;
+		return -EIO;
 	zdev->aisb = aisb;
 
 	/* Create adapter interrupt vector */
-	rc = -ENOMEM;
 	zdev->aibv = airq_iv_create(msi_vecs, AIRQ_IV_BITLOCK);
 	if (!zdev->aibv)
-		goto out_si;
+		return -ENOMEM;
 
 	/* Allocate data structures for msi interrupts */
 	rc = zpci_alloc_msi(zdev, msi_vecs);
 	if (rc)
-		goto out_iv;
+		return rc;
 
 	/* Wire up shortcut pointer */
 	zpci_imap[aisb] = zdev->irq_map;
@@ -507,31 +512,16 @@ int arch_setup_msi_irqs(struct pci_dev *
 		rc = zpci_setup_msi_irq(zdev, msi, msi_nr,
 					  aisb << ZPCI_MSI_VEC_BITS);
 		if (rc)
-			goto out_msi;
+			return rc;
 		msi_nr++;
 	}
 
 	/* Enable adapter interrupts */
 	rc = zpci_set_airq(zdev);
 	if (rc)
-		goto out_msi;
+		return rc;
 
 	return (msi_vecs == nvec) ? 0 : msi_vecs;
-
-out_msi:
-	msi_nr -= aisb << ZPCI_MSI_VEC_BITS;
-	list_for_each_entry(msi, &pdev->msi_list, list) {
-		if (msi_nr-- == 0)
-			break;
-		zpci_teardown_msi_irq(zdev, msi);
-	}
-	zpci_free_msi(zdev);
-out_iv:
-	airq_iv_release(zdev->aibv);
-out_si:
-	airq_iv_free_bit(zpci_aisb_iv, aisb);
-out:
-	return rc;
 }
 
 void arch_teardown_msi_irqs(struct pci_dev *pdev)
@@ -549,8 +539,15 @@ void arch_teardown_msi_irqs(struct pci_d
 		zpci_teardown_msi_irq(zdev, msi);
 
 	zpci_free_msi(zdev);
-	airq_iv_release(zdev->aibv);
-	airq_iv_free_bit(zpci_aisb_iv, zdev->aisb);
+
+	if (zdev->aisb != -1UL) {
+		airq_iv_free_bit(zpci_aisb_iv, zdev->aisb);
+		zdev->aisb = -1UL;
+	}
+	if (zdev->aibv) {
+		airq_iv_release(zdev->aibv);
+		zdev->aibv = NULL;
+	}
 }
 
 static void zpci_map_resources(struct pci_dev *pdev)
--- a/arch/s390/pci/pci_msi.c
+++ b/arch/s390/pci/pci_msi.c
@@ -106,8 +106,10 @@ void zpci_teardown_msi_irq(struct zpci_d
 	msi->irq = 0;
 
 	spin_lock(&msi_map_lock);
-	map = zdev->msi_map + nr;
-	hlist_del_rcu(&map->msi_chain);
+	if (zdev->msi_map) {
+		map = zdev->msi_map + nr;
+		hlist_del_rcu(&map->msi_chain);
+	}
 	spin_unlock(&msi_map_lock);
 }
 
