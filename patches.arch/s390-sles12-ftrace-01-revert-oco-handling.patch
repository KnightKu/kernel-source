From: Heiko Carstens <heiko.carstens@de.ibm.com>
Subject: ftrace: revert oco handling patch
Patch-mainline: never, SLES specific
References: bnc#924526, LTC#123020

Description:  kernel: use hotpatch feature to reduce function tracer overhead
Symptom:      The kernel uses more cpu cycles for each function being
              executed.
Problem:      The kGraft feature requires to instrument the kernel. In
              order to do that the kernel gets compiled with the function
              tracer enabled which causes the compiler to emit code that
              adds an "mcount" call to the prologue of each function.
              This code will be modified by the kernel for function tracing.
              The current implementation uses the "-pg" compiler option to
              generate a 24 byte function prologue which will be used by
              the function tracer.
              This 24 byte prologue however is larger than the 6 bytes that
              are needed and do cause a performance regression compared to
              kernels without function tracing enabled.
Solution:     Use gcc's hotpatch feature so that only a single 6 byte
              instruction will be added to the prologue of each function.
              With this change the impact of enabling the function tracer
              feature is close to zero compared to a kernel which has this
              feature disabled.
Reproduction: Compile the kernel with and without function tracer enabled
              and compare cpu time spent in the kernel for identical
              workloads.

Upstream-Description:

              ftrace: revert oco handling patch

              Temporarily remove the SLES12 oco handling patch, so the
              upstream commits apply easily. After the code has been rebased
              a different version of this patch will be applied again.

Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 arch/s390/include/asm/ftrace.h |   12 ------------
 arch/s390/kernel/ftrace.c      |   16 +++++++---------
 arch/s390/kernel/kprobes.c     |    2 +-
 arch/s390/kernel/mcount.S      |    4 ++--
 scripts/recordmcount.c         |    2 +-
 5 files changed, 11 insertions(+), 25 deletions(-)

--- a/arch/s390/include/asm/ftrace.h
+++ b/arch/s390/include/asm/ftrace.h
@@ -6,18 +6,6 @@
 #define MCOUNT_INSN_SIZE	24
 #define MCOUNT_RETURN_FIXUP	18
 
-/*
- * This is a SLES12 GA hack only:
- * After GA the ftrace code got changed to convert the first instead of
- * the second instruction. However we cannot change the recorded offsets
- * within the __mcount_loc section, due to out of tree built modules.
- * Therefore all (struct dyn_ftrace *) rec->ip passed instruction
- * addresses do not point to the instruction being changed, but six bytes
- * further.
- * The MCOUNT_IP_FIXUP define must be used everywhere to fixup the address.
- */
-#define MCOUNT_IP_FIXUP		6
-
 #ifndef __ASSEMBLY__
 
 void _mcount(void);
--- a/arch/s390/kernel/ftrace.c
+++ b/arch/s390/kernel/ftrace.c
@@ -59,10 +59,9 @@ int ftrace_modify_call(struct dyn_ftrace
 int ftrace_make_nop(struct module *mod, struct dyn_ftrace *rec,
 		    unsigned long addr)
 {
-	void *ip = (void *) rec->ip - MCOUNT_IP_FIXUP;
 	struct ftrace_insn orig, new, old;
 
-	if (probe_kernel_read(&old, ip, sizeof(old)))
+	if (probe_kernel_read(&old, (void *) rec->ip, sizeof(old)))
 		return -EFAULT;
 	if (addr == MCOUNT_ADDR) {
 		/* Initial code replacement; we expect to see stg r14,8(r15) */
@@ -82,23 +81,22 @@ int ftrace_make_nop(struct module *mod,
 		new.disp = KPROBE_ON_FTRACE_NOP;
 	} else {
 		/* Replace ftrace call with a nop. */
-		ftrace_generate_call_insn(&orig, (unsigned long) ip);
+		ftrace_generate_call_insn(&orig, rec->ip);
 		ftrace_generate_nop_insn(&new);
 	}
 	/* Verify that the to be replaced code matches what we expect. */
 	if (memcmp(&orig, &old, sizeof(old)))
 		return -EINVAL;
-	if (probe_kernel_write(ip, &new, sizeof(new)))
+	if (probe_kernel_write((void *) rec->ip, &new, sizeof(new)))
 		return -EPERM;
 	return 0;
 }
 
 int ftrace_make_call(struct dyn_ftrace *rec, unsigned long addr)
 {
-	void *ip = (void *) rec->ip - MCOUNT_IP_FIXUP;
 	struct ftrace_insn orig, new, old;
 
-	if (probe_kernel_read(&old, ip, sizeof(old)))
+	if (probe_kernel_read(&old, (void *) rec->ip, sizeof(old)))
 		return -EFAULT;
 	if (old.opc == BREAKPOINT_INSTRUCTION) {
 		/*
@@ -114,12 +112,12 @@ int ftrace_make_call(struct dyn_ftrace *
 	} else {
 		/* Replace nop with an ftrace call. */
 		ftrace_generate_nop_insn(&orig);
-		ftrace_generate_call_insn(&new, (unsigned long) ip);
+		ftrace_generate_call_insn(&new, rec->ip);
 	}
 	/* Verify that the to be replaced code matches what we expect. */
 	if (memcmp(&orig, &old, sizeof(old)))
 		return -EINVAL;
-	if (probe_kernel_write(ip, &new, sizeof(new)))
+	if (probe_kernel_write((void *) rec->ip, &new, sizeof(new)))
 		return -EPERM;
 	return 0;
 }
@@ -165,7 +163,7 @@ unsigned long __kprobes prepare_ftrace_r
 
 	if (unlikely(atomic_read(&current->tracing_graph_pause)))
 		goto out;
-	ip = (ip & PSW_ADDR_INSN) - MCOUNT_INSN_SIZE + MCOUNT_IP_FIXUP;
+	ip = (ip & PSW_ADDR_INSN) - MCOUNT_INSN_SIZE;
 	if (ftrace_push_return_trace(parent, ip, &trace.depth, 0) == -EBUSY)
 		goto out;
 	trace.func = ip;
--- a/arch/s390/kernel/kprobes.c
+++ b/arch/s390/kernel/kprobes.c
@@ -210,7 +210,7 @@ static void __kprobes copy_instruction(s
 	s64 disp, new_disp;
 	u64 addr, new_addr;
 
-	if (ftrace_location(ip + MCOUNT_IP_FIXUP) == ip + MCOUNT_IP_FIXUP) {
+	if (ftrace_location(ip) == ip) {
 		/*
 		 * If kprobes patches the instruction that is morphed by
 		 * ftrace make sure that kprobes always sees the branch
--- a/arch/s390/kernel/mcount.S
+++ b/arch/s390/kernel/mcount.S
@@ -34,12 +34,12 @@ ENTRY(ftrace_caller)
 	stg	%r0,(STACK_PTREGS_PSW+8)(%r15)
 	stmg	%r2,%r14,(STACK_PTREGS_GPRS+2*8)(%r15)
 #ifdef CONFIG_HAVE_MARCH_Z196_FEATURES
-	aghik	%r2,%r0,-(MCOUNT_INSN_SIZE-MCOUNT_IP_FIXUP)
+	aghik	%r2,%r0,-MCOUNT_INSN_SIZE
 	lgrl	%r4,function_trace_op
 	lgrl	%r1,ftrace_trace_function
 #else
 	lgr	%r2,%r0
-	aghi	%r2,-(MCOUNT_INSN_SIZE-MCOUNT_IP_FIXUP)
+	aghi	%r2,-MCOUNT_INSN_SIZE
 	larl	%r4,function_trace_op
 	lg	%r4,0(%r4)
 	larl	%r1,ftrace_trace_function
--- a/scripts/recordmcount.c
+++ b/scripts/recordmcount.c
@@ -397,7 +397,7 @@ do_file(char const *const fname)
 		}
 		if (w2(ghdr->e_machine) == EM_S390) {
 			reltype = R_390_64;
-			mcount_adjust_64 = -8;
+			mcount_adjust_64 = -14;
 		}
 		if (w2(ghdr->e_machine) == EM_MIPS) {
 			reltype = R_MIPS_64;
