From: Steffen Maier <maier@linux.vnet.ibm.com>
Subject: scsi: zfcp: fix use-after-free by not tracing WKA port open/close on failed send
Patch-mainline: v4.10-rc8
Git-commit: 2dfa6688aafdc3f74efeb1cf05fb871465d67f79
References: bnc#1025702, LTC#151365

Description:  zfcp: use-after-free tracing WKA port open/close on failed send
Symptom:      With low probability, undesired zfcp behavior such as:
              writing wrong value for the FSF request ID field of zfcp trace
              records of type ZFCP_DBF_REC_RUN with tags such as
              fsowp_1 or fscwp_1 [zfcpdbf, s390dbf],
              or even kernel panic due to page fault with one of these
              functions in the stack trace: zfcp_fsf_close_wka_port,
              zfcp_fsf_open_wka_port.
Problem:      Upstream commit d27a7cb91960cf1fdd11b10071e601828cbf4b1f
              ("zfcp: trace on request for open and close of WKA port")
              misses to check if the sending of a WKA port open/close failed
              and unconditionally dereferences the struct zfcp_fsf_req *req
              in this case to write a new trace record accessing data which
              was already released and thus causes a use-after-free.
Solution:     Rather than relying on req being NULL (or ERR_PTR) for all cases
              where we don't want to trace or should not trace, simply check
              retval which is unconditionally initialized with -EIO != 0 and it
              can only become 0 on successful retval = zfcp_fsf_req_send(req).
              With that we can also remove the then again unnecessary
              unconditional initialization of req which was introduced with
              that earlier commit.
Reproduction: Perform one of the following on FCP device(s) in a suitably
              timed loop such that it needs to open a WKA port,
              optionally send any FC CT/GS request,
              and close the WKA port again before the next loop iteration
              [triggering WKA port actions from user space with
               CT/GS pass through via BSG / libzfcphbaapi, or auto port scan]:
              * zfcp_show -n
              * zfcp_ping
              * trigger port_rescan via sysfs
              * zfcp_show (without -n option)
              (* rather unlikely: end of FCP device recovery,
                 cable pull&re-plug beyond host adjacent SAN switch)
              In another loop, perform one of the following which interrupts
              FCP device QDIO operations such that the sending of a
              WKA port open or close request is rejected with error:
              * configure FCP CHPID off&on at the SE or HMC
              * detach&attach FCP device from z/VM guest
              * vary FCP CHPID off&on within Linux (not sure this works)
              * live migrate z/VM guest while FCP device(s) active
              * FCP channel force recovery log at the SE
                (ATTENTION: risk of channel check stop if frequency too high!)

Upstream-Description:

              scsi: zfcp: fix use-after-free by not tracing WKA port open/close on failed send

              Dan Carpenter kindly reported:
              <quote>
              The patch d27a7cb91960: "zfcp: trace on request for open and close of
              WKA port" from Aug 10, 2016, leads to the following static checker
              warning:

              	drivers/s390/scsi/zfcp_fsf.c:1615 zfcp_fsf_open_wka_port()
              	warn: 'req' was already freed.

              drivers/s390/scsi/zfcp_fsf.c
                1609          zfcp_fsf_start_timer(req, ZFCP_FSF_REQUEST_TIMEOUT);
                1610          retval = zfcp_fsf_req_send(req);
                1611          if (retval)
                1612                  zfcp_fsf_req_free(req);
                                                        ^^^
              Freed.

                1613  out:
                1614          spin_unlock_irq(&qdio->req_q_lock);
                1615          if (req && !IS_ERR(req))
                1616                  zfcp_dbf_rec_run_wka("fsowp_1", wka_port, req->req_id);
                                                                                ^^^^^^^^^^^
              Use after free.

                1617          return retval;
                1618  }

              Same thing for zfcp_fsf_close_wka_port() as well.
              </quote>

              Rather than relying on req being NULL (or ERR_PTR) for all cases where
              we don't want to trace or should not trace,
              simply check retval which is unconditionally initialized with -EIO != 0
              and it can only become 0 on successful retval = zfcp_fsf_req_send(req).
              With that we can also remove the then again unnecessary unconditional
              initialization of req which was introduced with that earlier commit.

              Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
              Suggested-by: Benjamin Block <bblock@linux.vnet.ibm.com>
              Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
              Fixes: d27a7cb91960 ("zfcp: trace on request for open and close of WKA port")
              Cc: <stable@vger.kernel.org> #2.6.38+
              Reviewed-by: Benjamin Block <bblock@linux.vnet.ibm.com>
              Reviewed-by: Jens Remus <jremus@linux.vnet.ibm.com>
              Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>


Signed-off-by: Steffen Maier <maier@linux.vnet.ibm.com>
Acked-by: John Jolly <jjolly@suse.com>
---
 drivers/s390/scsi/zfcp_fsf.c |    8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

--- a/drivers/s390/scsi/zfcp_fsf.c
+++ b/drivers/s390/scsi/zfcp_fsf.c
@@ -1607,7 +1607,7 @@ out:
 int zfcp_fsf_open_wka_port(struct zfcp_fc_wka_port *wka_port)
 {
 	struct zfcp_qdio *qdio = wka_port->adapter->qdio;
-	struct zfcp_fsf_req *req = NULL;
+	struct zfcp_fsf_req *req;
 	int retval = -EIO;
 
 	spin_lock_irq(&qdio->req_q_lock);
@@ -1636,7 +1636,7 @@ int zfcp_fsf_open_wka_port(struct zfcp_f
 		zfcp_fsf_req_free(req);
 out:
 	spin_unlock_irq(&qdio->req_q_lock);
-	if (req && !IS_ERR(req))
+	if (!retval)
 		zfcp_dbf_rec_run_wka("fsowp_1", wka_port, req->req_id);
 	return retval;
 }
@@ -1662,7 +1662,7 @@ static void zfcp_fsf_close_wka_port_hand
 int zfcp_fsf_close_wka_port(struct zfcp_fc_wka_port *wka_port)
 {
 	struct zfcp_qdio *qdio = wka_port->adapter->qdio;
-	struct zfcp_fsf_req *req = NULL;
+	struct zfcp_fsf_req *req;
 	int retval = -EIO;
 
 	spin_lock_irq(&qdio->req_q_lock);
@@ -1691,7 +1691,7 @@ int zfcp_fsf_close_wka_port(struct zfcp_
 		zfcp_fsf_req_free(req);
 out:
 	spin_unlock_irq(&qdio->req_q_lock);
-	if (req && !IS_ERR(req))
+	if (!retval)
 		zfcp_dbf_rec_run_wka("fscwp_1", wka_port, req->req_id);
 	return retval;
 }
