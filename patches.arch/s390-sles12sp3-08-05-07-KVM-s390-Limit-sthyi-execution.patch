From: Janosch Frank <frankja@linux.vnet.ibm.com>
Subject: KVM: s390: Limit sthyi execution
Patch-mainline: v4.8-rc1
Git-commit: 7d0a5e62411a9223512c6af2e4c08a2d7c00fa2e
References: FATE#324070, LTC#158959

Summary:     kernel: Implement Store Hypervisor Information instruction in KVM
Description: Store Hypervisor Information is an emulated z/VM
             instruction that provides a guest with basic information about the
             layers it is running on. This includes information about the cpu
             configuration of both the machine and the lpar, as well as their
             names, machine model and machine type. This information enables an
             application to determine the maximum capacity of CPs and IFLs
             available to software.

Upstream-Description:

             KVM: s390: Limit sthyi execution

             Store hypervisor information is a valid instruction not only in
             supervisor state but also in problem state, i.e. the guest's
             userspace. Its execution is not only computational and memory
             intensive, but also has to get hold of the ipte lock to write to the
             guest's memory.

             This lock is not intended to be held often and long, especially not
             from the untrusted guest userspace. Therefore we apply rate limiting
             of sthyi executions per VM.

             Signed-off-by: Janosch Frank <frankja@linux.vnet.ibm.com>
             Acked-by: David Hildenbrand <dahi@linux.vnet.ibm.com>
             Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>


Signed-off-by: Janosch Frank <frankja@linux.vnet.ibm.com>
Acked-by: Johannes Thumshirn <jthumshirn@suse.de>
---
 arch/s390/include/asm/kvm_host.h |    1 +
 arch/s390/kvm/kvm-s390.c         |    2 ++
 arch/s390/kvm/sthyi.c            |   11 +++++++++++
 3 files changed, 14 insertions(+)

--- a/arch/s390/include/asm/kvm_host.h
+++ b/arch/s390/include/asm/kvm_host.h
@@ -602,6 +602,7 @@ struct kvm_arch{
 	wait_queue_head_t ipte_wq;
 	int ipte_lock_count;
 	struct mutex ipte_mutex;
+	struct ratelimit_state sthyi_limit;
 	spinlock_t start_stop_lock;
 	struct kvm_s390_cpu_model model;
 	struct kvm_s390_crypto crypto;
--- a/arch/s390/kvm/kvm-s390.c
+++ b/arch/s390/kvm/kvm-s390.c
@@ -1112,6 +1112,8 @@ int kvm_arch_init_vm(struct kvm *kvm, un
 
 	rc = -ENOMEM;
 
+	ratelimit_state_init(&kvm->arch.sthyi_limit, 5 * HZ, 500);
+
 	kvm->arch.sca = (struct sca_block *) get_zeroed_page(GFP_KERNEL);
 	if (!kvm->arch.sca)
 		goto out_err;
--- a/arch/s390/kvm/sthyi.c
+++ b/arch/s390/kvm/sthyi.c
@@ -12,6 +12,7 @@
 #include <linux/errno.h>
 #include <linux/pagemap.h>
 #include <linux/vmalloc.h>
+#include <linux/ratelimit.h>
 
 #include <asm/kvm_host.h>
 #include <asm/asm-offsets.h>
@@ -403,6 +404,16 @@ int handle_sthyi(struct kvm_vcpu *vcpu)
 	u64 code, addr, cc = 0;
 	struct sthyi_sctns *sctns = NULL;
 
+	/*
+	 * STHYI requires extensive locking in the higher hypervisors
+	 * and is very computational/memory expensive. Therefore we
+	 * ratelimit the executions per VM.
+	 */
+	if (!__ratelimit(&vcpu->kvm->arch.sthyi_limit)) {
+		kvm_s390_rewind_psw(vcpu, 4);
+		return 0;
+	}
+
 	kvm_s390_get_regs_rre(vcpu, &reg1, &reg2);
 	code = vcpu->run->s.regs.gprs[reg1];
 	addr = vcpu->run->s.regs.gprs[reg2];
