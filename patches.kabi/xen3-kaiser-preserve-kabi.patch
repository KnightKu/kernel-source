From: Jiri Kosina <jkosina@suse.cz>
Subject: [PATCH] xen/kaiser: work around kABI
Patch-mainline: Never, SUSE-Xen specific

The most potentially dangerous one is the vmstats one.  I can't imagine what
3rd party module would realistically be directly allocating pglist_data,
per_cpu_nodestat, memcg_stat_item, lruvec_stat, etc, but the potential
non-zero risk is there.

Signed-off-by: Jiri Kosina <jkosina@suse.cz>

Automatically created from "patches.kabi/kaiser-preserve-kabi.patch" by xen-port-patches.py

--- a/arch/x86/include/mach-xen/asm/desc.h
+++ b/arch/x86/include/mach-xen/asm/desc.h
@@ -42,7 +42,11 @@ struct gdt_page {
 	struct desc_struct gdt[GDT_ENTRIES];
 } __attribute__((aligned(PAGE_SIZE)));
 
+#ifdef __GENKSYMS__
+DECLARE_PER_CPU_PAGE_ALIGNED(struct gdt_page, gdt_page);
+#else
 DECLARE_PER_CPU_PAGE_ALIGNED_USER_MAPPED(struct gdt_page, gdt_page);
+#endif
 
 static inline struct desc_struct *get_cpu_gdt_table(unsigned int cpu)
 {
--- a/arch/x86/include/mach-xen/asm/fixmap.h
+++ b/arch/x86/include/mach-xen/asm/fixmap.h
@@ -78,7 +78,9 @@ enum fixed_addresses {
 	VSYSCALL_LAST_PAGE,
 	VSYSCALL_FIRST_PAGE = VSYSCALL_LAST_PAGE
 			    + ((VSYSCALL_END-VSYSCALL_START) >> PAGE_SHIFT) - 1,
+#ifndef __GENKSYMS__
 	VVAR_PAGE,
+#endif
 	VSYSCALL_HPET,
 #endif
 	FIX_DBGP_BASE,
--- a/arch/x86/include/mach-xen/asm/processor.h
+++ b/arch/x86/include/mach-xen/asm/processor.h
@@ -283,7 +283,11 @@ struct tss_struct {
 
 } ____cacheline_aligned;
 
+#ifndef __GENKSYMS__
 DECLARE_PER_CPU_SHARED_ALIGNED_USER_MAPPED(struct tss_struct, init_tss);
+#else
+DECLARE_PER_CPU_SHARED_ALIGNED(struct tss_struct, init_tss);
+#endif
 
 /*
  * Save the original ist values for checking stack pointers during debugging
--- a/arch/x86/include/mach-xen/asm/tlbflush.h
+++ b/arch/x86/include/mach-xen/asm/tlbflush.h
@@ -6,7 +6,9 @@
 
 #include <asm/processor.h>
 #include <asm/system.h>
+#ifndef __GENKSYMS__
 #include <asm/smp.h>
+#endif
 
 /*
  * Declare a couple of kaiser interfaces here for convenience,
--- a/arch/x86/kernel/cpu/common-xen.c
+++ b/arch/x86/kernel/cpu/common-xen.c
@@ -92,7 +92,11 @@ static const struct cpu_dev __cpuinitcon
 
 static const struct cpu_dev *this_cpu __cpuinitdata = &default_cpu;
 
+#ifndef __GENKSYMS__
 DEFINE_PER_CPU_PAGE_ALIGNED_USER_MAPPED(struct gdt_page, gdt_page) = { .gdt = {
+#else
+DEFINE_PER_CPU_PAGE_ALIGNED(struct gdt_page, gdt_page) = { .gdt = {
+#endif
 #ifdef CONFIG_X86_64
 	/*
 	 * We need valid kernel segments for data and code in long mode too
