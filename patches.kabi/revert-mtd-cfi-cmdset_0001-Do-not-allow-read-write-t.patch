From: Jiri Slaby <jslaby@suse.cz>
Date: Thu, 3 May 2018 14:14:33 +0200
Subject: Revert "mtd: cfi: cmdset_0001: Do not allow read/write to suspend
 erase block."
Patch-mainline: never, kabi
References: kabi

This reverts commit 869a31dfe4187038fe3b6033e70141a5e5739ada, upstream
commit 6510bbc88e3258631831ade49033537081950605. It adds a mask to
struct flchip. This breaks kABI. The problem is that struct flchip is
embedded into other structs so that we cannot move the newly added
member to the end. So revert the change unless someone comes with some
kABI workaround.

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 drivers/mtd/chips/cfi_cmdset_0001.c | 16 +++++-----------
 include/linux/mtd/flashchip.h       |  1 -
 2 files changed, 5 insertions(+), 12 deletions(-)

diff --git a/drivers/mtd/chips/cfi_cmdset_0001.c b/drivers/mtd/chips/cfi_cmdset_0001.c
index 4509ee0b294a..484cc4646521 100644
--- a/drivers/mtd/chips/cfi_cmdset_0001.c
+++ b/drivers/mtd/chips/cfi_cmdset_0001.c
@@ -837,10 +837,6 @@ static int chip_ready (struct map_info *map, struct flchip *chip, unsigned long
 		     (mode == FL_WRITING && (cfip->SuspendCmdSupport & 1))))
 			goto sleep;
 
-		/* Do not allow suspend iff read/write to EB address */
-		if ((adr & chip->in_progress_block_mask) ==
-		    chip->in_progress_block_addr)
-			goto sleep;
 
 		/* do not suspend small EBs, buggy Micron Chips */
 		if (cfi_is_micron_28F00AP30(cfi, chip) &&
@@ -848,19 +844,19 @@ static int chip_ready (struct map_info *map, struct flchip *chip, unsigned long
 			goto sleep;
 
 		/* Erase suspend */
-		map_write(map, CMD(0xB0), chip->in_progress_block_addr);
+		map_write(map, CMD(0xB0), adr);
 
 		/* If the flash has finished erasing, then 'erase suspend'
 		 * appears to make some (28F320) flash devices switch to
 		 * 'read' mode.  Make sure that we switch to 'read status'
 		 * mode so we get the right data. --rmk
 		 */
-		map_write(map, CMD(0x70), chip->in_progress_block_addr);
+		map_write(map, CMD(0x70), adr);
 		chip->oldstate = FL_ERASING;
 		chip->state = FL_ERASE_SUSPENDING;
 		chip->erase_suspended = 1;
 		for (;;) {
-			status = map_read(map, chip->in_progress_block_addr);
+			status = map_read(map, adr);
 			if (map_word_andequal(map, status, status_OK, status_OK))
 			        break;
 
@@ -1056,8 +1052,8 @@ static void put_chip(struct map_info *map, struct flchip *chip, unsigned long ad
 		   sending the 0x70 (Read Status) command to an erasing
 		   chip and expecting it to be ignored, that's what we
 		   do. */
-		map_write(map, CMD(0xd0), chip->in_progress_block_addr);
-		map_write(map, CMD(0x70), chip->in_progress_block_addr);
+		map_write(map, CMD(0xd0), adr);
+		map_write(map, CMD(0x70), adr);
 		chip->oldstate = FL_READY;
 		chip->state = FL_ERASING;
 		break;
@@ -1948,8 +1944,6 @@ static int __xipram do_erase_oneblock(struct map_info *map, struct flchip *chip,
 	map_write(map, CMD(0xD0), adr);
 	chip->state = FL_ERASING;
 	chip->erase_suspended = 0;
-	chip->in_progress_block_addr = adr;
-	chip->in_progress_block_mask = ~(len - 1);
 
 	ret = INVAL_CACHE_AND_WAIT(map, chip, adr,
 				   adr, len,
diff --git a/include/linux/mtd/flashchip.h b/include/linux/mtd/flashchip.h
index 3529683f691e..b63fa457febd 100644
--- a/include/linux/mtd/flashchip.h
+++ b/include/linux/mtd/flashchip.h
@@ -85,7 +85,6 @@ struct flchip {
 	unsigned int write_suspended:1;
 	unsigned int erase_suspended:1;
 	unsigned long in_progress_block_addr;
-	unsigned long in_progress_block_mask;
 
 	struct mutex mutex;
 	wait_queue_head_t wq; /* Wait on here when we're waiting for the chip
-- 
2.16.3

