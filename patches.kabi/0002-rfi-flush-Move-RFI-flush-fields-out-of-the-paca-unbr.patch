From 6950c09a5c49f07a8530b369d8245f4e5668de01 Mon Sep 17 00:00:00 2001
From: Michael Ellerman <mpe@ellerman.id.au>
Date: Fri, 12 Jan 2018 01:14:13 +1100
Subject: [PATCH 2/2] rfi-flush: Move RFI flush fields out of the paca (unbreak
 kABI)
Patch-mainline: Never, kABI
References: bsc#1075088

In order to avoid breaking kABI on distros that use it, we move the
RFI related fields out of the paca and into an auxillary structure.

We place the pointer to the auxillary structure in a hole that exists
prior to exgen.

Patch by Nick, reworked a bit by me.

Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Reviewed-by: Torsten Duwe <duwe@suse.de>
---
 arch/powerpc/include/asm/paca.h      | 40 +++++++++++++++++++++++-------------
 arch/powerpc/kernel/asm-offsets.c    | 10 +++++----
 arch/powerpc/kernel/exceptions-64s.S |  2 ++
 arch/powerpc/kernel/paca.c           | 25 +++++++++++++++++++---
 arch/powerpc/kernel/setup_64.c       |  7 ++++---
 5 files changed, 60 insertions(+), 24 deletions(-)

diff --git a/arch/powerpc/include/asm/paca.h b/arch/powerpc/include/asm/paca.h
index 63a6b66..4711b12 100644
--- a/arch/powerpc/include/asm/paca.h
+++ b/arch/powerpc/include/asm/paca.h
@@ -49,6 +49,23 @@ extern unsigned int debug_smp_processor_id(void); /* from linux/smp.h */
 struct task_struct;
 
 /*
+ * This is pointed to by paca->aux_ptr, for the purpose of extending the
+ * paca structure without kABI breakage.
+ */
+#ifdef CONFIG_PPC_BOOK3S_64
+struct paca_aux_struct {
+	/*
+	 * rfi fallback flush must be in its own cacheline to prevent
+	 * other paca data leaking into the L1d
+	 */
+	u64 exrfi[EX_SIZE] __aligned(0x80);
+	void *rfi_flush_fallback_area;
+	u64 l1d_flush_congruence;
+	u64 l1d_flush_sets;
+};
+#endif
+
+/*
  * Defines the layout of the paca.
  *
  * This structure is not directly accessed by firmware or the service
@@ -96,7 +113,15 @@ struct paca_struct {
 #endif /* CONFIG_PPC_STD_MMU_64 */
 	u64 dscr_default;		/* per-CPU default DSCR */
 
-#ifdef CONFIG_PPC_STD_MMU_64
+#ifdef CONFIG_PPC_BOOK3S_64
+#ifndef __GENKSYMS__
+	/*
+	 * Because of alignement of exgen there is a hole here, we use that hole
+	 * for the aux_ptr and so don't change the size of the paca or the
+	 * location of any members.
+	 */
+	struct paca_aux_struct *aux_ptr;
+#endif
 	/*
 	 * Now, starting in cacheline 2, the exception save areas
 	 */
@@ -163,19 +188,6 @@ struct paca_struct {
 	/* We use this to store guest state in */
 	struct kvmppc_book3s_shadow_vcpu shadow_vcpu;
 #endif
-#ifndef __GENKSYMS__
-#ifdef CONFIG_PPC_BOOK3S_64
-
-	/*
-	 * rfi fallback flush must be in its own cacheline to prevent
-	 * other paca data leaking into the L1d
-	 */
-	u64 exrfi[EX_SIZE] __aligned(0x80);
-	void *rfi_flush_fallback_area;
-	u64 l1d_flush_congruence;
-	u64 l1d_flush_sets;
-#endif
-#endif
 };
 
 extern struct paca_struct *paca;
diff --git a/arch/powerpc/kernel/asm-offsets.c b/arch/powerpc/kernel/asm-offsets.c
index 732394b..1c3498b 100644
--- a/arch/powerpc/kernel/asm-offsets.c
+++ b/arch/powerpc/kernel/asm-offsets.c
@@ -203,10 +203,12 @@ int main(void)
 #endif /* CONFIG_PPC_STD_MMU_64 */
 	DEFINE(PACAEMERGSP, offsetof(struct paca_struct, emergency_sp));
 
-	OFFSET(PACA_RFI_FLUSH_FALLBACK_AREA, paca_struct, rfi_flush_fallback_area);
-	OFFSET(PACA_EXRFI, paca_struct, exrfi);
-	OFFSET(PACA_L1D_FLUSH_CONGRUENCE, paca_struct, l1d_flush_congruence);
-	OFFSET(PACA_L1D_FLUSH_SETS, paca_struct, l1d_flush_sets);
+	/* paca_aux_struct stuff: */
+	OFFSET(PACA_AUX_PTR, paca_struct, aux_ptr);
+	OFFSET(PACA_RFI_FLUSH_FALLBACK_AREA, paca_aux_struct, rfi_flush_fallback_area);
+	OFFSET(PACA_EXRFI, paca_aux_struct, exrfi);
+	OFFSET(PACA_L1D_FLUSH_CONGRUENCE, paca_aux_struct, l1d_flush_congruence);
+	OFFSET(PACA_L1D_FLUSH_SETS, paca_aux_struct, l1d_flush_sets);
 
 	DEFINE(PACAHWCPUID, offsetof(struct paca_struct, hw_cpu_id));
 	DEFINE(PACAKEXECSTATE, offsetof(struct paca_struct, kexec_state));
diff --git a/arch/powerpc/kernel/exceptions-64s.S b/arch/powerpc/kernel/exceptions-64s.S
index 6888452..f9be5f9 100644
--- a/arch/powerpc/kernel/exceptions-64s.S
+++ b/arch/powerpc/kernel/exceptions-64s.S
@@ -362,6 +362,7 @@ machine_check_fwnmi:
 rfi_flush_fallback:
 	SET_SCRATCH0(r13);
 	GET_PACA(r13);
+	ld	r13,PACA_AUX_PTR(r13) /* r13 now = paca_aux pointer */
 	std	r9,PACA_EXRFI+EX_R9(r13)
 	std	r10,PACA_EXRFI+EX_R10(r13)
 	std	r11,PACA_EXRFI+EX_R11(r13)
@@ -404,6 +405,7 @@ rfi_flush_fallback:
 hrfi_flush_fallback:
 	SET_SCRATCH0(r13);
 	GET_PACA(r13);
+	ld	r13,PACA_AUX_PTR(r13) /* r13 now = paca_aux pointer */
 	std	r9,PACA_EXRFI+EX_R9(r13)
 	std	r10,PACA_EXRFI+EX_R10(r13)
 	std	r11,PACA_EXRFI+EX_R11(r13)
diff --git a/arch/powerpc/kernel/paca.c b/arch/powerpc/kernel/paca.c
index efeb881..3995fee 100644
--- a/arch/powerpc/kernel/paca.c
+++ b/arch/powerpc/kernel/paca.c
@@ -127,6 +127,12 @@ struct paca_struct *paca;
 EXPORT_SYMBOL(paca);
 
 struct paca_struct boot_paca;
+/*
+ * Auxiliary structure that can be used to basically add fields to the
+ * paca without changing its size (for kABI purposes). Upstream code should
+ * have these fields directly in the paca.
+ */
+static struct paca_aux_struct * __initdata paca_aux;
 
 void __init initialise_paca(struct paca_struct *new_paca, int cpu)
 {
@@ -151,6 +157,9 @@ void __init initialise_paca(struct paca_struct *new_paca, int cpu)
 #ifdef CONFIG_PPC_STD_MMU_64
 	new_paca->slb_shadow_ptr = &slb_shadow[cpu];
 #endif /* CONFIG_PPC_STD_MMU_64 */
+#ifdef CONFIG_PPC_BOOK3S_64
+	new_paca->aux_ptr = &paca_aux[cpu];
+#endif
 }
 
 /* Put the paca pointer into r13 and SPRG_PACA */
@@ -175,6 +184,7 @@ void setup_paca(struct paca_struct *new_paca)
 }
 
 static int __initdata paca_size;
+static int __initdata paca_aux_size;
 
 void __init allocate_pacas(void)
 {
@@ -195,8 +205,13 @@ void __init allocate_pacas(void)
 	paca = __va(memblock_alloc_base(paca_size, PAGE_SIZE, limit));
 	memset(paca, 0, paca_size);
 
-	printk(KERN_DEBUG "Allocated %u bytes for %d pacas at %p\n",
-		paca_size, nr_cpu_ids, paca);
+	paca_aux_size = PAGE_ALIGN(sizeof(struct paca_aux_struct) * nr_cpu_ids);
+
+	paca_aux = __va(memblock_alloc_base(paca_aux_size, PAGE_SIZE, limit));
+	memset(paca_aux, 0, paca_aux_size);
+
+	printk(KERN_DEBUG "Allocated %u bytes for %u pacas at %p\n",
+		paca_size + paca_aux_size, nr_cpu_ids, paca);
 
 	allocate_lppacas(nr_cpu_ids, limit);
 
@@ -208,18 +223,22 @@ void __init allocate_pacas(void)
 void __init free_unused_pacas(void)
 {
 	int new_size;
+	int new_aux_size;
 
 	new_size = PAGE_ALIGN(sizeof(struct paca_struct) * nr_cpu_ids);
+	new_aux_size = PAGE_ALIGN(sizeof(struct paca_aux_struct) * nr_cpu_ids);
 
 	if (new_size >= paca_size)
 		return;
 
 	memblock_free(__pa(paca) + new_size, paca_size - new_size);
+	memblock_free(__pa(paca_aux) + new_aux_size, paca_aux_size - new_aux_size);
 
 	printk(KERN_DEBUG "Freed %u bytes for unused pacas\n",
-		paca_size - new_size);
+		paca_size - new_size + paca_aux_size - new_aux_size);
 
 	paca_size = new_size;
+	paca_aux_size = new_aux_size;
 
 	free_lppacas();
 }
diff --git a/arch/powerpc/kernel/setup_64.c b/arch/powerpc/kernel/setup_64.c
index 5deac99..37c9a02 100644
--- a/arch/powerpc/kernel/setup_64.c
+++ b/arch/powerpc/kernel/setup_64.c
@@ -733,6 +733,7 @@ static void init_fallback_flush(void)
 	WARN_ON(l1d_size > MAX_L1D_SIZE);
 
 	for_each_possible_cpu(cpu) {
+		struct paca_aux_struct *paca_aux = paca[cpu].aux_ptr;
 		/*
 		 * The fallback flush is currently coded for 8-way
 		 * associativity. Different associativity is possible, but it
@@ -743,9 +744,9 @@ static void init_fallback_flush(void)
 		 */
 		u64 c = l1d_size / 8;
 
-		paca[cpu].rfi_flush_fallback_area = l1d_flush_fallback_area;
-		paca[cpu].l1d_flush_congruence = c;
-		paca[cpu].l1d_flush_sets = c / 128;
+		paca_aux->rfi_flush_fallback_area = l1d_flush_fallback_area;
+		paca_aux->l1d_flush_congruence = c;
+		paca_aux->l1d_flush_sets = c / 128;
 	}
 }
 
-- 
1.8.3.1

