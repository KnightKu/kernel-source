From: Joerg Roedel <jroedel@suse.de>
Date: Thu, 21 Sep 2017 15:04:31 +0200
Subject: [PATCH] kABI: Workaround kABI breakage of AMD-AVIC fixes
Patch-mainline: never, kabi
References: bsc#1044503

The fixes change the prototype of kvm_x86_ops->get_enable_apicv
call-back. Work around it by moving the call-back out of
kvm_x86_ops.

Signed-off-by: Joerg Roedel <jroedel@suse.de>
---
 arch/x86/include/asm/kvm_host.h | 5 +++--
 arch/x86/kvm/svm.c              | 6 ++++--
 arch/x86/kvm/vmx.c              | 4 +++-
 arch/x86/kvm/x86.c              | 5 ++++-
 4 files changed, 14 insertions(+), 6 deletions(-)

diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index d6f28fb..b6fb8d4 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -882,7 +882,7 @@ struct kvm_x86_ops {
 	void (*enable_nmi_window)(struct kvm_vcpu *vcpu);
 	void (*enable_irq_window)(struct kvm_vcpu *vcpu);
 	void (*update_cr8_intercept)(struct kvm_vcpu *vcpu, int tpr, int irr);
-	bool (*get_enable_apicv)(struct kvm_vcpu *vcpu);
+	bool (*get_enable_apicv)(void);
 	void (*refresh_apicv_exec_ctrl)(struct kvm_vcpu *vcpu);
 	void (*hwapic_irr_update)(struct kvm_vcpu *vcpu, int max_irr);
 	void (*hwapic_isr_update)(struct kvm *kvm, int isr);
@@ -981,8 +981,9 @@ struct kvm_arch_async_pf {
 
 extern struct kvm_x86_ops *kvm_x86_ops;
 
-/* kABI hack */
+/* kABI hacks */
 extern void (*kvm_set_pkru)(struct kvm_vcpu *vcpu, u32 pkru);
+extern bool (*kvm_get_enable_apicv)(struct kvm_vcpu *vcpu);
 
 int kvm_mmu_module_init(void);
 void kvm_mmu_module_exit(void);
diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c
index 393923f..250a6b5 100644
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@ -5379,7 +5379,6 @@ static struct kvm_x86_ops svm_x86_ops = {
 	.enable_irq_window = enable_irq_window,
 	.update_cr8_intercept = update_cr8_intercept,
 	.set_virtual_x2apic_mode = svm_set_virtual_x2apic_mode,
-	.get_enable_apicv = svm_get_enable_apicv,
 	.refresh_apicv_exec_ctrl = svm_refresh_apicv_exec_ctrl,
 	.load_eoi_exitmap = svm_load_eoi_exitmap,
 	.sync_pir_to_irr = svm_sync_pir_to_irr,
@@ -5428,12 +5427,15 @@ static int __init svm_init(void)
 	int r;
 
 	kvm_set_pkru = svm_set_pkru;
+	kvm_get_enable_apicv = svm_get_enable_apicv;
 
 	r = kvm_init(&svm_x86_ops, sizeof(struct vcpu_svm),
 		     __alignof__(struct vcpu_svm), THIS_MODULE);
 
-	if (r)
+	if (r) {
 		kvm_set_pkru = NULL;
+		kvm_get_enable_apicv = NULL;
+	}
 
 	return r;
 }
diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c
index e5bcb6b..cea552e 100644
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@ -10950,7 +10950,6 @@ static struct kvm_x86_ops vmx_x86_ops = {
 	.update_cr8_intercept = update_cr8_intercept,
 	.set_virtual_x2apic_mode = vmx_set_virtual_x2apic_mode,
 	.set_apic_access_page_addr = vmx_set_apic_access_page_addr,
-	.get_enable_apicv = vmx_get_enable_apicv,
 	.refresh_apicv_exec_ctrl = vmx_refresh_apicv_exec_ctrl,
 	.load_eoi_exitmap = vmx_load_eoi_exitmap,
 	.hwapic_irr_update = vmx_hwapic_irr_update,
@@ -11011,10 +11010,13 @@ static int __init vmx_init(void)
 	int r;
 
 	kvm_set_pkru = vmx_set_pkru;
+	kvm_get_enable_apicv = vmx_get_enable_apicv;
+
 	r = kvm_init(&vmx_x86_ops, sizeof(struct vcpu_vmx),
                      __alignof__(struct vcpu_vmx), THIS_MODULE);
 	if (r) {
 		kvm_set_pkru = NULL;
+		kvm_get_enable_apicv = NULL;
 		return r;
 	}
 
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index bd23ca6..8a9adfc 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -105,6 +105,9 @@ EXPORT_SYMBOL_GPL(kvm_x86_ops);
 void (*kvm_set_pkru)(struct kvm_vcpu *vcpu, u32 pkru);
 EXPORT_SYMBOL_GPL(kvm_set_pkru);
 
+bool (*kvm_get_enable_apicv)(struct kvm_vcpu *vcpu);
+EXPORT_SYMBOL_GPL(kvm_get_enable_apicv);
+
 static bool __read_mostly ignore_msrs = 0;
 module_param(ignore_msrs, bool, S_IRUGO | S_IWUSR);
 
@@ -7685,7 +7688,7 @@ int kvm_arch_vcpu_init(struct kvm_vcpu *vcpu)
 	BUG_ON(vcpu->kvm == NULL);
 	kvm = vcpu->kvm;
 
-	vcpu->arch.apicv_active = kvm_x86_ops->get_enable_apicv(vcpu);
+	vcpu->arch.apicv_active = kvm_get_enable_apicv(vcpu);
 	vcpu->arch.pv.pv_unhalted = false;
 	vcpu->arch.emulate_ctxt.ops = &emulate_ops;
 	if (!irqchip_in_kernel(kvm) || kvm_vcpu_is_reset_bsp(vcpu))
-- 
1.8.5.6

