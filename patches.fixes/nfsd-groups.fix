From: NeilBrown <neilb@suse.com>
Subject: nfsd: don't share group_info among threads
Patch-mainline: Not yet, under development
References: bsc@1070623

When set_groups() is called to assign a group_info to an nfsd thread,
the set of groups is sorted.  This uses a heap sort which is unstable.
i.e. Even if the array is initialy sorted changes will happen to
contents of the array during the sort process.

If the group_info array is shared, one thread might transiently see
these changes while another thread is sorting them.

This only happens when mountd is run with --manage-gids, or when krb5
is used. In other cases the group_info is always created new from the
RPC credentials.

Fix this by copying the groups list if it is already shared.

Acked-by: NeilBrown <neilb@suse.com>
Signed-off-by: Neil Brown <neilb@suse.com>

---
 fs/nfsd/auth.c |   15 ++++++++++++++-
 1 file changed, 14 insertions(+), 1 deletion(-)

--- a/fs/nfsd/auth.c
+++ b/fs/nfsd/auth.c
@@ -61,8 +61,21 @@ int nfsd_setuser(struct svc_rqst *rqstp,
 			else
 				GROUP_AT(gi, i) = GROUP_AT(rqgi, i);
 		}
-	} else {
+	} else if (atomic_read(&rqgi->usage) == 1) {
+		/* This is only used by this thread, so no need to copy */
 		gi = get_group_info(rqgi);
+	} else {
+		/* We have to duplicate the group_info as
+		 * set_groups() will sort it which can cause
+		 * transient instability which is visible in other
+		 * threads if the same group_info is shared.
+		 */
+		gi = groups_alloc(rqgi->ngroups);
+		if (!gi)
+			goto oom;
+
+		for (i = 0; i < rqgi->ngroups; i++)
+			GROUP_AT(gi, i) = GROUP_AT(rqgi, i);
 	}
 
 	if (new->fsuid == (uid_t) -1)
