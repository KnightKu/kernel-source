From: NeilBrown <neilb@suse.de>
Subject: Avoid occasional hang with NFS
Patch-mainline: v3.14
References: bnc#852488
Git-commit: 06ea0bfe6e6043cb56a78935a19f6f8ebc636226

There is a race in xs_nospace.  It is possible that space could be freed
on the socket before SOCK_NOSPACE is set.  The result of this is that
the ->sk_write_space() callback is never set.  So we must call it
ourselves.  As it checks if there really is space, this will not cause
an incorrect notification of space.

However this fix has not been tested by the customer.  The fix they
tested and will run with involves reverting a recent -stable patch
which removed the timeout for non-SOFT tasks when we are out of buffer
space.  Keeping the timeout ensures that losing the above race (or some
similar race) is not fatal.

So to be completely sure the customer does not see another regression
we keep that timeout-workaround, but substantially increase the
timeout.  The reason the timeout was removed in -stable is that it can
lead to the untimely breaking of connections which causes confusion.
Increasing the timeout will make this confusion much much less likely
(not that it is likely in the first place).  However a race will still
not be fatal.

So this patch increases the timeout for the non-SOFT case, and introduces
the call to ->sk_write_space.

Acked-by: NeilBrown <neilb@suse.de>
Signed-off-by: Neil Brown <neilb@suse.de>

---
 net/sunrpc/xprt.c     |    2 +-
 net/sunrpc/xprtsock.c |    4 ++++
 2 files changed, 5 insertions(+), 1 deletion(-)

--- a/net/sunrpc/xprt.c
+++ b/net/sunrpc/xprt.c
@@ -481,7 +481,7 @@ void xprt_wait_for_buffer_space(struct r
 	struct rpc_rqst *req = task->tk_rqstp;
 	struct rpc_xprt *xprt = req->rq_xprt;
 
-	task->tk_timeout = RPC_IS_SOFT(task) ? req->rq_timeout : 0;
+	task->tk_timeout = RPC_IS_SOFT(task) ? req->rq_timeout : (req->rq_timeout*10);
 	rpc_sleep_on(&xprt->pending, task, action);
 }
 EXPORT_SYMBOL_GPL(xprt_wait_for_buffer_space);
--- a/net/sunrpc/xprtsock.c
+++ b/net/sunrpc/xprtsock.c
@@ -485,6 +485,7 @@ static int xs_nospace(struct rpc_task *t
 	struct rpc_xprt *xprt = req->rq_xprt;
 	struct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);
 	int ret = -EAGAIN;
+	struct sock *sk = transport->inet;
 
 	dprintk("RPC: %5u xmit incomplete (%u left of %u)\n",
 			task->tk_pid, req->rq_slen - req->rq_bytes_sent,
@@ -511,6 +512,9 @@ static int xs_nospace(struct rpc_task *t
 	}
 
 	spin_unlock_bh(&xprt->transport_lock);
+
+	/* Race breaker in case memory is freed before above code is called */
+	sk->sk_write_space(sk);
 	return ret;
 }
 
