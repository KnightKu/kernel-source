From 94640c79d111ccea832b5663eb9066bf8163e122 Mon Sep 17 00:00:00 2001
From: Jan Kara <jack@suse.cz>
Date: Wed, 27 Mar 2013 17:30:59 +0100
Git-commit: e678a4f0f50d4fa4f7aaa6de8eb3f071513356a0
References: bsc#1020229
Patch-mainline: v3.10-rc1
Subject: [PATCH] jbd: don't wait (forever) for stale tid caused by wraparound

In the case where an inode has a very stale transaction id (tid) in
i_datasync_tid or i_sync_tid, it's possible that after a very large
(2**31) number of transactions, that the tid number space might wrap,
causing tid_geq()'s calculations to fail.

Commit d9b0193 "jbd: fix fsync() tid wraparound bug" attempted to fix
this problem, but it only avoided kjournald spinning forever by fixing
the logic in jbd_log_start_commit().

Signed-off-by: Jan Kara <jack@suse.cz>
---
 fs/jbd/journal.c | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/fs/jbd/journal.c b/fs/jbd/journal.c
index 86d96ee6a164..efbaad7dca76 100644
--- a/fs/jbd/journal.c
+++ b/fs/jbd/journal.c
@@ -561,6 +561,16 @@ int log_wait_commit(journal_t *journal, tid_t tid)
 	spin_unlock(&journal->j_state_lock);
 #endif
 	spin_lock(&journal->j_state_lock);
+	/*
+	 * Not running or committing trans? Must be already committed. This
+	 * saves us from waiting for a *long* time when tid overflows.
+	 */
+	if (!((journal->j_running_transaction &&
+	       journal->j_running_transaction->t_tid == tid) ||
+	      (journal->j_committing_transaction &&
+	       journal->j_committing_transaction->t_tid == tid)))
+		goto out_unlock;
+
 	if (!tid_geq(journal->j_commit_waited, tid))
 		journal->j_commit_waited = tid;
 	while (tid_gt(tid, journal->j_commit_sequence)) {
@@ -572,6 +582,7 @@ int log_wait_commit(journal_t *journal, tid_t tid)
 				!tid_gt(tid, journal->j_commit_sequence));
 		spin_lock(&journal->j_state_lock);
 	}
+out_unlock:
 	spin_unlock(&journal->j_state_lock);
 
 	if (unlikely(is_journal_aborted(journal))) {
-- 
2.11.0.258.ge05806d

