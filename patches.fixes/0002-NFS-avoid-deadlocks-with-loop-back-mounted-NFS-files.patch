From: NeilBrown <neilb@suse.de>
Date: Wed, 24 Sep 2014 11:28:32 +1000
Subject: [PATCH] NFS: avoid deadlocks with loop-back mounted NFS filesystems.
Git-commit: 9590544694becc64f4874963dbfc4b4d391024b7
Patch-mainline: v3.18
References: bsc#956491, FATE#320631

Support for loop-back mounted NFS filesystems is useful when NFS is
used to access shared storage in a high-availability cluster.

If the node running the NFS server fails, some other node can mount the
filesystem and start providing NFS service.  If that node already had
the filesystem NFS mounted, it will now have it loop-back mounted.

nfsd can suffer a deadlock when allocating memory and entering direct
reclaim.
While direct reclaim does not write to the NFS filesystem it can send
and wait for a COMMIT through nfs_release_page().

This patch modifies nfs_release_page() to wait a limited time for the
commit to complete - one second.  If the commit doesn't complete
in this time, nfs_release_page() will fail.  This means it might now
fail in some cases where it wouldn't before.  These cases are only
when 'gfp' includes '__GFP_WAIT'.

nfs_release_page() is only called by try_to_release_page(), and that
can only be called on an NFS page with required 'gfp' flags from
 - page_cache_pipe_buf_steal() in splice.c
 - shrink_page_list() in vmscan.c
 - invalidate_inode_pages2_range() in truncate.c

The first two handle failure quite safely.  The last is only called
after ->launder_page() has been called, and that will have waited
for the commit to finish already.

So aborting if the commit takes longer than 1 second is perfectly safe.

neilb: for SLE-11, page_waitqueue, wake_up_page and wait_on_page_bit_killable_timeout
  are included locally as 'static' as they aren't exported yet.

Signed-off-by: NeilBrown <neilb@suse.de>
Acked-by: Jeff Layton <jlayton@primarydata.com>
Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>

---
 fs/nfs/file.c  |   51 +++++++++++++++++++++++++++++++++++++++++----------
 fs/nfs/write.c |   16 ++++++++++++++++
 2 files changed, 57 insertions(+), 10 deletions(-)

--- a/fs/nfs/file.c
+++ b/fs/nfs/file.c
@@ -489,6 +489,31 @@ static void nfs_invalidate_page(struct p
 	nfs_fscache_invalidate_page(page, page->mapping->host);
 }
 
+#include <linux/hash.h>
+
+static inline wait_queue_head_t *page_waitqueue(struct page *page)
+{
+	const struct zone *zone = page_zone(page);
+
+	return &zone->wait_table[hash_ptr(page, zone->wait_table_bits)];
+}
+
+static void wait_on_page_bit_killable_timeout(struct page *page, int bit_nr, unsigned long timeout)
+{
+	DEFINE_WAIT_BIT(wait, &page->flags, bit_nr);
+	wait_queue_head_t *wq = page_waitqueue(page);
+
+	if (!test_bit(bit_nr, &page->flags))
+		return;
+
+	do {
+		prepare_to_wait(wq, &wait.wait, TASK_KILLABLE);
+		if (test_bit(bit_nr, &page->flags))
+			timeout = schedule_timeout(timeout);
+	} while (test_bit(bit_nr, &page->flags) && timeout > 0);
+	finish_wait(wq, &wait.wait);
+}
+
 /*
  * Attempt to release the private state associated with a page
  * - Called if either PG_private or PG_fscache is set on the page
@@ -501,17 +526,23 @@ static int nfs_release_page(struct page
 
 	dfprintk(PAGECACHE, "NFS: release_page(%p)\n", page);
 
-	/* Only do I/O if gfp is a superset of GFP_KERNEL, and we're not
-	 * doing this memory reclaim for a fs-related allocation.
+	/* Always try to initiate a 'commit' if relevant, but only
+	 * wait for it if __GFP_WAIT is set and the calling process is
+	 * allowed to block.  Even then, only wait 1 second.
+	 * Waiting indefinitely can cause deadlocks when the NFS
+	 * server is on this machine, and there is no particular need
+	 * to wait extensively here.  A short wait has the benefit
+	 * that someone else can worry about the freezer.
 	 */
-	if (mapping && (gfp & GFP_KERNEL) == GFP_KERNEL &&
-	    !(current->flags & PF_FSTRANS)) {
-		int how = FLUSH_SYNC;
-
-		/* Don't let kswapd deadlock waiting for OOM RPC calls */
-		if (current_is_kswapd())
-			how = 0;
-		nfs_commit_inode(mapping->host, how);
+	if (mapping) {
+		struct nfs_server *nfss = NFS_SERVER(mapping->host);
+		nfs_commit_inode(mapping->host, 0);
+		if ((gfp & __GFP_WAIT) &&
+		    !current_is_kswapd() &&
+		    !(current->flags & PF_FSTRANS)) {
+			wait_on_page_bit_killable_timeout(page, PG_private,
+							  HZ);
+		}
 	}
 	/* If PagePrivate() is set, then the page is not freeable */
 	if (PagePrivate(page))
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@ -427,6 +427,20 @@ out:
 	return error;
 }
 
+#include <linux/hash.h>
+
+static inline wait_queue_head_t *page_waitqueue(struct page *page)
+{
+	const struct zone *zone = page_zone(page);
+
+	return &zone->wait_table[hash_ptr(page, zone->wait_table_bits)];
+}
+
+static inline void wake_up_page(struct page *page, int bit)
+{
+	__wake_up_bit(page_waitqueue(page), &page->flags, bit);
+}
+
 /*
  * Remove a write request from an inode
  */
@@ -441,6 +455,8 @@ static void nfs_inode_remove_request(str
 	if (likely(!PageSwapCache(req->wb_page))) {
 		set_page_private(req->wb_page, 0);
 		ClearPagePrivate(req->wb_page);
+		smp_mb();
+		wake_up_page(req->wb_page, PG_private);
 		clear_bit(PG_MAPPED, &req->wb_flags);
 	}
 	radix_tree_delete(&nfsi->nfs_page_tree, req->wb_index);
