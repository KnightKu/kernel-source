From: NeilBrown <neilb@suse.com>
Subject: NFS: use smaller allocations for 'struct idmap'
References: bsc#965923
Patch-mainline: Never, this is just to support legacy stuff better

'struct idmap' is slightly over 32K, so it needs an order-4
allocation, which sometimes fails.

The largest part is 2 lots of 128 strings, each 128bytes long.  So
separate the strings into a collection of PAGE_SIZE allocations.  32
strings per page, 4 pages per hashtable.

This replaces an order-4 allocation with an order-1 allocation and 8
order-0 allocations.

Fortunately access to the strings is fairly localized so not many
places need to be changed.

---
 fs/nfs/idmap.c |   53 ++++++++++++++++++++++++++++++++++++++++++++---------
 1 file changed, 44 insertions(+), 9 deletions(-)

--- a/fs/nfs/idmap.c
+++ b/fs/nfs/idmap.c
@@ -321,12 +321,12 @@ struct idmap_hashent {
 	unsigned long		ih_expires;
 	__u32			ih_id;
 	size_t			ih_namelen;
-	char			ih_name[IDMAP_NAMESZ];
 };
 
 struct idmap_hashtable {
 	__u8			h_type;
 	struct idmap_hashent	h_entries[IDMAP_HASH_SZ];
+	char			*h_names[DIV_ROUND_UP(IDMAP_HASH_SZ * IDMAP_NAMESZ, PAGE_SIZE)];
 };
 
 struct idmap {
@@ -353,23 +353,46 @@ static const struct rpc_pipe_ops idmap_u
 	.destroy_msg	= idmap_pipe_destroy_msg,
 };
 
+static void idmap_free(struct idmap *idmap)
+{
+
+	if (idmap) {
+		int i;
+		for (i = 0; i < ARRAY_SIZE(idmap->idmap_user_hash.h_names); i++) {
+			kfree(idmap->idmap_user_hash.h_names[i]);
+			kfree(idmap->idmap_group_hash.h_names[i]);
+		}
+		kfree(idmap);
+	}
+}
+
 int
 nfs_idmap_new(struct nfs_client *clp)
 {
 	struct idmap *idmap;
 	int error;
+	int i;
 
 	BUG_ON(clp->cl_idmap != NULL);
 
 	idmap = kzalloc(sizeof(*idmap), GFP_KERNEL);
 	if (idmap == NULL)
 		return -ENOMEM;
+	for (i = 0; i < ARRAY_SIZE(idmap->idmap_user_hash.h_names); i++) {
+		idmap->idmap_user_hash.h_names[i] = kmalloc(PAGE_SIZE, GFP_KERNEL);
+		idmap->idmap_group_hash.h_names[i] = kmalloc(PAGE_SIZE, GFP_KERNEL);
+		if (!idmap->idmap_user_hash.h_names[i] ||
+		    !idmap->idmap_group_hash.h_names[i]) {
+			idmap_free(idmap);
+			return -ENOMEM;
+		}
+	}
 
 	idmap->idmap_dentry = rpc_mkpipe(clp->cl_rpcclient->cl_path.dentry,
 			"idmap", idmap, &idmap_upcall_ops, 0);
 	if (IS_ERR(idmap->idmap_dentry)) {
 		error = PTR_ERR(idmap->idmap_dentry);
-		kfree(idmap);
+		idmap_free(idmap);
 		return error;
 	}
 
@@ -392,7 +415,7 @@ nfs_idmap_delete(struct nfs_client *clp)
 		return;
 	rpc_unlink(idmap->idmap_dentry);
 	clp->cl_idmap = NULL;
-	kfree(idmap);
+	idmap_free(idmap);
 }
 
 /*
@@ -404,12 +427,21 @@ idmap_name_hash(struct idmap_hashtable*
 	return &h->h_entries[fnvhash32(name, len) % IDMAP_HASH_SZ];
 }
 
+static char *get_ih_name(struct idmap_hashtable *h, struct idmap_hashent *he)
+{
+	int i = he - h->h_entries;
+	int p = (i * IDMAP_NAMESZ) / PAGE_SIZE;
+	i -= p * PAGE_SIZE;
+	return h->h_names[p] + i * IDMAP_NAMESZ;
+}
+
 static struct idmap_hashent *
 idmap_lookup_name(struct idmap_hashtable *h, const char *name, size_t len)
 {
 	struct idmap_hashent *he = idmap_name_hash(h, name, len);
+	char *ih_name = get_ih_name(h, he);
 
-	if (he->ih_namelen != len || memcmp(he->ih_name, name, len) != 0)
+	if (he->ih_namelen != len || memcmp(ih_name, name, len) != 0)
 		return NULL;
 	if (time_after(jiffies, he->ih_expires))
 		return NULL;
@@ -451,12 +483,14 @@ idmap_alloc_id(struct idmap_hashtable *h
 }
 
 static void
-idmap_update_entry(struct idmap_hashent *he, const char *name,
+idmap_update_entry(struct idmap_hashtable *h,
+		   struct idmap_hashent *he, const char *name,
 		size_t namelen, __u32 id)
 {
+	char *ih_name = get_ih_name(h, he);
 	he->ih_id = id;
-	memcpy(he->ih_name, name, namelen);
-	he->ih_name[namelen] = '\0';
+	memcpy(ih_name, name, namelen);
+	ih_name[namelen] = '\0';
 	he->ih_namelen = namelen;
 	he->ih_expires = jiffies + nfs_idmap_cache_timeout;
 }
@@ -556,7 +590,8 @@ nfs_idmap_name(struct idmap *idmap, stru
 
 	he = idmap_lookup_id(h, id);
 	if (he) {
-		memcpy(name, he->ih_name, he->ih_namelen);
+		char *ih_name = get_ih_name(h, he);
+		memcpy(name, ih_name, he->ih_namelen);
 		ret = he->ih_namelen;
 		goto out;
 	}
@@ -693,7 +728,7 @@ idmap_pipe_downcall(struct file *filp, c
 
 	/* If the entry is valid, also copy it to the cache */
 	if (he != NULL)
-		idmap_update_entry(he, im_in.im_name, namelen_in, im_in.im_id);
+		idmap_update_entry(h, he, im_in.im_name, namelen_in, im_in.im_id);
 	ret = mlen;
 out:
 	mutex_unlock(&idmap->idmap_im_lock);
