From: Jan Kara <jack@suse.com>
Subject: inotify: Fix nested sleeps in inotify_read()
Patch-mainline: Never (fixed differently by commit e23738a7300a7591a57a22f47b813fd1b53ec404 which is too intrusive)
References: bsc#940925

inotify_read() calls prepare_to_wait() early to avoid races between adding
of event and reading notification queue. However this sets task state
to TASK_INTERRUPTIBLE and if fsnotify_put_event() drops last inode reference
and hence calls into filesystem code to delete the inode, we can end up
with nested sleeps corrupting task state and leading to possibly indefinite
sleep of the process.

Fix the problem by moving prepare_to_wait() to later in the loop and re-check
queue emptyness before going to sleep.

Signed-off-by: Jan Kara <jack@suse.com>

---
 fs/notify/inotify/inotify_user.c |   12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

--- a/fs/notify/inotify/inotify_user.c
+++ b/fs/notify/inotify/inotify_user.c
@@ -234,14 +234,13 @@ static ssize_t inotify_read(struct file
 	struct fsnotify_event *kevent;
 	char __user *start;
 	int ret;
+	bool sleep;
 	DEFINE_WAIT(wait);
 
 	start = buf;
 	group = file->private_data;
 
 	while (1) {
-		prepare_to_wait(&group->notification_waitq, &wait, TASK_INTERRUPTIBLE);
-
 		mutex_lock(&group->notification_mutex);
 		kevent = get_one_event(group, count);
 		mutex_unlock(&group->notification_mutex);
@@ -271,10 +270,15 @@ static ssize_t inotify_read(struct file
 		if (start != buf)
 			break;
 
-		schedule();
+		prepare_to_wait(&group->notification_waitq, &wait, TASK_INTERRUPTIBLE);
+		mutex_lock(&group->notification_mutex);
+		sleep = fsnotify_notify_queue_is_empty(group);
+		mutex_unlock(&group->notification_mutex);
+		if (sleep)
+			schedule();
+		finish_wait(&group->notification_waitq, &wait);
 	}
 
-	finish_wait(&group->notification_waitq, &wait);
 	if (start != buf && ret != -EFAULT)
 		ret = buf - start;
 	return ret;
