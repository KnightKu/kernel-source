From ab061f49fe81cd4e3bba9ea22548018be777ab55 Mon Sep 17 00:00:00 2001
From: Nikolay Borisov <nborisov@suse.com>
Date: Wed, 31 May 2017 14:13:48 +0300
Subject: [PATCH 1/2] xfs: Synchronize xfs_buf disposal routines
References: bsc#1041160
Patch-mainline: Never, this is Suse-specific patch

Due to kernel 3.0 missing the infrastructure bits whichi
"xfs: use ->b_state to fix buffer I/O accounting release race" uses to 
implement the fix, I had to roll my own, stripped down version. This is what
this patch does. 

Signed-off-by: Nikolay Borisov <nborisov@suse.com>
---
 fs/xfs/linux-2.6/xfs_buf.c |    5 +++++
 fs/xfs/linux-2.6/xfs_buf.h |    5 +++++
 2 files changed, 10 insertions(+)

--- a/fs/xfs/linux-2.6/xfs_buf.c
+++ b/fs/xfs/linux-2.6/xfs_buf.c
@@ -200,6 +200,7 @@ xfs_buf_stale(
 	 */
 	xfs_buf_ioacct_dec(bp);
 
+	spin_lock(&bp->b_lock);
 	atomic_set(&(bp)->b_lru_ref, 0);
 	if (!list_empty(&bp->b_lru)) {
 		struct xfs_buftarg *btp = bp->b_target;
@@ -214,6 +215,7 @@ xfs_buf_stale(
 		spin_unlock(&btp->bt_lru_lock);
 	}
 	ASSERT(atomic_read(&bp->b_hold) >= 1);
+	spin_unlock(&bp->b_lock);
 }
 
 STATIC void
@@ -237,6 +239,7 @@ _xfs_buf_initialize(
 	INIT_LIST_HEAD(&bp->b_list);
 	RB_CLEAR_NODE(&bp->b_rbnode);
 	sema_init(&bp->b_sema, 0); /* held, no waiters */
+	spin_lock_init(&bp->b_lock);
 	XB_SET_OWNER(bp);
 	bp->b_target = target;
 	bp->b_file_offset = range_base;
@@ -952,6 +955,7 @@ xfs_buf_rele(
 
 	ASSERT(atomic_read(&bp->b_hold) > 0);
 	release = atomic_dec_and_lock(&bp->b_hold, &pag->pag_buf_lock);
+	spin_lock(&bp->b_lock);
 	if (!release) {
 		/*
 		 * Drop the in-flight state if the buffer is already on the LRU
@@ -980,6 +984,7 @@ xfs_buf_rele(
 	}
 
 out:
+	spin_unlock(&bp->b_lock);
 	if (freebuf)
 		xfs_buf_free(bp);
 }
--- a/fs/xfs/linux-2.6/xfs_buf.h
+++ b/fs/xfs/linux-2.6/xfs_buf.h
@@ -176,6 +176,11 @@ typedef struct xfs_buf {
 #ifdef XFS_BUF_LOCK_TRACKING
 	int			b_last_holder;
 #endif
+
+#ifndef __GENKSYMS__
+	spinlock_t		b_lock;
+	unsigned int		b_state;
+#endif
 } xfs_buf_t;
 
 
