From: Hannes Reinecke <hare@suse.de>
Date: Wed, 28 Mar 2018 09:15:36 +0200
Subject: [PATCH] nvme: do not send keep-alive frames during reset
References: bsc#1084223
Patch-Mainline: Never, SLE12-SP3 specific

When the controller is in RESETTING we should not send any keep-alive
frames, as those requests will only be requeued anyway.
And keep-alive will be restarted once the queue becomes live again.
Plus the queue might actually been torn down while the I/O is in flight,
so better not attempt it at all.

Reported-by: Steve Schremmer <sschremm@netapp.com>
Signed-off-by: Hannes Reinecke <hare@suse.com>
---
 drivers/nvme/host/core.c | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/drivers/nvme/host/core.c b/drivers/nvme/host/core.c
index ddfa6787f956..b69e81984cce 100644
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@ -528,7 +528,9 @@ static void nvme_keep_alive_end_io(struct request *rq, int error)
 		return;
 	}
 
-	schedule_delayed_work(&ctrl->ka_work, ctrl->kato * HZ);
+	/* Skip keep-alive if the controller is not live */
+	if (ctrl->state == NVME_CTRL_LIVE)
+		schedule_delayed_work(&ctrl->ka_work, ctrl->kato * HZ);
 }
 
 static int nvme_keep_alive(struct nvme_ctrl *ctrl)
@@ -557,6 +559,10 @@ static void nvme_keep_alive_work(struct work_struct *work)
 	struct nvme_ctrl *ctrl = container_of(to_delayed_work(work),
 			struct nvme_ctrl, ka_work);
 
+	/* Short-circuit keep-alive during resetting */
+	if (ctrl->state == NVME_CTRL_RESETTING)
+		return;
+
 	if (nvme_keep_alive(ctrl)) {
 		/* allocation failure, reset the controller */
 		dev_err(ctrl->device, "keep-alive failed\n");
-- 
2.12.3

