From: Tahsin Erdogan <tahsin@google.com>
Date:   Tue Feb 14 19:27:38 2017 -0800
Date: Tue, 4 Jul 2017 10:46:29 +0200
Subject: block: do not allow updates through sysfs until registration completes
Git-commit: b410aff2bd9f101bc096069612391aecce204cd1
References: bsc#1047027
Patch-Mainline: v4.12

When a new disk shows up, sysfs queue directory is created before elevator
is registered. This allows a user to attempt a scheduler switch even though
the initial registration hasn't completed yet.

In one scenario, blk_register_queue() calls elv_register_queue() and
right before cfq_registered_queue() is called, another process executes
elevator_switch() and replaces q->elevator with deadline scheduler. When
cfq_registered_queue() executes it interprets e->elevator_data as struct
cfq_data even though it is actually struct deadline_data.

Grab q->sysfs_lock in blk_register_queue() to synchronize with sysfs
callers.

Signed-off-by: Tahsin Erdogan <tahsin@google.com>
Signed-off-by: Jens Axboe <axboe@fb.com>
Acked-by: Vasilis Liaskovitis <vliaskovitis@suse.com>
---
 block/blk-sysfs.c | 18 +++++++++++++-----
 1 file changed, 13 insertions(+), 5 deletions(-)

diff --git a/block/blk-sysfs.c b/block/blk-sysfs.c
index 8539dd8..c7d14ee 100644
--- a/block/blk-sysfs.c
+++ b/block/blk-sysfs.c
@@ -537,16 +537,21 @@ int blk_register_queue(struct gendisk *disk)
 	if (ret)
 		return ret;
 
+	/* Prevent changes through sysfs until registration is completed. */
+	mutex_lock(&q->sysfs_lock);
+
 	ret = kobject_add(&q->kobj, kobject_get(&dev->kobj), "%s", "queue");
 	if (ret < 0) {
 		blk_trace_remove_sysfs(dev);
-		return ret;
+		goto unlock;
 	}
 
 	kobject_uevent(&q->kobj, KOBJ_ADD);
 
-	if (!q->request_fn)
-		return 0;
+	if (!q->request_fn) {
+		ret = 0;
+		goto unlock;
+	}
 
 	ret = elv_register_queue(q);
 	if (ret) {
@@ -554,10 +559,13 @@ int blk_register_queue(struct gendisk *disk)
 		kobject_del(&q->kobj);
 		blk_trace_remove_sysfs(dev);
 		kobject_put(&dev->kobj);
-		return ret;
+		goto unlock;
 	}
 
-	return 0;
+	ret = 0;
+unlock:
+	mutex_unlock(&q->sysfs_lock);
+	return ret;
 }
 
 void blk_unregister_queue(struct gendisk *disk)
-- 
1.7.12.4

