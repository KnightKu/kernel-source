From 47303423c117ca946a5452ee52da5eef27253762 Mon Sep 17 00:00:00 2001
From: Nikolay Borisov <nborisov@suse.com>
Date: Tue, 14 Mar 2017 22:33:41 +0200
Subject: [PATCH 08/10] xfs: Make xfs_icdinode->di_dmstate atomic_t
References: bsc#1024788
Patch-mainline: Never, this is SUSE private patch

Currently di_dmstate is being used as a counter for the number of holes
punched into a file. In xfs_dm_send_data_event it is being snapshotted i.e.
read under i_iolock. However, a future patch which is going to require
calling xfs_dm_send_data_event without i_iolock held to fix a deadlock
in file splicing. To allow this and at the same time provide the same
snapshot semantics convert di_dmstate to atomic_t.

Signed-off-by: Nikolay Borisov <nborisov@suse.com>
---
 fs/xfs/dmapi/xfs_dm.c | 15 ++++++++++-----
 fs/xfs/xfs_inode.c    |  6 +++---
 fs/xfs/xfs_inode.h    |  2 +-
 fs/xfs/xfs_itable.c   |  2 +-
 fs/xfs/xfs_vnodeops.c |  2 +-
 5 files changed, 16 insertions(+), 11 deletions(-)

diff --git a/fs/xfs/dmapi/xfs_dm.c b/fs/xfs/dmapi/xfs_dm.c
index d55dd330427d..c8a1ad788f4d 100644
--- a/fs/xfs/dmapi/xfs_dm.c
+++ b/fs/xfs/dmapi/xfs_dm.c
@@ -149,7 +149,7 @@ xfs_dm_send_data_event(
 	/* Returns positive errors to XFS */
 
 	do {
-		dmstate = ip->i_d.di_dmstate;
+		dmstate = atomic_read(&ip->i_d.di_dmstate);
 		if (lock_flags)
 			xfs_iunlock(ip, *lock_flags);
 
@@ -163,7 +163,7 @@ xfs_dm_send_data_event(
 
 		if (lock_flags)
 			xfs_ilock(ip, *lock_flags);
-	} while (!error && (ip->i_d.di_dmstate != dmstate));
+	} while (!error && (atomic_read(&ip->i_d.di_dmstate) != dmstate));
 
 	return error;
 }
@@ -325,7 +325,7 @@ xfs_ip_to_stat(
 	buf->dt_xfs_extents = dic->di_nextents;
 	buf->dt_xfs_aextents = dic->di_anextents;
 	buf->dt_xfs_igen = dic->di_gen;
-	buf->dt_xfs_dmstate = dic->di_dmstate;
+	buf->dt_xfs_dmstate = atomic_read(&dic->di_dmstate);
 
 	switch (dic->di_format) {
 	case XFS_DINODE_FMT_DEV:
@@ -2265,10 +2265,15 @@ xfs_dm_punch_hole(
 	if (error)
 		error = -error;
 
-	/* Let threads in send_data_event know we punched the file. */
-	ip->i_d.di_dmstate++;
 	xfs_iunlock(ip, XFS_IOLOCK_EXCL);
 
+	/* Let threads in send_data_event know we punched the file.
+	 * Also due to out change from uint16 to effectively uint32, handle
+	 * overflow case manually
+	 */
+	if (!atomic_add_unless(&ip->i_d.di_dmstate, 1, USHRT_MAX))
+			atomic_set(&ip->i_d.di_dmstate, 0); 
+
 up_and_out:
 	up_rw_sems(inode, DM_SEM_FLAG_WR);
 	put_write_access(inode);
diff --git a/fs/xfs/xfs_inode.c b/fs/xfs/xfs_inode.c
index 7feb4f2b3af2..b626a2478c42 100644
--- a/fs/xfs/xfs_inode.c
+++ b/fs/xfs/xfs_inode.c
@@ -668,7 +668,7 @@ xfs_dinode_from_disk(
 	to->di_forkoff = from->di_forkoff;
 	to->di_aformat	= from->di_aformat;
 	to->di_dmevmask	= be32_to_cpu(from->di_dmevmask);
-	to->di_dmstate	= be16_to_cpu(from->di_dmstate);
+	atomic_set(&to->di_dmstate, be16_to_cpu(from->di_dmstate));
 	to->di_flags	= be16_to_cpu(from->di_flags);
 	to->di_gen	= be32_to_cpu(from->di_gen);
 }
@@ -704,7 +704,7 @@ xfs_dinode_to_disk(
 	to->di_forkoff = from->di_forkoff;
 	to->di_aformat = from->di_aformat;
 	to->di_dmevmask = cpu_to_be32(from->di_dmevmask);
-	to->di_dmstate = cpu_to_be16(from->di_dmstate);
+	to->di_dmstate = cpu_to_be16(atomic_read(&from->di_dmstate));
 	to->di_flags = cpu_to_be16(from->di_flags);
 	to->di_gen = cpu_to_be32(from->di_gen);
 }
@@ -1070,7 +1070,7 @@ xfs_ialloc(
 	 */
 	ip->i_d.di_extsize = 0;
 	ip->i_d.di_dmevmask = 0;
-	ip->i_d.di_dmstate = 0;
+	atomic_set(&ip->i_d.di_dmstate, 0);
 	ip->i_d.di_flags = 0;
 	flags = XFS_ILOG_CORE;
 	switch (mode & S_IFMT) {
diff --git a/fs/xfs/xfs_inode.h b/fs/xfs/xfs_inode.h
index fd405cfaa97e..71ea08632e18 100644
--- a/fs/xfs/xfs_inode.h
+++ b/fs/xfs/xfs_inode.h
@@ -148,7 +148,7 @@ typedef struct xfs_icdinode {
 	__uint8_t	di_forkoff;	/* attr fork offs, <<3 for 64b align */
 	__int8_t	di_aformat;	/* format of attr fork's data */
 	__uint32_t	di_dmevmask;	/* DMIG event mask */
-	__uint16_t	di_dmstate;	/* DMIG state info */
+	atomic_t	di_dmstate;	/* DMIG state info */
 	__uint16_t	di_flags;	/* random flags, XFS_DIFLAG_... */
 	__uint32_t	di_gen;		/* generation number */
 } xfs_icdinode_t;
diff --git a/fs/xfs/xfs_itable.c b/fs/xfs/xfs_itable.c
index a240ed2ffa7f..5a1ec9a6cdd7 100644
--- a/fs/xfs/xfs_itable.c
+++ b/fs/xfs/xfs_itable.c
@@ -118,7 +118,7 @@ xfs_bulkstat_one_int(
 	buf->bs_gen = dic->di_gen;
 	memset(buf->bs_pad, 0, sizeof(buf->bs_pad));
 	buf->bs_dmevmask = dic->di_dmevmask;
-	buf->bs_dmstate = dic->di_dmstate;
+	buf->bs_dmstate = atomic_read(&dic->di_dmstate);
 	buf->bs_aextents = dic->di_anextents;
 	buf->bs_forkoff = XFS_IFORK_BOFF(ip);
 
diff --git a/fs/xfs/xfs_vnodeops.c b/fs/xfs/xfs_vnodeops.c
index b05778424568..b09fec394438 100644
--- a/fs/xfs/xfs_vnodeops.c
+++ b/fs/xfs/xfs_vnodeops.c
@@ -1832,7 +1832,7 @@ xfs_set_dmattrs(
 	xfs_trans_ijoin_ref(tp, ip, XFS_ILOCK_EXCL);
 
 	ip->i_d.di_dmevmask = evmask;
-	ip->i_d.di_dmstate  = state;
+	atomic_set(&ip->i_d.di_dmstate, state);
 
 	xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
 	error = xfs_trans_commit(tp, 0);
-- 
2.7.4

