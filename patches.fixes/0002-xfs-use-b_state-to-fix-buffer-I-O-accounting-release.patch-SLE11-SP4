From 770336c08e4b770444bf147b9436a676fa354c99 Mon Sep 17 00:00:00 2001
From: Nikolay Borisov <nborisov@suse.com>
Date: Thu, 1 Jun 2017 10:21:23 +0300
Subject: [PATCH 2/2] xfs: use ->b_state to fix buffer I/O accounting release
 race
Patch-mainline: Submitted to ml, https://patchwork.kernel.org/patch/9754591/
References: bsc#1041160

We've had user reports of unmount hangs in xfs_wait_buftarg() that
analysis shows is due to btp->bt_io_count == -1. bt_io_count
represents the count of in-flight asynchronous buffers and thus
should always be >= 0. xfs_wait_buftarg() waits for this value to
stabilize to zero in order to ensure that all untracked (with
respect to the lru) buffers have completed I/O processing before
unmount proceeds to tear down in-core data structures.

The value of -1 implies an I/O accounting decrement race. Indeed,
the fact that xfs_buf_ioacct_dec() is called from xfs_buf_rele()
(where the buffer lock is no longer held) means that bp->b_flags can
be updated from an unsafe context. While a user-level reproducer is
currently not available, some intrusive hacks to run racing buffer
lookups/ioacct/releases from multiple threads was used to
successfully manufacture this problem.

Existing callers do not expect to acquire the buffer lock from
xfs_buf_rele(). Therefore, we can not safely update ->b_flags from
this context. It turns out that we already have separate buffer
state bits and associated serialization for dealing with buffer LRU
state in the form of ->b_state and ->b_lock. Therefore, replace the
_XBF_IN_FLIGHT flag with a ->b_state variant, update the I/O
accounting wrappers appropriately and make sure they are used with
the correct locking. This ensures that buffer in-flight state can be
modified at buffer release time without racing with modifications
from a buffer lock holder.

Fixes: 9c7504aa72b6 ("xfs: track and serialize in-flight async buffers against unmount")
CC: stable@vger.kernel.org # v4.8+
Signed-off-by: Brian Foster <bfoster@redhat.com>
Reviewed-by: Nikolay Borisov <nborisov@suse.com>
Acked-by: Nikolay Borisov <nborisov@suse.com>
---
 fs/xfs/linux-2.6/xfs_buf.c | 46 ++++++++++++++++++++++++++++------------------
 fs/xfs/linux-2.6/xfs_buf.h |  6 +++---
 2 files changed, 31 insertions(+), 21 deletions(-)

diff --git a/fs/xfs/linux-2.6/xfs_buf.c b/fs/xfs/linux-2.6/xfs_buf.c
index 1485af32db43..681d60f0610e 100644
--- a/fs/xfs/linux-2.6/xfs_buf.c
+++ b/fs/xfs/linux-2.6/xfs_buf.c
@@ -103,31 +103,38 @@ xfs_buf_vmap_len(
  * the XBF_NO_IOACCT flag before I/O submission. Otherwise, the buftarg count
  * never reaches zero and unmount hangs indefinitely.
  */
-static inline void
-xfs_buf_ioacct_inc(
-   struct xfs_buf  *bp)
+static inline void xfs_buf_ioacct_inc(struct xfs_buf  *bp)
 {
-   if (bp->b_flags & (XBF_NO_IOACCT|_XBF_IN_FLIGHT))
+   if (bp->b_flags & XBF_NO_IOACCT)
        return;
 
    ASSERT(bp->b_flags & XBF_ASYNC);
-   bp->b_flags |= _XBF_IN_FLIGHT;
-   percpu_counter_inc(&bp->b_target->bt_io_count);
+   spin_lock(&bp->b_lock);
+   if (!(bp->b_state & XFS_BSTATE_IN_FLIGHT)) {
+	bp->b_state |= XFS_BSTATE_IN_FLIGHT;
+	percpu_counter_inc(&bp->b_target->bt_io_count);
+   }
+   spin_unlock(&bp->b_lock);
 }
 
 /*
  * Clear the in-flight state on a buffer about to be released to the LRU or
  * freed and unaccount from the buftarg.
  */
-static inline void
-xfs_buf_ioacct_dec(
-   struct xfs_buf  *bp)
+static inline void __xfs_buf_ioacct_dec(struct xfs_buf  *bp)
 {
-   if (!(bp->b_flags & _XBF_IN_FLIGHT))
-       return;
+	ASSERT(spin_is_locked(&bp->b_lock));
+	if (bp->b_state & XFS_BSTATE_IN_FLIGHT) {
+		bp->b_state &= ~XFS_BSTATE_IN_FLIGHT;
+		percpu_counter_dec(&bp->b_target->bt_io_count);
+	}
+}
+
 
-   bp->b_flags &= ~_XBF_IN_FLIGHT;
-   percpu_counter_dec(&bp->b_target->bt_io_count);
+static inline void xfs_buf_ioacct_dec(struct xfs_buf  *bp) {
+	spin_lock(&bp->b_lock);
+	__xfs_buf_ioacct_dec(bp);
+	spin_unlock(&bp->b_lock);
 }
 
 
@@ -198,9 +205,10 @@ xfs_buf_stale(
 	 * unaccounted (released to LRU) before that occurs. Drop in-flight
 	 * status now to preserve accounting consistency.
 	 */
-	xfs_buf_ioacct_dec(bp);
 
 	spin_lock(&bp->b_lock);
+	__xfs_buf_ioacct_dec(bp);
+
 	atomic_set(&(bp)->b_lru_ref, 0);
 	if (!list_empty(&bp->b_lru)) {
 		struct xfs_buftarg *btp = bp->b_target;
@@ -964,13 +972,13 @@ xfs_buf_rele(
 		 * ensures the decrement occurs only once per-buf.
 		 */
 		if ((atomic_read(&bp->b_hold) == 1) && !list_empty(&bp->b_lru))
-		    xfs_buf_ioacct_dec(bp);
+		    __xfs_buf_ioacct_dec(bp);
 		goto out;
 
 	}
 
 	/* the last refrence has been dropped ... */
-	xfs_buf_ioacct_dec(bp);
+	__xfs_buf_ioacct_dec(bp);
 	if (!(bp->b_flags & XBF_STALE) && atomic_read(&bp->b_lru_ref)) {
 		xfs_buf_lru_add(bp);
 		spin_unlock(&pag->pag_buf_lock);
@@ -1518,8 +1526,10 @@ xfs_wait_buftarg(
 	 * all reference counts have been dropped before we start walking the
 	 * LRU list.
 	 */
-	while (percpu_counter_sum(&btp->bt_io_count))
-	    delay(100);
+	while (percpu_counter_sum(&btp->bt_io_count)) {
+		BUG_ON(percpu_counter_sum(&btp->bt_io_count) < 0);
+		delay(100);
+	}
 	drain_workqueue(btp->bt_mount->m_buf_workqueue);
 
 restart:
diff --git a/fs/xfs/linux-2.6/xfs_buf.h b/fs/xfs/linux-2.6/xfs_buf.h
index d771ebfcc445..d7b82e133484 100644
--- a/fs/xfs/linux-2.6/xfs_buf.h
+++ b/fs/xfs/linux-2.6/xfs_buf.h
@@ -67,7 +67,6 @@ typedef enum {
 #define	_XBF_KMEM	(1 << 20)/* backed by heap memory */
 #define _XBF_DELWRI_Q	(1 << 21)/* buffer on delwri queue */
 #define _XBF_LRU_DISPOSE (1 << 24)/* buffer being discarded */
-#define _XBF_IN_FLIGHT	 (1 << 25) /* I/O in flight, for accounting purposes */
 
 typedef unsigned int xfs_buf_flags_t;
 
@@ -88,8 +87,9 @@ typedef unsigned int xfs_buf_flags_t;
 	{ _XBF_RUN_QUEUES,	"RUN_QUEUES" }, \
 	{ _XBF_KMEM,		"KMEM" }, \
 	{ _XBF_DELWRI_Q,	"DELWRI_Q" }, \
-	{ _XBF_LRU_DISPOSE,	"LRU_DISPOSE" }, \
-	{ _XBF_IN_FLIGHT,	"IN_FLIGHT" }
+	{ _XBF_LRU_DISPOSE,	"LRU_DISPOSE" }
+
+#define XFS_BSTATE_IN_FLIGHT (1 << 1) /* I/O in flight */
 
 typedef enum {
 	XBT_FORCE_SLEEP = 0,
-- 
2.7.4

