From 579b62faa5fb16ffeeb88cda5e2c4e95730881af Mon Sep 17 00:00:00 2001
From: Brian Foster <bfoster@redhat.com>
Date: Tue, 6 Nov 2012 09:50:47 -0500
Subject: [PATCH] xfs: add background scanning to clear eofblocks inodes
Git-commit: 579b62faa5fb16ffeeb88cda5e2c4e95730881af
Patch-mainline: v3.8-rc1
References: bnc#930788

Create a new mount workqueue and delayed_work to enable background
scanning and freeing of eofblocks inodes. The scanner kicks in once
speculative preallocation occurs and stops requeueing itself when
no eofblocks inodes exist.

The scan interval is based on the new
'speculative_prealloc_lifetime' tunable (default to 5m). The
background scanner performs unfiltered, best effort scans (which
skips inodes under lock contention or with a dirty cache mapping).

Signed-off-by: Brian Foster <bfoster@redhat.com>
Reviewed-by: Mark Tinguely <tinguely@sgi.com>
Reviewed-by: Dave Chinner <dchinner@redhat.com>
Signed-off-by: Ben Myers <bpm@sgi.com>
Acked-by: Jan Kara <jack@suse.cz>

---
 fs/xfs/linux-2.6/xfs_globals.c |    4 +++-
 fs/xfs/linux-2.6/xfs_linux.h   |    1 +
 fs/xfs/linux-2.6/xfs_super.c   |   17 +++++++++++++++++
 fs/xfs/linux-2.6/xfs_sync.c    |   29 +++++++++++++++++++++++++++++
 fs/xfs/linux-2.6/xfs_sync.h    |    1 +
 fs/xfs/linux-2.6/xfs_sysctl.c  |    9 +++++++++
 fs/xfs/linux-2.6/xfs_sysctl.h  |    1 +
 fs/xfs/xfs_mount.c             |    2 ++
 fs/xfs/xfs_mount.h             |    4 ++++
 9 files changed, 67 insertions(+), 1 deletion(-)

--- a/fs/xfs/linux-2.6/xfs_globals.c
+++ b/fs/xfs/linux-2.6/xfs_globals.c
@@ -21,7 +21,8 @@
 /*
  * Tunable XFS parameters.  xfs_params is required even when CONFIG_SYSCTL=n,
  * other XFS code uses these values.  Times are measured in centisecs (i.e.
- * 100ths of a second).
+ * 100ths of a second) with the exception of eofb_timer, which is measured in
+ * seconds.
  */
 xfs_param_t xfs_params = {
 			  /*	MIN		DFLT		MAX	*/
@@ -40,4 +41,5 @@ xfs_param_t xfs_params = {
 	.rotorstep	= {	1,		1,		255	},
 	.inherit_nodfrg	= {	0,		1,		1	},
 	.fstrm_timer	= {	1,		30*100,		3600*100},
+	.eofb_timer	= {	1,		300,		3600*24},
 };
--- a/fs/xfs/linux-2.6/xfs_linux.h
+++ b/fs/xfs/linux-2.6/xfs_linux.h
@@ -115,6 +115,7 @@
 #define xfs_rotorstep		xfs_params.rotorstep.val
 #define xfs_inherit_nodefrag	xfs_params.inherit_nodfrg.val
 #define xfs_fstrm_centisecs	xfs_params.fstrm_timer.val
+#define xfs_eofb_secs		xfs_params.eofb_timer.val
 
 #define current_cpu()		(raw_smp_processor_id())
 #define current_pid()		(current->pid)
--- a/fs/xfs/linux-2.6/xfs_super.c
+++ b/fs/xfs/linux-2.6/xfs_super.c
@@ -846,8 +846,22 @@ xfs_init_mount_workqueues(
 	if (!mp->m_unwritten_workqueue)
 		goto out_free_data_conv_queue_name;
 
+	wqname = kasprintf(GFP_KERNEL, "xfs-eofblocks/%s", mp->m_fsname);
+	if (!wqname)
+		goto out_destroy_data_conv_queue;
+
+	mp->m_eofblocks_workqueue_name = wqname;
+	mp->m_eofblocks_workqueue = alloc_workqueue(wqname, WQ_NON_REENTRANT, 0);
+	if (!mp->m_eofblocks_workqueue)
+		goto out_free_eofblocks_name;
+
+
 	return 0;
 
+out_free_eofblocks_name:
+	kfree(mp->m_eofblocks_workqueue_name);
+out_destroy_data_conv_queue:
+	destroy_workqueue(mp->m_unwritten_workqueue);
 out_free_data_conv_queue_name:
 	kfree(mp->m_unwritten_workqueue_name);
 out_destroy_data_iodone_queue:
@@ -865,6 +879,8 @@ xfs_destroy_mount_workqueues(
 	destroy_workqueue(mp->m_data_workqueue);
 	kfree(mp->m_unwritten_workqueue_name);
 	destroy_workqueue(mp->m_unwritten_workqueue);
+	kfree(mp->m_eofblocks_workqueue_name);
+	destroy_workqueue(mp->m_eofblocks_workqueue);
 }
 
 /* Catch misguided souls that try to use this interface on XFS */
@@ -1502,6 +1518,7 @@ xfs_fs_fill_super(
 	error = xfs_syncd_init(mp);
 	if (error)
 		goto out_unmount;
+	INIT_DELAYED_WORK(&mp->m_eofblocks_work, xfs_eofblocks_worker);
 
 	root = igrab(VFS_I(mp->m_rootip));
 	if (!root) {
--- a/fs/xfs/linux-2.6/xfs_sync.c
+++ b/fs/xfs/linux-2.6/xfs_sync.c
@@ -199,6 +199,32 @@ restart:
 	return last_error;
 }
 
+/*
+ * Background scanning to trim post-EOF preallocated space. This is queued
+ * based on the 'background_prealloc_discard_period' tunable (5m by default).
+ */
+STATIC void
+xfs_queue_eofblocks(
+	struct xfs_mount *mp)
+{
+	rcu_read_lock();
+	if (radix_tree_tagged(&mp->m_perag_tree, XFS_ICI_EOFBLOCKS_TAG))
+		queue_delayed_work(mp->m_eofblocks_workqueue,
+				   &mp->m_eofblocks_work,
+				   msecs_to_jiffies(xfs_eofb_secs * 1000));
+	rcu_read_unlock();
+}
+
+void
+xfs_eofblocks_worker(
+	struct work_struct *work)
+{
+	struct xfs_mount *mp = container_of(to_delayed_work(work),
+				struct xfs_mount, m_eofblocks_work);
+	xfs_icache_free_eofblocks(mp, NULL);
+	xfs_queue_eofblocks(mp);
+}
+
 int
 xfs_inode_ag_iterator(
 	struct xfs_mount	*mp,
@@ -1241,6 +1267,9 @@ xfs_inode_set_eofblocks_tag(
 				   XFS_ICI_EOFBLOCKS_TAG);
 		spin_unlock(&ip->i_mount->m_perag_lock);
 
+		/* kick off background trimming */
+		xfs_queue_eofblocks(ip->i_mount);
+
 		trace_xfs_perag_set_eofblocks(ip->i_mount, pag->pag_agno,
 					      -1, _RET_IP_);
 	}
--- a/fs/xfs/linux-2.6/xfs_sync.h
+++ b/fs/xfs/linux-2.6/xfs_sync.h
@@ -52,6 +52,7 @@ void __xfs_inode_clear_reclaim_tag(struc
 void xfs_inode_set_eofblocks_tag(struct xfs_inode *ip);
 void xfs_inode_clear_eofblocks_tag(struct xfs_inode *ip);
 int xfs_icache_free_eofblocks(struct xfs_mount *, struct xfs_eofblocks *);
+void xfs_eofblocks_worker(struct work_struct *);
 
 int xfs_sync_inode_grab(struct xfs_inode *ip);
 int xfs_inode_ag_iterator(struct xfs_mount *mp,
--- a/fs/xfs/linux-2.6/xfs_sysctl.c
+++ b/fs/xfs/linux-2.6/xfs_sysctl.c
@@ -202,6 +202,15 @@ static ctl_table xfs_table[] = {
 		.extra1		= &xfs_params.fstrm_timer.min,
 		.extra2		= &xfs_params.fstrm_timer.max,
 	},
+	{
+		.procname	= "speculative_prealloc_lifetime",
+		.data		= &xfs_params.eofb_timer.val,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec_minmax,
+		.extra1		= &xfs_params.eofb_timer.min,
+		.extra2		= &xfs_params.eofb_timer.max,
+	},
 	/* please keep this the last entry */
 #ifdef CONFIG_PROC_FS
 	{
--- a/fs/xfs/linux-2.6/xfs_sysctl.h
+++ b/fs/xfs/linux-2.6/xfs_sysctl.h
@@ -47,6 +47,7 @@ typedef struct xfs_param {
 	xfs_sysctl_val_t rotorstep;	/* inode32 AG rotoring control knob */
 	xfs_sysctl_val_t inherit_nodfrg;/* Inherit the "nodefrag" inode flag. */
 	xfs_sysctl_val_t fstrm_timer;	/* Filestream dir-AG assoc'n timeout. */
+	xfs_sysctl_val_t eofb_timer;	/* Interval between eofb scan wakeups */
 } xfs_param_t;
 
 /*
--- a/fs/xfs/xfs_mount.c
+++ b/fs/xfs/xfs_mount.c
@@ -1467,6 +1467,8 @@ xfs_unmountfs(
 	__uint64_t		resblks;
 	int			error;
 
+	cancel_delayed_work_sync(&mp->m_eofblocks_work);
+
 	xfs_qm_unmount_quotas(mp);
 	xfs_rtunmount_inodes(mp);
 	IRELE(mp->m_rootip);
--- a/fs/xfs/xfs_mount.h
+++ b/fs/xfs/xfs_mount.h
@@ -222,6 +222,10 @@ typedef struct xfs_mount {
 	struct workqueue_struct	*m_data_workqueue;
 	const char		*m_unwritten_workqueue_name;
 	struct workqueue_struct	*m_unwritten_workqueue;
+	struct delayed_work	m_eofblocks_work; /* background eof blocks
+						     trimming */
+	const char		*m_eofblocks_workqueue_name;
+	struct workqueue_struct *m_eofblocks_workqueue;
 #endif
 } xfs_mount_t;
 
