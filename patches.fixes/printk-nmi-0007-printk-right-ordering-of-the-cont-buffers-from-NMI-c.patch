From: Petr Mladek <pmladek@suse.cz>
Date: Wed, 7 May 2014 11:52:20 +0200
Subject: [RFC PATCH 07/11] printk: right ordering of the cont buffers from NMI
 context
Patch-mainline: Submitted, https://lkml.org/lkml/2014/5/9/126
References: bnc#831949

pmladek@suse.cz:
This patch needed some modifications for SLED12 to avoid KABI changes.
They were done using:

    sed -i \
	-e "s/struct printk_log \*/enum printk_log_type /g" \
	-e "s/struct printk_msg/struct printk_log/g" \
	-e "s/main_logbuf_lock/logbuf_lock/g" \
	-e "s/nmi_log\.buf/nmi_log_buf/g" \
	-e "s/&main_log/MAIN_LOG/g" \
	-e "s/&nmi_log/NMI_LOG/g" \
	-e "s/NMI_LOGbuf_lock/\&nmi_logbuf_lock/g" \
	-e "s/main_log\.cont/\&main_cont/g" \
	-e "s/msg_from_idx/log_from_idx/g" \
	-e "s/get_dict/log_dict/g" \
	-e "s/get_text/get_dict/g" \
	-e "s/nmi_log\.nmi\.first_id/nmi_log_first_id/g" \
	-e "s/nmi_log\.nmi\.next_id/nmi_log_next_id/g" \
	orig.patch


When using the NMI log buffer, continuous messages were sometimes mixed
after merging to the main log buffer.

The problems are solved by the following two tricks. First, continuous messages
are always put into the NMI log buffer if it already contains something. Second,
the main cont buffer is always flushed before merging any message from the NMI
log buffer.

Note that the second part of a continuous message always has to be the first
message in the NMI log buffer. If the first part goes to the main log buffer,
we have the lock for the main log buffer and merge all previous messages.

The only drawback is that we check "nmi_cont" without having "nmi_logbuf_lock".
Well, parallel NMIs are very rare. In fact, they should not happen. In the
worst case, we crate some mess in the log.

I tested this a lot. I still see that a single line might get split into two
lines from time to time. In each case, this patch helped a lot. Especially it
fixed problems with ordering of the line parts.

Signed-off-by: Petr Mladek <pmladek@suse.cz>
---
 kernel/printk/printk.c | 17 ++++++++++++++++-
 1 file changed, 16 insertions(+), 1 deletion(-)

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index e6cc6f3cf5d5..81427617e4d1 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1951,6 +1951,7 @@ static void merge_nmi_delayed_printk(void)
 	unsigned long nmi_first_id, nmi_next_id;
 	u32 old_main_next_idx;
 	u64 old_main_next_seq;
+	int main_cont_flushed = 0;
 
 	while (true) {
 		/*
@@ -1963,6 +1964,15 @@ static void merge_nmi_delayed_printk(void)
 		if (likely(nmi_merge_seq == seq_from_id(nmi_next_id)))
 			return;
 
+		/*
+		 * The main cont buffer might include the first part of the
+		 * first message from NMI context.
+		 */
+		if (unlikely(!main_cont_flushed)) {
+			cont_flush(MAIN_LOG, LOG_CONT);
+			main_cont_flushed = 1;
+		}
+
 		/* check if we lost some messages */
 		nmi_first_id = ACCESS_ONCE(nmi_log_first_id);
 		if (nmi_seq_is_invalid(nmi_merge_seq,
@@ -2076,7 +2086,12 @@ asmlinkage int vprintk_emit(int facility, int level,
 	if (likely(!in_nmi())) {
 		raw_spin_lock(&logbuf_lock);
 	} else {
-		if (!raw_spin_trylock(&logbuf_lock)) {
+		/*
+		 * Always use NMI ring buffer if something is already
+		 * in the cont buffer.
+		 */
+		if ((nmi_cont.len && nmi_cont.owner == current) ||
+		    !raw_spin_trylock(&logbuf_lock)) {
 			if (!nmi_log_buf) {
 				lockdep_on();
 				local_irq_restore(flags);
-- 
1.8.4

