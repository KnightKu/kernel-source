From 4d83a9cf0e822b3c858ed5543d89d2c8f835decd Mon Sep 17 00:00:00 2001
From: Carlos Maiolino <cmaiolino@redhat.com>
Date: Fri, 21 Jun 2013 14:45:53 -0300
Acked-by: Ales Novak <alnovak@suse.cz>
Git-commit: 42c49d7f249c2487f36d3314753d5d8ebcee8249
Patch-mainline: v3.10-rc1
References: bsc#965860
Subject: [PATCH] xfs: fix sgid inheritance for subdirectories inheriting
 default acls [V3]

XFS removes sgid bits of subdirectories under a directory containing a default
acl.

When a default acl is set, it implies xfs to call xfs_setattr_nonsize() in its
code path. Such function is shared among mkdir and chmod system calls, and
does some checks unneeded by mkdir (calling inode_change_ok()). Such checks
remove sgid bit from the inode after it has been granted.

With this patch, we extend the meaning of XFS_ATTR_NOACL flag to avoid these
checks when acls are being inherited (thanks hch).

Also, xfs_setattr_mode, doesn't need to re-check for group id and capabilities
permissions, this only implies in another try to remove sgid bit from the
directories. Such check is already done either on inode_change_ok() or
xfs_setattr_nonsize().

Changelog:

V2: Extends the meaning of XFS_ATTR_NOACL instead of wrap the tests into another
    function

V3: Remove S_ISDIR check in xfs_setattr_nonsize() from the patch

Signed-off-by: Carlos Maiolino <cmaiolino@redhat.com>
Reviewed-by: Ben Myers <bpm@sgi.com>
Signed-off-by: Ben Myers <bpm@sgi.com>
---
 fs/xfs/xfs_vnodeops.c | 19 +++++++++----------
 1 file changed, 9 insertions(+), 10 deletions(-)

diff --git a/fs/xfs/xfs_vnodeops.c b/fs/xfs/xfs_vnodeops.c
index 65e8e99..afe37e0 100644
--- a/fs/xfs/xfs_vnodeops.c
+++ b/fs/xfs/xfs_vnodeops.c
@@ -71,15 +71,17 @@ xfs_setattr(
 
 	trace_xfs_setattr(ip);
 
-	if (mp->m_flags & XFS_MOUNT_RDONLY)
-		return XFS_ERROR(EROFS);
+	if (iattr->ia_valid & ATTR_SIZE || !(flags & XFS_ATTR_NOACL)) {
+		if (mp->m_flags & XFS_MOUNT_RDONLY)
+			return XFS_ERROR(EROFS);
 
-	if (XFS_FORCED_SHUTDOWN(mp))
-		return XFS_ERROR(EIO);
+		if (XFS_FORCED_SHUTDOWN(mp))
+			return XFS_ERROR(EIO);
 
-	code = -inode_change_ok(inode, iattr);
-	if (code)
-		return code;
+		code = -inode_change_ok(inode, iattr);
+		if (code)
+			return code;
+	}
 
 	olddquot1 = olddquot2 = NULL;
 	udqp = gdqp = NULL;
@@ -388,9 +390,6 @@ xfs_setattr(
 	if (mask & ATTR_MODE) {
 		umode_t mode = iattr->ia_mode;
 
-		if (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))
-			mode &= ~S_ISGID;
-
 		ip->i_d.di_mode &= S_IFMT;
 		ip->i_d.di_mode |= mode & ~S_IFMT;
 
-- 
2.7.0

