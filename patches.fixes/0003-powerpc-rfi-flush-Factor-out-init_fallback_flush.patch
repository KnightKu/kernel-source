From cbe52de48c75b8cb1b5eeea2178d5e8bdb129c86 Mon Sep 17 00:00:00 2001
From: Michael Ellerman <mpe@ellerman.id.au>
Date: Thu, 11 Jan 2018 16:57:39 +1100
Subject: [PATCH 3/6] powerpc/rfi-flush: Factor out init_fallback_flush()
Patch-mainline: Submitted, 2018-01-09 LKML + linuxppc-dev
References: bsc#1075088

In upstream this function can fail so it's pulled out to cater for
that. In SLES11 it can't fail so this is purely cosmetic to reduce the
size of the diff vs upstream.

Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Reviewed-by: Torsten Duwe <duwe@suse.de>
---
 arch/powerpc/kernel/setup_64.c | 64 +++++++++++++++++++++++-------------------
 1 file changed, 35 insertions(+), 29 deletions(-)

diff --git a/arch/powerpc/kernel/setup_64.c b/arch/powerpc/kernel/setup_64.c
index 78cc12dd7414..20bf40a925fd 100644
--- a/arch/powerpc/kernel/setup_64.c
+++ b/arch/powerpc/kernel/setup_64.c
@@ -716,41 +716,47 @@ void rfi_flush_enable(bool enable)
 	rfi_flush = enable;
 }
 
-void __init setup_rfi_flush(enum l1d_flush_type types, bool enable)
+static void init_fallback_flush(void)
 {
-	if (types & L1D_FLUSH_FALLBACK) {
-		int cpu;
-		u64 l1d_size = ppc64_caches.dsize;
+	u64 l1d_size;
+	int cpu;
 
-		pr_info("rfi-flush: Using fallback displacement flush\n");
+	l1d_size = ppc64_caches.dsize;
 
+	/*
+	 * We allocate 2x L1d size for the dummy area, to
+	 * catch possible hardware prefetch runoff.
+	 *
+	 * We can't use memblock_alloc here because bootmem has
+	 * been initialized, and the bootmem APIs don't work well
+	 * with an upper limit we need, so we allocate it statically
+	 * from BSS. The biggest L1d supported by this kernel is
+	 * 64kB (POWER8), so 128kB is reserved above.
+	 */
+	WARN_ON(l1d_size > MAX_L1D_SIZE);
+
+	for_each_possible_cpu(cpu) {
 		/*
-		 * We allocate 2x L1d size for the dummy area, to
-		 * catch possible hardware prefetch runoff.
+		 * The fallback flush is currently coded for 8-way
+		 * associativity. Different associativity is possible, but it
+		 * will be treated as 8-way and may not evict the lines as
+		 * effectively.
 		 *
-		 * We can't use memblock_alloc here because bootmem has
-		 * been initialized, and the bootmem APIs don't work well
-		 * with an upper limit we need, so we allocate it statically
-		 * from BSS. The biggest L1d supported by this kernel is
-		 * 64kB (POWER8), so 128kB is reserved above.
+		 * 128 byte lines are mandatory.
 		 */
-		WARN_ON(l1d_size > MAX_L1D_SIZE);
-
-		for_each_possible_cpu(cpu) {
-			/*
-			 * The fallback flush is currently coded for 8-way
-			 * associativity. Different associativity is possible,
-			 * but it will be treated as 8-way and may not evict
-			 * the lines as effectively.
-			 *
-			 * 128 byte lines are mandatory.
-			 */
-			u64 c = l1d_size / 8;
-
-			paca[cpu].rfi_flush_fallback_area = l1d_flush_fallback_area;
-			paca[cpu].l1d_flush_congruence = c;
-			paca[cpu].l1d_flush_sets = c / 128;
-		}
+		u64 c = l1d_size / 8;
+
+		paca[cpu].rfi_flush_fallback_area = l1d_flush_fallback_area;
+		paca[cpu].l1d_flush_congruence = c;
+		paca[cpu].l1d_flush_sets = c / 128;
+	}
+}
+
+void __init setup_rfi_flush(enum l1d_flush_type types, bool enable)
+{
+	if (types & L1D_FLUSH_FALLBACK) {
+		pr_info("rfi-flush: Using fallback displacement flush\n");
+		init_fallback_flush();
 	}
 
 	if (types & L1D_FLUSH_ORI)
-- 
2.14.3

