From: Aurelien Aptel <aaptel@suse.com>
Subject: fs/cifs: fix wrongly prefixed path to root
Patch-mainline: Submitted, linux-cifs 2016-04-20
References: bsc#963655, bsc#979681

When cifs_get_root() calls cifs_build_path_to_root(), it expects a full
path from the root, even in the presence of a DFS link.

e.g. in the case of a DFS link like

    //A/shareA/link -> //B/shareB/sub/dir/

When mounting shareA and doing a "cd link", cifs_get_root() was getting

    "//B/shareB//sub/dir"

Instead of

    "/sub/dir"

Resulting in

    sh: cd: link: No such file or directory

--- a/fs/cifs/inode.c
+++ b/fs/cifs/inode.c
@@ -793,31 +793,15 @@ char *cifs_build_path_to_root(struct smb
 			      struct cifs_tcon *tcon)
 {
 	int pplen = vol->prepath ? strlen(vol->prepath) : 0;
-	int dfsplen;
 	char *full_path = NULL;

-	/* if no prefix path, simply set path to the root of share to "" */
-	if (pplen == 0) {
-		full_path = kmalloc(1, GFP_KERNEL);
-		if (full_path)
-			full_path[0] = 0;
-		return full_path;
-	}
-
-	if (tcon->Flags & SMB_SHARE_IS_IN_DFS)
-		dfsplen = strnlen(tcon->treeName, MAX_TREE_SIZE + 1);
-	else
-		dfsplen = 0;
-
-	full_path = kmalloc(dfsplen + pplen + 1, GFP_KERNEL);
+	full_path = kmalloc(pplen + 1, GFP_KERNEL);
 	if (full_path == NULL)
 		return full_path;

-	if (dfsplen)
-		strncpy(full_path, tcon->treeName, dfsplen);
-	strncpy(full_path + dfsplen, vol->prepath, pplen);
+	strncpy(full_path, vol->prepath, pplen);
 	convert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));
-	full_path[dfsplen + pplen] = 0; /* add trailing null */
+	full_path[pplen] = 0; /* add trailing null */
 	return full_path;
 }

