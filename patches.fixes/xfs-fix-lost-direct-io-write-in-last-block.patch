From: Jan Kara <jack@suse.com>
Subject: xfs: Fix lost direct IO write in the last block
References: bsc#949744
Patch-mainline: Never, functionality achieved by 40c63fbc55a9, 3136e8bb3054

When doing AIO DIO write starting beyond EOF, we call xfs_zero_eof() to zero
out part of the last block that becomes a hole. xfs_zero_eof() is called under
XFS_IOLOCK_EXCL so that excludes any buffered write or parallel submission of
any direct IO write to that block however there can be direct IO overwriting
(part of) that block still in flight. And the read-modify-write cycle in
xfs_zero_eof() can thus overwrite the data that are just in flight.

Fix the problem by waiting for all the IO to drain before zeroing part of
the last block.

Signed-off-by: Jan Kara <jack@suse.com>

---
 fs/xfs/linux-2.6/xfs_file.c |   13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

--- a/fs/xfs/linux-2.6/xfs_file.c
+++ b/fs/xfs/linux-2.6/xfs_file.c
@@ -791,8 +791,19 @@ start:
 	 * blocks that fall between the existing EOF and the start of this
 	 * write.
 	 */
-	if (*pos > ip->i_size)
+	if (*pos > ip->i_size) {
+		xfs_rw_iunlock(ip, XFS_ILOCK_EXCL);
+		/*
+		 * We hold XFS_IOLOCK_EXCL but there can still be AIO DIO in
+		 * flight for the last block we want to zero out part of. Wait
+		 * for it so that we don't lose that data. Since we hold
+		 * XFS_IOLOCK_EXCL all the time, ip->i_size cannot change under
+		 * us and we are safe to continue without restart.
+		 */
+		xfs_ioend_wait(ip);
+		xfs_rw_ilock(ip, XFS_ILOCK_EXCL);
 		error = -xfs_zero_eof(ip, *pos, ip->i_size);
+	}
 
 	xfs_rw_iunlock(ip, XFS_ILOCK_EXCL);
 	if (error)
