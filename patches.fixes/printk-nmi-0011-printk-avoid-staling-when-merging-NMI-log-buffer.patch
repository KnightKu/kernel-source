From: Petr Mladek <pmladek@suse.cz>
Date: Thu, 17 Apr 2014 11:07:16 +0200
Subject: [RFC PATCH 11/11] printk: avoid staling when merging NMI log buffer
Patch-mainline: Submitted https://lkml.org/lkml/2014/5/9/141
References: bnc#831949

pmladek@suse.cz:
This patch needed some modifications for SLED12 to avoid KABI changes.
They were done using:

    sed -i \
	-e "s/struct printk_log \*/enum printk_log_type /g" \
	-e "s/struct printk_msg/struct printk_log/g" \
	-e "s/main_logbuf_lock/logbuf_lock/g" \
	-e "s/nmi_log\.buf/nmi_log_buf/g" \
	-e "s/&main_log/MAIN_LOG/g" \
	-e "s/&nmi_log/NMI_LOG/g" \
	-e "s/NMI_LOGbuf_lock/\&nmi_logbuf_lock/g" \
	-e "s/main_log\.cont/\&main_cont/g" \
	-e "s/msg_from_idx/log_from_idx/g" \
	-e "s/get_dict/log_dict/g" \
	-e "s/get_text/get_dict/g" \
	-e "s/nmi_log\.nmi\.first_id/nmi_log_first_id/g" \
	-e "s/nmi_log\.nmi\.next_id/nmi_log_next_id/g" \
	orig.patch


New messages can appear in NMI log buffer at any time. The call merging them
into the main log buffer might have hard times to catch up with the flood. It
can be even interrupted by an NMI that adds new messages itself.

It would make sense to limit the number of copied messages and postpone
the merging to a later time and even another CPU. We could nicely reuse
the IRQ work here.

One drawback is that it might create mess when merging continuous lines
but this would be very rare. IMHO, it is not worth making the code more
complicated.

To be honest, I am not much happy with the current limit 5000 messages.
The number is sucked out of my little finger ;-) I would feel better with
some limit but I also might be too paranoid. Any better idea is welcome.

Signed-off-by: Petr Mladek <pmladek@suse.cz>
---
 kernel/printk/printk.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 6e006ce248cb..ae28a2754a22 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -372,6 +372,8 @@ static struct printk_cont nmi_cont = {
  */
 #define NMI_MAX_LEN_POWER (min(NMI_IDX_BYTES, sizeof(nmi_log_buf_len) * 8 - 1))
 #define NMI_MAX_LEN (1UL << NMI_MAX_LEN_POWER)
+/* maximum number of merged strings in one call */
+#define NMI_MAX_MERGE 5000
 
 static struct printk_cont *get_cont(enum printk_log_type log)
 {
@@ -2017,6 +2019,7 @@ static void merge_nmi_delayed_printk(void)
 	u32 old_main_next_idx;
 	u64 old_main_next_seq;
 	int main_cont_flushed = 0;
+	int merged = 0;
 
 	while (true) {
 		/*
@@ -2047,6 +2050,13 @@ restart_merge:
 			nmi_merge_idx = idx_from_id(nmi_first_id);
 		}
 
+		/* do not stale CPU with too many merges */
+		if (merged++ > NMI_MAX_MERGE) {
+			__this_cpu_or(printk_pending, PRINTK_PENDING_OUTPUT);
+			irq_work_queue(&__get_cpu_var(wake_up_klogd_work));
+			return;
+		}
+
 		/*
 		 * Make sure that the whole message has been written for the
 		 * given idx.
-- 
1.8.4

