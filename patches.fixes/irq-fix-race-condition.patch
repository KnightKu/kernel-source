From: Joerg Roedel <jroedel@suse.de>
Subject: irq: Fix race condition
Patch-mainline: never, upstream code was rewritten
References: bsc#1042615

There is a race condition in generic kernel IRQ code between
irq-decriptor setup and the irq allocation bitmap. Fix it by
not releasing the lock between the update of these two data
structures.

Signed-off-by: Joerg Roedel <jroedel@suse.de>
---
 kernel/irq/irqdesc.c | 11 ++---------
 1 file changed, 2 insertions(+), 9 deletions(-)
--- a/kernel/irq/irqdesc.c
+++ b/kernel/irq/irqdesc.c
@@ -181,9 +181,7 @@ static void free_desc(unsigned int irq)
 	 * sparse tree we can free it. Access in proc will fail to
 	 * lookup the descriptor.
 	 */
-	mutex_lock(&sparse_irq_lock);
 	delete_irq_desc(irq);
-	mutex_unlock(&sparse_irq_lock);
 
 	free_masks(desc);
 	free_percpu(desc->kstat_irqs);
@@ -199,9 +197,7 @@ static int alloc_descs(unsigned int star
 		desc = alloc_desc(start + i, node);
 		if (!desc)
 			goto err;
-		mutex_lock(&sparse_irq_lock);
 		irq_insert_desc(start + i, desc);
-		mutex_unlock(&sparse_irq_lock);
 	}
 	return start;
 
@@ -209,9 +205,7 @@ err:
 	for (i--; i >= 0; i--)
 		free_desc(start + i);
 
-	mutex_lock(&sparse_irq_lock);
 	bitmap_clear(allocated_irqs, start, cnt);
-	mutex_unlock(&sparse_irq_lock);
 	return -ENOMEM;
 }
 
@@ -336,10 +330,10 @@ void irq_free_descs(unsigned int from, u
 	if (from >= nr_irqs || (from + cnt) > nr_irqs)
 		return;
 
+	mutex_lock(&sparse_irq_lock);
 	for (i = 0; i < cnt; i++)
 		free_desc(from + i);
 
-	mutex_lock(&sparse_irq_lock);
 	bitmap_clear(allocated_irqs, from, cnt);
 	mutex_unlock(&sparse_irq_lock);
 }
@@ -383,8 +377,7 @@ irq_alloc_descs(int irq, unsigned int fr
 	}
 
 	bitmap_set(allocated_irqs, start, cnt);
-	mutex_unlock(&sparse_irq_lock);
-	return alloc_descs(start, cnt, node);
+	ret = alloc_descs(start, cnt, node);
 
 err:
 	mutex_unlock(&sparse_irq_lock);
