From: Jan Kara <jack@suse.cz>
Subject: quota: Fix use of units in quota getting / setting interfaces
Patch-mainline: Never (fixed differently by 14bf61ffe6ac)
References: bnc#913232

Currently ->get_dqblk() and ->set_dqblk() use struct fs_disk_quota which
tracks space limits and usage in 512-byte blocks. However VFS quotas
track usage in bytes (as some filesystems require that) and we need to
somehow pass this information. Upto now it wasn't a problem because we
didn't do any unit conversion (thus VFS quota routines happily stuck
number of bytes into d_bcount field of struct fs_disk_quota). Only if
you tried to use Q_XGETQUOTA or Q_XSETQLIM for VFS quotas (or Q_GETQUOTA
/ Q_SETQUOTA for XFS quotas), you got bogus results. Hardly anyone
tried this but reportedly some Samba users hit the problem in practice.
So when we want interfaces compatible we need to fix this.

Fix the problem by making VFS quota store limits in basic blocks into
struct fs_disk_quota and XFS & GFS2 store used space in bytes. We convert
the passed value to / from appropriate units depending on which quotactl user
actually called (GETQUOTA vs GETXQUOTA, SETQUOTA vs XSETQLIM).

We choose this fix because upstream fix 14bf61ffe6ac (quota: Switch
->get_dqblk() and ->set_dqblk() to use bytes as space units) changes kABI
heavily.

Signed-off-by: Jan Kara <jack@suse.cz>

---
 fs/gfs2/quota.c          |    6 +++---
 fs/quota/dquot.c         |   18 ++++--------------
 fs/quota/quota.c         |   30 ++++++++++++++++++++++++------
 fs/xfs/xfs_qm_syscalls.c |    1 +
 include/linux/quotaops.h |   10 ++++++++++
 5 files changed, 42 insertions(+), 23 deletions(-)

--- a/fs/gfs2/quota.c
+++ b/fs/gfs2/quota.c
@@ -679,7 +679,7 @@ static int gfs2_adjust_quota(struct gfs2
 			qd->qd_qb.qb_limit = qp->qu_limit;
 		}
 		if (fdq->d_fieldmask & FS_DQ_BCOUNT) {
-			qp->qu_value = cpu_to_be64(fdq->d_bcount >> sdp->sd_fsb2bb_shift);
+			qp->qu_value = cpu_to_be64(fdq->d_bcount >> inode->i_sb->s_blocksize_bits);
 			qd->qd_qb.qb_value = qp->qu_value;
 		}
 	}
@@ -1497,7 +1497,7 @@ static int gfs2_get_dqblk(struct super_b
 	fdq->d_id = from_kqid_munged(current_user_ns(), qid);
 	fdq->d_blk_hardlimit = be64_to_cpu(qlvb->qb_limit) << sdp->sd_fsb2bb_shift;
 	fdq->d_blk_softlimit = be64_to_cpu(qlvb->qb_warn) << sdp->sd_fsb2bb_shift;
-	fdq->d_bcount = be64_to_cpu(qlvb->qb_value) << sdp->sd_fsb2bb_shift;
+	fdq->d_bcount = be64_to_cpu(qlvb->qb_value) << sb->s_blocksize_bits;
 
 	gfs2_glock_dq_uninit(&q_gh);
 out:
@@ -1562,7 +1562,7 @@ static int gfs2_set_dqblk(struct super_b
 		fdq->d_fieldmask ^= FS_DQ_BHARD;
 
 	if ((fdq->d_fieldmask & FS_DQ_BCOUNT) &&
-	    ((fdq->d_bcount >> sdp->sd_fsb2bb_shift) == be64_to_cpu(qd->qd_qb.qb_value)))
+	    ((fdq->d_bcount >> sb->s_blocksize_bits) == be64_to_cpu(qd->qd_qb.qb_value)))
 		fdq->d_fieldmask ^= FS_DQ_BCOUNT;
 
 	if (fdq->d_fieldmask == 0)
--- a/fs/quota/dquot.c
+++ b/fs/quota/dquot.c
@@ -2396,16 +2396,6 @@ out:
 }
 EXPORT_SYMBOL(dquot_quota_on_mount);
 
-static inline qsize_t qbtos(qsize_t blocks)
-{
-	return blocks << QIF_DQBLKSIZE_BITS;
-}
-
-static inline qsize_t stoqb(qsize_t space)
-{
-	return (space + QIF_DQBLKSIZE - 1) >> QIF_DQBLKSIZE_BITS;
-}
-
 /* Generic routine for getting common part of quota structure */
 static void do_get_dqblk(struct dquot *dquot, struct fs_disk_quota *di)
 {
@@ -2418,8 +2408,8 @@ static void do_get_dqblk(struct dquot *d
 	di->d_id = from_kqid_munged(current_user_ns(), dquot->dq_id);
 
 	spin_lock(&dq_data_lock);
-	di->d_blk_hardlimit = stoqb(dm->dqb_bhardlimit);
-	di->d_blk_softlimit = stoqb(dm->dqb_bsoftlimit);
+	di->d_blk_hardlimit = stobb(dm->dqb_bhardlimit);
+	di->d_blk_softlimit = stobb(dm->dqb_bsoftlimit);
 	di->d_ino_hardlimit = dm->dqb_ihardlimit;
 	di->d_ino_softlimit = dm->dqb_isoftlimit;
 	di->d_bcount = dm->dqb_curspace + dm->dqb_rsvspace;
@@ -2477,9 +2467,9 @@ static int do_set_dqblk(struct dquot *dq
 	}
 
 	if (di->d_fieldmask & FS_DQ_BSOFT)
-		dm->dqb_bsoftlimit = qbtos(di->d_blk_softlimit);
+		dm->dqb_bsoftlimit = bbtos(di->d_blk_softlimit);
 	if (di->d_fieldmask & FS_DQ_BHARD)
-		dm->dqb_bhardlimit = qbtos(di->d_blk_hardlimit);
+		dm->dqb_bhardlimit = bbtos(di->d_blk_hardlimit);
 	if (di->d_fieldmask & (FS_DQ_BSOFT | FS_DQ_BHARD)) {
 		check_blim = 1;
 		set_bit(DQ_LASTSET_B + QIF_BLIMITS_B, &dquot->dq_flags);
--- a/fs/quota/quota.c
+++ b/fs/quota/quota.c
@@ -115,10 +115,16 @@ static int quota_setinfo(struct super_bl
 	return sb->s_qcop->set_info(sb, type, &info);
 }
 
+/* Convert from XFS basic blocks (512) to quota blocks (1024) */
+static u64 bbtoqb(u64 val)
+{
+	return val >> (QIF_DQBLKSIZE_BITS - 9);
+}
+
 static void copy_to_if_dqblk(struct if_dqblk *dst, struct fs_disk_quota *src)
 {
-	dst->dqb_bhardlimit = src->d_blk_hardlimit;
-	dst->dqb_bsoftlimit = src->d_blk_softlimit;
+	dst->dqb_bhardlimit = bbtoqb(src->d_blk_hardlimit);
+	dst->dqb_bsoftlimit = bbtoqb(src->d_blk_softlimit);
 	dst->dqb_curspace = src->d_bcount;
 	dst->dqb_ihardlimit = src->d_ino_hardlimit;
 	dst->dqb_isoftlimit = src->d_ino_softlimit;
@@ -150,10 +156,16 @@ static int quota_getquota(struct super_b
 	return 0;
 }
 
+/* Convert from quota blocks (1024) to XFS basic blocks (512) */
+static u64 qbtobb(u64 val)
+{
+	return val << (QIF_DQBLKSIZE_BITS - 9);
+}
+
 static void copy_from_if_dqblk(struct fs_disk_quota *dst, struct if_dqblk *src)
 {
-	dst->d_blk_hardlimit = src->dqb_bhardlimit;
-	dst->d_blk_softlimit  = src->dqb_bsoftlimit;
+	dst->d_blk_hardlimit = qbtobb(src->dqb_bhardlimit);
+	dst->d_blk_softlimit = qbtobb(src->dqb_bsoftlimit);
 	dst->d_bcount = src->dqb_curspace;
 	dst->d_ino_hardlimit = src->dqb_ihardlimit;
 	dst->d_ino_softlimit = src->dqb_isoftlimit;
@@ -256,6 +268,8 @@ static int quota_setxquota(struct super_
 	qid = make_kqid(current_user_ns(), type, id);
 	if (!qid_valid(qid))
 		return -EINVAL;
+	/* We pass number in bytes, convert from basic blocks */
+	fdq.d_bcount = bbtos(fdq.d_bcount);
 	return sb->s_qcop->set_dqblk(sb, qid, &fdq);
 }
 
@@ -272,8 +286,12 @@ static int quota_getxquota(struct super_
 	if (!qid_valid(qid))
 		return -EINVAL;
 	ret = sb->s_qcop->get_dqblk(sb, qid, &fdq);
-	if (!ret && copy_to_user(addr, &fdq, sizeof(fdq)))
-		return -EFAULT;
+	if (!ret) {
+		/* We pass number in bytes, convert to basic blocks */
+		fdq.d_bcount = stobb(fdq.d_bcount);
+		if (copy_to_user(addr, &fdq, sizeof(fdq)))
+			return -EFAULT;
+	}
 	return ret;
 }
 
--- a/fs/xfs/xfs_qm_syscalls.c
+++ b/fs/xfs/xfs_qm_syscalls.c
@@ -915,6 +915,7 @@ xfs_qm_scall_getquota(
 		}
 	}
 #endif
+	dst->d_bcount = BBTOB(dst->d_bcount);
 out_put:
 	xfs_qm_dqput(dqp);
 	return error;
--- a/include/linux/quotaops.h
+++ b/include/linux/quotaops.h
@@ -386,4 +386,14 @@ static inline void dquot_release_reserva
 	__dquot_free_space(inode, nr << inode->i_blkbits, DQUOT_SPACE_RESERVE);
 }
 
+static inline qsize_t bbtos(qsize_t blocks)
+{
+	return blocks << 9;
+}
+
+static inline qsize_t stobb(qsize_t space)
+{
+	return (space + 511) >> 9;
+}
+
 #endif /* _LINUX_QUOTAOPS_ */
