From: Jan Kara <jack@suse.cz>
Subject: dentry name snapshots
Patch-mainline: Never, fixed differently by 49d31c2f389a
References: bsc#1049483 CVE-2017-7533

take_dentry_name_snapshot() takes a safe snapshot of dentry name;
if the name is a short one, it gets copied into caller-supplied
structure, otherwise an extra reference to external name is grabbed
(those are never modified).  In either case the pointer to stable
string is stored into the same structure.

dentry must be held by the caller of take_dentry_name_snapshot(),
but may be freely dropped afterwards - the snapshot will stay
until destroyed by release_dentry_name_snapshot().

Intended use:
        struct name_snapshot s;

        take_dentry_name_snapshot(&s, dentry);
        ...
        access s.name
        ...
        release_dentry_name_snapshot(&s);

We use the snapshots in fsnotify to get a stable name we can pass to fsnotify
callbacks and thus avoid possible use after free issues when racing with
rename.

Signed-off-by: Jan Kara <jack@suse.cz>

---
 fs/notify/fsnotify.c |   62 +++++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 60 insertions(+), 2 deletions(-)

--- a/fs/notify/fsnotify.c
+++ b/fs/notify/fsnotify.c
@@ -86,6 +86,55 @@ void __fsnotify_update_child_dentry_flag
 	spin_unlock(&inode->i_lock);
 }
 
+struct name_snapshot {
+	const char *name;
+	char inline_name[DNAME_INLINE_LEN];
+};
+
+/*
+ * Copy dentry name without holding i_mutex on the directory. We have to be
+ * very careful as the name can be changing under us until we grab d_lock.
+ */
+static void take_dentry_name_snapshot(struct name_snapshot *name,
+				      struct dentry *dentry)
+{
+	char *namebuf = NULL;
+	unsigned int len;
+
+restart:
+	/* Opportunistic check and buffer allocation without lock... */
+	if (dname_external(dentry)) {
+		len = ACCESS_ONCE(dentry->d_name.len);
+		namebuf = kmalloc(len + 1, GFP_KERNEL);
+	}
+	spin_lock(&dentry->d_lock);
+	/* Check reliably under the lock */
+	if (dname_external(dentry)) {
+		if (!namebuf || len < dentry->d_name.len) {
+			spin_unlock(&dentry->d_lock);
+			kfree(namebuf);
+			namebuf = NULL;
+			goto restart;
+		}
+		memcpy(namebuf, dentry->d_name.name, len + 1);
+		name->name = namebuf;
+		namebuf = NULL;
+	} else {
+		memcpy(name->inline_name, dentry->d_name.name,
+		       dentry->d_name.len + 1);
+		name->name = name->inline_name;
+	}
+	spin_unlock(&dentry->d_lock);
+	/* Free buffer if it wasn't used */
+	kfree(namebuf);
+}
+
+static void release_dentry_name_snapshot(struct name_snapshot *name)
+{
+	if (unlikely(name->name != name->inline_name))
+		kfree(name->name);
+}
+
 /* Notify this dentry's parent about a child's events. */
 int __fsnotify_parent(struct path *path, struct dentry *dentry, __u32 mask)
 {
@@ -105,16 +154,25 @@ int __fsnotify_parent(struct path *path,
 	if (unlikely(!fsnotify_inode_watches_children(p_inode)))
 		__fsnotify_update_child_dentry_flags(p_inode);
 	else if (p_inode->i_fsnotify_mask & mask) {
+		struct name_snapshot name;
+
 		/* we are notifying a parent so come up with the new mask which
 		 * specifies these are events which came from a child. */
 		mask |= FS_EVENT_ON_CHILD;
 
+		/*
+		 * We have to ve *very* careful here as dentry->d_name can be
+		 * changing under us (e.g. during open we don't hold anything
+		 * protecting from rename(2) changing the dentry).
+		 */
+		take_dentry_name_snapshot(&name, dentry);
 		if (path)
 			ret = fsnotify(p_inode, mask, path, FSNOTIFY_EVENT_PATH,
-				       dentry->d_name.name, 0);
+				       name.name, 0);
 		else
 			ret = fsnotify(p_inode, mask, dentry->d_inode, FSNOTIFY_EVENT_INODE,
-				       dentry->d_name.name, 0);
+				       name.name, 0);
+		release_dentry_name_snapshot(&name);
 	}
 
 	dput(parent);
