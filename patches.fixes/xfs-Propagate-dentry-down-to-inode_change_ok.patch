From 5166c7ae0b6f0e203f5b478f16669c13c7fe232e Mon Sep 17 00:00:00 2001
From: Jan Kara <jack@suse.cz>
Date: Thu, 26 May 2016 14:46:43 +0200
Subject: [PATCH 1/4] xfs: Propagate dentry down to inode_change_ok()
Git-commit: 69bca80744eef58fa155e8042996b968fec17b26
Patch-mainline: v4.9-rc1
References: bsc#914939 CVE-2015-1350

To avoid clearing of capabilities or security related extended
attributes too early, inode_change_ok() will need to take dentry instead
of inode. Propagate dentry down to functions calling inode_change_ok().
This is rather straightforward except for xfs_set_mode() function which
does not have dentry easily available. Luckily that function does not
call inode_change_ok() anyway so we just have to do a little dance with
function prototypes.

Acked-by: Dave Chinner <dchinner@redhat.com>
Reviewed-by: Christoph Hellwig <hch@lst.de>
Signed-off-by: Jan Kara <jack@suse.cz>

---
 fs/xfs/linux-2.6/xfs_acl.c  |    2 -
 fs/xfs/linux-2.6/xfs_file.c |    3 +
 fs/xfs/linux-2.6/xfs_iops.c |    2 -
 fs/xfs/xfs_vnodeops.c       |   74 +++++++++++++++++++++++++++++++++++---------
 fs/xfs/xfs_vnodeops.h       |    2 +
 5 files changed, 66 insertions(+), 17 deletions(-)

--- a/fs/xfs/linux-2.6/xfs_acl.c
+++ b/fs/xfs/linux-2.6/xfs_acl.c
@@ -266,7 +266,7 @@ xfs_set_mode(struct inode *inode, mode_t
 		iattr.ia_mode = mode;
 		iattr.ia_ctime = current_fs_time(inode->i_sb);
 
-		error = -xfs_setattr(XFS_I(inode), &iattr, XFS_ATTR_NOACL);
+		error = -__xfs_setattr(XFS_I(inode), &iattr, XFS_ATTR_NOACL);
 	}
 
 	return error;
--- a/fs/xfs/linux-2.6/xfs_file.c
+++ b/fs/xfs/linux-2.6/xfs_file.c
@@ -965,7 +965,8 @@ xfs_file_fallocate(
 
 		iattr.ia_valid = ATTR_SIZE;
 		iattr.ia_size = new_size;
-		error = -xfs_setattr(ip, &iattr, XFS_ATTR_NOLOCK);
+		error = -xfs_setattr_dentry(file->f_dentry, &iattr,
+					    XFS_ATTR_NOLOCK);
 	}
 
 out_unlock:
--- a/fs/xfs/linux-2.6/xfs_iops.c
+++ b/fs/xfs/linux-2.6/xfs_iops.c
@@ -510,7 +510,7 @@ xfs_vn_setattr(
 	struct dentry	*dentry,
 	struct iattr	*iattr)
 {
-	return -xfs_setattr(XFS_I(dentry->d_inode), iattr, 0);
+	return -xfs_setattr_dentry(dentry, iattr, 0);
 }
 
 #define XFS_FIEMAP_FLAGS	(FIEMAP_FLAG_SYNC|FIEMAP_FLAG_XATTR)
--- a/fs/xfs/xfs_vnodeops.c
+++ b/fs/xfs/xfs_vnodeops.c
@@ -51,7 +51,7 @@
 #include "xfs_trace.h"
 
 int
-xfs_setattr(
+__xfs_setattr(
 	struct xfs_inode	*ip,
 	struct iattr		*iattr,
 	int			flags)
@@ -68,18 +68,6 @@ xfs_setattr(
 	struct xfs_dquot	*udqp, *gdqp, *olddquot1, *olddquot2;
 	int			need_iolock = 1;
 
-	trace_xfs_setattr(ip);
-
-	if (mp->m_flags & XFS_MOUNT_RDONLY)
-		return XFS_ERROR(EROFS);
-
-	if (XFS_FORCED_SHUTDOWN(mp))
-		return XFS_ERROR(EIO);
-
-	code = -inode_change_ok(inode, iattr);
-	if (code)
-		return code;
-
 	olddquot1 = olddquot2 = NULL;
 	udqp = gdqp = NULL;
 
@@ -474,6 +462,60 @@ xfs_setattr(
 	return code;
 }
 
+int
+xfs_setattr(
+	struct xfs_inode	*ip,
+	struct iattr		*iattr,
+	int			flags)
+{
+	xfs_mount_t		*mp = ip->i_mount;
+	int			code;
+
+	trace_xfs_setattr(ip);
+
+	if (mp->m_flags & XFS_MOUNT_RDONLY)
+		return XFS_ERROR(EROFS);
+
+	if (XFS_FORCED_SHUTDOWN(mp))
+		return XFS_ERROR(EIO);
+
+	/* xfs_setattr() is deprecated. Use xfs_setattr_dentry(). */
+	WARN_ON(1);
+
+	code = -inode_change_ok(VFS_I(ip), iattr);
+	if (code)
+		return code;
+
+	return __xfs_setattr(ip, iattr, flags);
+}
+
+int
+xfs_setattr_dentry(
+	struct dentry		*dentry,
+	struct iattr		*iattr,
+	int			flags)
+{
+	struct inode		*inode = dentry->d_inode;
+	struct xfs_inode	*ip = XFS_I(inode);
+	xfs_mount_t		*mp = ip->i_mount;
+	int			code;
+
+	trace_xfs_setattr(ip);
+
+	if (mp->m_flags & XFS_MOUNT_RDONLY)
+		return XFS_ERROR(EROFS);
+
+	if (XFS_FORCED_SHUTDOWN(mp))
+		return XFS_ERROR(EIO);
+
+	code = -inode_change_ok(inode, iattr);
+	if (code)
+		return code;
+
+	return __xfs_setattr(ip, iattr, flags);
+}
+
+
 /*
  * The maximum pathlen is 1024 bytes. Since the minimum file system
  * blocksize is 512 bytes, we can get a max of 2 extents back from
@@ -2791,7 +2833,11 @@ xfs_change_file_space(
 		iattr.ia_valid = ATTR_SIZE;
 		iattr.ia_size = startoffset;
 
-		error = xfs_setattr(ip, &iattr, attr_flags);
+		error = inode_newsize_ok(VFS_I(ip), startoffset);
+		if (error)
+			return -error;
+
+		error = __xfs_setattr(ip, &iattr, attr_flags);
 
 		if (error)
 			return error;
--- a/fs/xfs/xfs_vnodeops.h
+++ b/fs/xfs/xfs_vnodeops.h
@@ -14,6 +14,8 @@ struct xfs_iomap;
 
 
 int xfs_setattr(struct xfs_inode *ip, struct iattr *vap, int flags);
+int xfs_setattr_dentry(struct dentry *dentry, struct iattr *vap, int flags);
+int __xfs_setattr(struct xfs_inode *ip, struct iattr *vap, int flags);
 #define	XFS_ATTR_DMI		0x01	/* invocation from a DMI function */
 #define	XFS_ATTR_NONBLOCK	0x02	/* return EAGAIN if operation would block */
 #define XFS_ATTR_NOLOCK		0x04	/* Don't grab any conflicting locks */
