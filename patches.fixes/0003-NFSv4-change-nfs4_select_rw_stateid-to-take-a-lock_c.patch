From: NeilBrown <neilb@suse.com>
Date: Wed, 5 Oct 2016 16:14:33 +1100
Subject: [PATCH] NFSv4: change nfs4_select_rw_stateid to take a lock_context
 inplace of lock_owner
Patch-mainline: Submitted, Thu, 13 Oct 2016 15:26:47 +1100 - linux-nfs@vger.kernel.org
References: bnc#998689

The only time that a lock_context is not immediately available is in
setattr, and now that it has an open_context, it can easily find one
with nfs_get_lock_context.
This removes the need for the on-stack nfs_lockowner.

This change is preparation for correctly support flock stateids.

Signed-off-by: NeilBrown <neilb@suse.com>
Acked-by: NeilBrown <neilb@suse.com>

---
 fs/nfs/nfs4_fs.h   |    2 +-
 fs/nfs/nfs4proc.c  |   21 ++++++++++-----------
 fs/nfs/nfs4state.c |   11 +++++------
 3 files changed, 16 insertions(+), 18 deletions(-)

--- a/fs/nfs/nfs4_fs.h
+++ b/fs/nfs/nfs4_fs.h
@@ -377,7 +377,7 @@ extern void nfs41_handle_recall_slot(str
 extern void nfs4_put_lock_state(struct nfs4_lock_state *lsp);
 extern int nfs4_set_lock_state(struct nfs4_state *state, struct file_lock *fl);
 extern int nfs4_select_rw_stateid(nfs4_stateid *, struct nfs4_state *,
-		fmode_t, const struct nfs_lockowner *);
+		fmode_t, const struct nfs_lock_context *);
 extern int nfs4_lock_lost(const struct nfs_open_context *ctx,
 			  const struct nfs_lock_context *l_ctx);
 
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -1985,12 +1985,14 @@ static int _nfs4_do_setattr(struct inode
 	nfs_fattr_init(fattr);
 
 	if (state != NULL) {
-		struct nfs_lockowner lockowner = {
-			.l_owner = current->files,
-			.l_pid = current->tgid,
-		};
-		if (nfs4_select_rw_stateid(&arg.stateid, state, FMODE_WRITE,
-					   &lockowner) == -EIO)
+		struct nfs_lock_context *l_ctx;
+		l_ctx = nfs_get_lock_context(ctx);
+		if (IS_ERR(l_ctx))
+			return PTR_ERR(l_ctx);
+		status = nfs4_select_rw_stateid(&arg.stateid, state, FMODE_WRITE,
+						l_ctx);
+		nfs_put_lock_context(l_ctx);
+		if (status == -EIO)
 			return -EBADF;
 	} else if (nfs4_copy_delegation_stateid(&arg.stateid, inode,
 				FMODE_WRITE)) {
@@ -3333,15 +3335,12 @@ int nfs4_set_rw_stateid(nfs4_stateid *st
 		const struct nfs_lock_context *l_ctx,
 		fmode_t fmode)
 {
-	const struct nfs_lockowner *lockowner = NULL;
-
 	if (ctx->state == NULL) {
 		nfs4_stateid_copy(stateid, &zero_stateid);
 		return 0;
 	}
-	if (l_ctx != NULL)
-		lockowner = &l_ctx->lockowner;
-	return nfs4_select_rw_stateid(stateid, ctx->state, fmode, lockowner);
+
+	return nfs4_select_rw_stateid(stateid, ctx->state, fmode, l_ctx);
 }
 EXPORT_SYMBOL_GPL(nfs4_set_rw_stateid);
 
--- a/fs/nfs/nfs4state.c
+++ b/fs/nfs/nfs4state.c
@@ -847,20 +847,19 @@ int nfs4_set_lock_state(struct nfs4_stat
 
 static int nfs4_copy_lock_stateid(nfs4_stateid *dst,
 		struct nfs4_state *state,
-		const struct nfs_lockowner *lockowner)
+		const struct nfs_lock_context *l_ctx)
 {
 	struct nfs4_lock_state *lsp;
 	fl_owner_t fl_owner;
 	int ret = -ENOENT;
 
-
-	if (lockowner == NULL)
+	if (l_ctx == NULL)
 		goto out;
 
 	if (test_bit(LK_STATE_IN_USE, &state->flags) == 0)
 		goto out;
 
-	fl_owner = lockowner->l_owner;
+	fl_owner = l_ctx->lockowner.l_owner;
 	spin_lock(&state->state_lock);
 	lsp = __nfs4_find_lock_state(state, fl_owner);
 	if (lsp && (lsp->ls_flags & NFS_LOCK_LOST))
@@ -891,9 +890,9 @@ static void nfs4_copy_open_stateid(nfs4_
  * requests.
  */
 int nfs4_select_rw_stateid(nfs4_stateid *dst, struct nfs4_state *state,
-		fmode_t fmode, const struct nfs_lockowner *lockowner)
+		fmode_t fmode, const struct nfs_lock_context *l_ctx)
 {
-	int ret = nfs4_copy_lock_stateid(dst, state, lockowner);
+	int ret = nfs4_copy_lock_stateid(dst, state, l_ctx);
 	if (ret == -EIO)
 		/* A lost lock - don't even consider delegations */
 		goto out;
