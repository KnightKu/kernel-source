From: Trond Myklebust <trond.myklebust@primarydata.com>
Date: Mon, 21 Jul 2014 13:32:42 -0400
Subject: [PATCH] SUNRPC: Enforce an upper limit on the number of cached
 credentials
Git-commit: bae6746ff356478e1a2706072edbfb514072e0ff
Patch-mainline: v3.17
References: bsc#1012917

In some cases where the credentials are not often reused, we may want
to limit their total number just in order to make the negative lookups
in the hash table more manageable.

Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
Acked-by: NeilBrown <neilb@suse.com>

---
 net/sunrpc/auth.c |   41 ++++++++++++++++++++++++++++++++++-------
 1 file changed, 34 insertions(+), 7 deletions(-)

--- a/net/sunrpc/auth.c
+++ b/net/sunrpc/auth.c
@@ -79,6 +79,10 @@ static struct kernel_param_ops param_ops
 module_param_named(auth_hashtable_size, auth_hashbits, hashtbl_sz, 0644);
 MODULE_PARM_DESC(auth_hashtable_size, "RPC credential cache hashtable size");
 
+static unsigned long auth_max_cred_cachesize = ULONG_MAX;
+module_param(auth_max_cred_cachesize, ulong, 0644);
+MODULE_PARM_DESC(auth_max_cred_cachesize, "RPC credential maximum total cache size");
+
 static u32
 pseudoflavor_to_flavor(u32 flavor) {
 	if (flavor >= RPC_AUTH_MAXFLAVOR)
@@ -322,14 +326,25 @@ rpcauth_prune_expired(struct list_head *
 	return (number_cred_unused / 100) * sysctl_vfs_cache_pressure;
 }
 
+static unsigned long
+rpcauth_cache_do_shrink(int nr_to_scan)
+{
+	LIST_HEAD(free);
+	unsigned long freed;
+
+	spin_lock(&rpc_credcache_lock);
+	freed = rpcauth_prune_expired(&free, nr_to_scan);
+	spin_unlock(&rpc_credcache_lock);
+	rpcauth_destroy_credlist(&free);
+	return freed;
+}
+
 /*
  * Run memory cache shrinker.
  */
 static int
 rpcauth_cache_shrinker(struct shrinker *shrink, struct shrink_control *sc)
 {
-	LIST_HEAD(free);
-	int res;
 	int nr_to_scan = sc->nr_to_scan;
 	gfp_t gfp_mask = sc->gfp_mask;
 
@@ -337,11 +352,22 @@ rpcauth_cache_shrinker(struct shrinker *
 		return (nr_to_scan == 0) ? 0 : -1;
 	if (list_empty(&cred_unused))
 		return 0;
-	spin_lock(&rpc_credcache_lock);
-	res = rpcauth_prune_expired(&free, nr_to_scan);
-	spin_unlock(&rpc_credcache_lock);
-	rpcauth_destroy_credlist(&free);
-	return res;
+	return rpcauth_cache_do_shrink(nr_to_scan);
+}
+
+static void
+rpcauth_cache_enforce_limit(void)
+{
+	unsigned long diff;
+	unsigned int nr_to_scan;
+
+	if (number_cred_unused <= auth_max_cred_cachesize)
+		return;
+	diff = number_cred_unused - auth_max_cred_cachesize;
+	nr_to_scan = 100;
+	if (diff < nr_to_scan)
+		nr_to_scan = diff;
+	rpcauth_cache_do_shrink(nr_to_scan);
 }
 
 /*
@@ -398,6 +424,7 @@ rpcauth_lookup_credcache(struct rpc_auth
 	} else
 		list_add_tail(&new->cr_lru, &free);
 	spin_unlock(&cache->lock);
+	rpcauth_cache_enforce_limit();
 found:
 	if (test_bit(RPCAUTH_CRED_NEW, &cred->cr_flags) &&
 	    cred->cr_ops->cr_init != NULL &&
