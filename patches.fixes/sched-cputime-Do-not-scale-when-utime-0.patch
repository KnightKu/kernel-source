From: Stanislaw Gruszka <sgruszka@redhat.com>
Date: Wed, 4 Sep 2013 15:16:03 +0200
Subject: sched/cputime: Do not scale when utime == 0
Git-commit: 5a8e01f8fa51f5cbce8f37acc050eb2319d12956
Patch-mainline: v3.12-rc1
References: bnc#938352

scale_stime() silently assumes that stime < rtime, otherwise
when stime == rtime and both values are big enough (operations
on them do not fit in 32 bits), the resulting scaling stime can
be bigger than rtime. In consequence utime = rtime - stime
results in negative value.

User space visible symptoms of the bug are overflowed TIME
values on ps/top, for example:

 $ ps aux | grep rcu
 root         8  0.0  0.0      0     0 ?        S    12:42   0:00 [rcuc/0]
 root         9  0.0  0.0      0     0 ?        S    12:42   0:00 [rcub/0]
 root        10 62422329  0.0  0     0 ?        R    12:42 21114581:37 [rcu_preempt]
 root        11  0.1  0.0      0     0 ?        S    12:42   0:02 [rcuop/0]
 root        12 62422329  0.0  0     0 ?        S    12:42 21114581:35 [rcuop/1]
 root        10 62422329  0.0  0     0 ?        R    12:42 21114581:37 [rcu_preempt]

or overflowed utime values read directly from /proc/$PID/stat

Reference:

  https://lkml.org/lkml/2013/8/20/259

Reported-and-tested-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
Cc: stable@vger.kernel.org
Cc: Frederic Weisbecker <fweisbec@gmail.com>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
Cc: Borislav Petkov <bp@alien8.de>
Link: http://lkml.kernel.org/r/20130904131602.GC2564@redhat.com
Signed-off-by: Ingo Molnar <mingo@kernel.org>
Signed-off-by: Mike Galbraith <mgalbraith@suse.de>
---
 kernel/sched.c |   35 +++++++++++++++++++++++------------
 1 file changed, 23 insertions(+), 12 deletions(-)

--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -4307,7 +4307,7 @@ static cputime_t scale_stime(u64 stime,
 
 void task_times(struct task_struct *p, cputime_t *ut, cputime_t *st)
 {
-	cputime_t rtime, stime = p->stime, utime, total = cputime_add(stime, p->utime);
+	cputime_t rtime, stime, utime;
 
 	/*
 	 * Use CFS's precise accounting:
@@ -4322,12 +4322,18 @@ void task_times(struct task_struct *p, c
 	if (cputime_add(p->prev_stime, p->prev_utime) >= rtime)
 		goto out;
 
-	if (total) {
+	stime = p->stime;
+	utime = p->utime;
+
+	if (utime == 0) {
+		stime = rtime;
+	} else if (stime == 0) {
+		utime = rtime;
+	} else {
+		cputime_t total = cputime_add(stime, utime);
+
 		stime = scale_stime(stime, rtime, total);
 		utime = cputime_sub(rtime, stime);
-	} else {
-		stime = rtime;
-		utime = 0;
 	}
 
 	/*
@@ -4348,11 +4354,10 @@ void thread_group_times(struct task_stru
 {
 	struct signal_struct *sig = p->signal;
 	struct task_cputime cputime;
-	cputime_t rtime, stime, utime, total;
+	cputime_t rtime, stime, utime;
 
 	thread_group_cputime(p, &cputime);
 
-	total = cputime_add(cputime.utime, cputime.stime);
 	rtime = nsecs_to_cputime(cputime.sum_exec_runtime);
 
 	/*
@@ -4363,12 +4368,18 @@ void thread_group_times(struct task_stru
 	if (cputime_add(sig->prev_stime, sig->prev_utime) >= rtime)
 		goto out;
 
-	if (total) {
-		stime = scale_stime(cputime.stime, rtime, total);
-		utime = cputime_sub(rtime, stime);
-	} else {
+	stime = cputime.stime;
+	utime = cputime.utime;
+
+	if (utime == 0) {
 		stime = rtime;
-		utime = 0;
+	} else if (stime == 0) {
+		utime = rtime;
+	} else {
+		cputime_t total = cputime_add(utime, stime);
+
+		stime = scale_stime(stime, rtime, total);
+		utime = cputime_sub(rtime, stime);
 	}
 
 	sig->prev_stime = max(sig->prev_stime, stime);
