Subject: Change NFSv4 to not recover locks after they are lost.
From: NeilBrown <neilb@suse.de>
Patch-mainline: 3.12
Git-commit: ef1820f9be27b6ad158f433ab38002ab8131db4d
No-Fix: 146d70caaa1b87f64597743429d7da4b8073d0c9
References: bnc#828236

If the client is out of contact with the server for a while
the server will cancel its locks.
Currently the client will simply try to reclaim them.
This is bad as some other client may have gained the lock in the
mean time, in which case the locking protocols are violated.

So change the NFSv4 server to not reclaim locks and instead return
subsequent IO as EIO.

This change can be reverted if a sie depends on the old behavious
by setting the nfs.recover_locks module
parameter to Y (or 1).

Signed-off-by: NeilBrown <neilb@suse.de>

---
 fs/nfs/internal.h  |    4 +---
 fs/nfs/nfs4_fs.h   |    4 ++++
 fs/nfs/nfs4proc.c  |   10 ++++++++++
 fs/nfs/nfs4state.c |   29 +++++++++++++++++++++++++++--
 fs/nfs/read.c      |   12 ++++++------
 fs/nfs/write.c     |   14 ++++++--------
 6 files changed, 54 insertions(+), 19 deletions(-)

--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -451,7 +451,5 @@ unsigned int nfs_page_array_len(unsigned
  */
 static inline int nfs_restart_rpc(struct rpc_task *task, const struct nfs_client *clp)
 {
-	if (nfs4_has_session(clp))
-		return rpc_restart_call_prepare(task);
-	return rpc_restart_call(task);
+	return rpc_restart_call_prepare(task);
 }
--- a/fs/nfs/nfs4_fs.h
+++ b/fs/nfs/nfs4_fs.h
@@ -163,6 +163,7 @@ struct nfs4_lock_state {
 	struct list_head	ls_locks;	/* Other lock stateids */
 	struct nfs4_state *	ls_state;	/* Pointer to open state */
 #define NFS_LOCK_INITIALIZED 1
+#define NFS_LOCK_LOST 2
 	int			ls_flags;
 	struct nfs_seqid_counter	ls_seqid;
 	struct rpc_sequence	ls_sequence;
@@ -182,6 +183,7 @@ enum {
 	NFS_STATE_RECLAIM_REBOOT,	/* OPEN stateid server rebooted */
 	NFS_STATE_RECLAIM_NOGRACE,	/* OPEN stateid needs to recover state */
 	NFS_STATE_POSIX_LOCKS,		/* Posix locks are supported */
+	LK_STATE_LOST,			/* a lock has been lost */
 };
 
 struct nfs4_state {
@@ -359,6 +361,8 @@ extern void nfs41_handle_recall_slot(str
 extern void nfs4_put_lock_state(struct nfs4_lock_state *lsp);
 extern int nfs4_set_lock_state(struct nfs4_state *state, struct file_lock *fl);
 extern void nfs4_copy_stateid(nfs4_stateid *, struct nfs4_state *, fl_owner_t, pid_t);
+extern int nfs4_lock_lost(const struct nfs_open_context *ctx,
+			  const struct nfs_lock_context *l_ctx);
 
 extern struct nfs_seqid *nfs_alloc_seqid(struct nfs_seqid_counter *counter, gfp_t gfp_mask);
 extern int nfs_wait_on_sequence(struct nfs_seqid *seqid, struct rpc_task *task);
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -4523,6 +4523,11 @@ static int nfs4_lock_reclaim(struct nfs4
 	return err;
 }
 
+bool recover_locks = false;
+module_param(recover_locks, bool, 0644);
+MODULE_PARM_DESC(recover_locks,
+		 "If the server reports that a lock might be lost, "
+		 "try to recovery it risking corruption.");
 static int nfs4_lock_expired(struct nfs4_state *state, struct file_lock *request)
 {
 	struct nfs_server *server = NFS_SERVER(state->inode);
@@ -4534,6 +4539,11 @@ static int nfs4_lock_expired(struct nfs4
 	err = nfs4_set_lock_state(state, request);
 	if (err != 0)
 		return err;
+	if (!recover_locks) {
+		request->fl_u.nfs4_fl.owner->ls_flags |= NFS_LOCK_LOST;
+		set_bit(LK_STATE_LOST, &state->flags);
+		return 0;
+	}
 	do {
 		if (test_bit(NFS_DELEGATED_STATE, &state->flags) != 0)
 			return 0;
--- a/fs/nfs/nfs4state.c
+++ b/fs/nfs/nfs4state.c
@@ -822,8 +822,10 @@ void nfs4_put_lock_state(struct nfs4_loc
 	if (!atomic_dec_and_lock(&lsp->ls_count, &state->state_lock))
 		return;
 	list_del(&lsp->ls_locks);
-	if (list_empty(&state->lock_states))
+	if (list_empty(&state->lock_states)) {
 		clear_bit(LK_STATE_IN_USE, &state->flags);
+		clear_bit(LK_STATE_LOST, &state->flags);
+	}
 	spin_unlock(&state->state_lock);
 	if (lsp->ls_flags & NFS_LOCK_INITIALIZED)
 		nfs4_release_lockowner(lsp);
@@ -887,12 +889,35 @@ void nfs4_copy_stateid(nfs4_stateid *dst
 
 	spin_lock(&state->state_lock);
 	lsp = __nfs4_find_lock_state(state, fl_owner, fl_pid, NFS4_ANY_LOCK_TYPE);
-	if (lsp != NULL && (lsp->ls_flags & NFS_LOCK_INITIALIZED) != 0)
+	if (lsp != NULL &&
+	    (lsp->ls_flags & (NFS_LOCK_INITIALIZED | NFS_LOCK_LOST)) != 0)
 		memcpy(dst, &lsp->ls_stateid, sizeof(*dst));
 	spin_unlock(&state->state_lock);
 	nfs4_put_lock_state(lsp);
 }
 
+/* Check the lock access would try to use a lost lock stateid */
+int nfs4_lock_lost(const struct nfs_open_context *ctx,
+		   const struct nfs_lock_context *l_ctx)
+{
+	int ret = 0;
+	struct nfs4_state *state;
+	struct nfs4_lock_state *lsp;
+	if (!ctx || !ctx->state || !l_ctx)
+		return 0;
+	state = ctx->state;
+	if (!test_bit(LK_STATE_IN_USE, &state->flags) ||
+	    !test_bit(LK_STATE_LOST, &state->flags))
+		return 0;
+	spin_lock(&state->state_lock);
+	lsp = __nfs4_find_lock_state(state, l_ctx->lockowner, l_ctx->pid, NFS4_ANY_LOCK_TYPE);
+	if (lsp != NULL && (lsp->ls_flags & NFS_LOCK_LOST) != 0)
+		ret = 1;
+	spin_unlock(&state->state_lock);
+	nfs4_put_lock_state(lsp);
+	return ret;
+}
+
 struct nfs_seqid *nfs_alloc_seqid(struct nfs_seqid_counter *counter, gfp_t gfp_mask)
 {
 	struct nfs_seqid *new;
--- a/fs/nfs/read.c
+++ b/fs/nfs/read.c
@@ -445,23 +445,25 @@ static void nfs_readpage_release_partial
 	nfs_readdata_release(calldata);
 }
 
-#if defined(CONFIG_NFS_V4_1)
 void nfs_read_prepare(struct rpc_task *task, void *calldata)
 {
 	struct nfs_read_data *data = calldata;
 
+#if defined(CONFIG_NFS_V4_1)
 	if (nfs4_setup_sequence(NFS_SERVER(data->inode),
 				&data->args.seq_args, &data->res.seq_res,
 				0, task))
 		return;
+#endif /* CONFIG_NFS_V4_1 */
 	rpc_call_start(task);
+#if defined(CONFIG_NFS_V4)
+	if (nfs4_lock_lost(data->args.context, data->args.lock_context))
+		rpc_exit(task, -EIO);
+#endif
 }
-#endif /* CONFIG_NFS_V4_1 */
 
 static const struct rpc_call_ops nfs_read_partial_ops = {
-#if defined(CONFIG_NFS_V4_1)
 	.rpc_call_prepare = nfs_read_prepare,
-#endif /* CONFIG_NFS_V4_1 */
 	.rpc_call_done = nfs_readpage_result_partial,
 	.rpc_release = nfs_readpage_release_partial,
 };
@@ -525,9 +527,7 @@ static void nfs_readpage_release_full(vo
 }
 
 static const struct rpc_call_ops nfs_read_full_ops = {
-#if defined(CONFIG_NFS_V4_1)
 	.rpc_call_prepare = nfs_read_prepare,
-#endif /* CONFIG_NFS_V4_1 */
 	.rpc_call_done = nfs_readpage_result_full,
 	.rpc_release = nfs_readpage_release_full,
 };
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@ -1108,23 +1108,25 @@ out:
 	nfs_writedata_release(calldata);
 }
 
-#if defined(CONFIG_NFS_V4_1)
 void nfs_write_prepare(struct rpc_task *task, void *calldata)
 {
 	struct nfs_write_data *data = calldata;
 
+#if defined(CONFIG_NFS_V4_1)
 	if (nfs4_setup_sequence(NFS_SERVER(data->inode),
 				&data->args.seq_args,
 				&data->res.seq_res, 1, task))
 		return;
+#endif /* CONFIG_NFS_V4_1 */
 	rpc_call_start(task);
+#if defined(CONFIG_NFS_V4)
+	if (nfs4_lock_lost(data->args.context, data->args.lock_context))
+		rpc_exit(task, -EIO);
+#endif
 }
-#endif /* CONFIG_NFS_V4_1 */
 
 static const struct rpc_call_ops nfs_write_partial_ops = {
-#if defined(CONFIG_NFS_V4_1)
 	.rpc_call_prepare = nfs_write_prepare,
-#endif /* CONFIG_NFS_V4_1 */
 	.rpc_call_done = nfs_writeback_done_partial,
 	.rpc_release = nfs_writeback_release_partial,
 };
@@ -1186,9 +1188,7 @@ remove_request:
 }
 
 static const struct rpc_call_ops nfs_write_full_ops = {
-#if defined(CONFIG_NFS_V4_1)
 	.rpc_call_prepare = nfs_write_prepare,
-#endif /* CONFIG_NFS_V4_1 */
 	.rpc_call_done = nfs_writeback_done_full,
 	.rpc_release = nfs_writeback_release_full,
 };
@@ -1482,9 +1482,7 @@ static void nfs_commit_release(void *cal
 }
 
 static const struct rpc_call_ops nfs_commit_ops = {
-#if defined(CONFIG_NFS_V4_1)
 	.rpc_call_prepare = nfs_write_prepare,
-#endif /* CONFIG_NFS_V4_1 */
 	.rpc_call_done = nfs_commit_done,
 	.rpc_release = nfs_commit_release,
 };
