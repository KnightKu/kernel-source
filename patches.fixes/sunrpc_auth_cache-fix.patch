From: NeilBrown <neilb@suse.com>
Subject: Fix two issues with drop_caches and the sunrpc auth cache
Patch-mainline: Not yet, not really needed so no hurry.
References: bsc#1012917

The sunrpc auth cache refuses to discard cache items that have been
used in the last minute, but includes them in the count that it reports
to shrink_slab().  When the shrinker find a newish entry, it reports that
there are no more entries to discard.

shrink_slab() measures progress by the difference between "how many
can be discarded", and "how many are left after some were discarded".
As the former includes new items, and the latter is zero if there are new items,
it mistakenly thinks it is making progress if there are lots of new entries.

The new result of this is that if there are more than 100 distinct
users who are actively using NFS, then
  echo 3 > /proc/sys/vm/drop_caches
can block indefinitely, and spin it's wheels doing nothing useful.

Changing the return value from '0' to '-1' (which means "I have to
stop now") fixes this. Also returning -1 then the number-free is
requested avoid unnecessary work.

A separate issue is that if there are fewer than 100 entries in this cache,
the 'drop_caches' command doesn't remove them.  This isn't a big problem
but is techincally the wrong outcome.
So change the calculation with sysctl_vfs_cache_pressure to not round down
to a multiple of 100.

While this code is essentially unchanged in mainline (4.10), the bug does not
occur due to a change in shrink_slab() in
Commit: a0b02131c5fc ("shrinker: Kill old ->shrink API.")
which arrived in v3.12.  With this change, the incorrect "return 0" doesn't confuse
shrink_slab()

Signed-off-by: NeilBrown <neilb@suse.com>

---
 net/sunrpc/auth.c |   10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

--- a/net/sunrpc/auth.c
+++ b/net/sunrpc/auth.c
@@ -298,16 +298,16 @@ rpcauth_prune_expired(struct list_head *
 	unsigned long expired = jiffies - RPC_AUTH_EXPIRY_MORATORIUM;
 
 	list_for_each_entry_safe(cred, next, &cred_unused, cr_lru) {
-
-		if (nr_to_scan-- == 0)
-			break;
 		/*
 		 * Enforce a 60 second garbage collection moratorium
 		 * Note that the cred_unused list must be time-ordered.
 		 */
 		if (time_in_range(cred->cr_expire, expired, jiffies) &&
 		    test_bit(RPCAUTH_CRED_HASHED, &cred->cr_flags) != 0)
-			return 0;
+			return -1;
+
+		if (nr_to_scan-- == 0)
+			break;
 
 		list_del_init(&cred->cr_lru);
 		number_cred_unused--;
@@ -323,7 +323,7 @@ rpcauth_prune_expired(struct list_head *
 		}
 		spin_unlock(cache_lock);
 	}
-	return (number_cred_unused / 100) * sysctl_vfs_cache_pressure;
+	return number_cred_unused * sysctl_vfs_cache_pressure / 100;
 }
 
 static unsigned long
