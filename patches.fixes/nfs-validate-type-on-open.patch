From: NeilBrown <neilb@suse.com>
Subject: NFS: Avoid getting confused by confused server.
References: bsc#1045416
Patch-mainline: Not yet - under development

If an NFS server reports that the same filehandle is
sometimes for a regular file, and sometimes for a directory, then
the NFS client can get confused.

It already detects this, marks the inode as stale, and returns an
error.  However the error isn't always detected.

There is at least one case where this can cause a system crash.
The ->private_data for a directory and a file are very different.
For a file, the data structure is included on the nfs_inode->open_files
lists.  For a directory there is no such linkage.
If a given inode (data structure) is for a directory, but the corresponding
filehandle is returned when openning a file, the nfs_open_context for a
file might be stored in the ->private_data for a directory filp.
When the filp is closed the ->private_data is freed, but is still
on the ->open_files linked list.
This can eventually result in use-after-free data corruption.

Two different fixes are included here.  Either one should fix the
observed problem, but both are included for safely - other server
problems could trigger different code paths.

In dir.c, we only consider calling nfs_file_set_open_context(), which
sets ->private_data to an nfs_open_context, if the inode
is thought to be for a regular file.

In inode.c, we check that the inode we found has the same type as the
NFS server said it should, and cause nfs_fhget() to fail if not.

Signed-off-by: NeilBrown <neilb@suse.com>

---
 fs/nfs/dir.c   |    8 ++++++++
 fs/nfs/inode.c |   10 ++++++++--
 2 files changed, 16 insertions(+), 2 deletions(-)

--- a/fs/nfs/dir.c
+++ b/fs/nfs/dir.c
@@ -1495,6 +1495,14 @@ static int nfs_intent_set_file(struct na
 	struct file *filp;
 	int ret = 0;
 
+	/* This only makes sense for regular files, as the filp ->private_data
+	 * has different types for regular files and others.
+	 * That should be impossible, but a confused server can cause confusion.
+	 */
+	if (!S_ISREG(ctx->path.dentry->d_inode->i_mode)) {
+		ret = -ESTALE;
+		goto out;
+	}
 	/* If the open_intent is for execute, we have an extra check to make */
 	if (ctx->mode & FMODE_EXEC) {
 		ret = nfs_may_open(ctx->path.dentry->d_inode,
--- a/fs/nfs/inode.c
+++ b/fs/nfs/inode.c
@@ -387,8 +387,14 @@ nfs_fhget(struct super_block *sb, struct
 		nfs_fscache_init_inode_cookie(inode);
 
 		unlock_new_inode(inode);
-	} else
-		nfs_refresh_inode(inode, fattr);
+	} else {
+		int err = nfs_refresh_inode(inode, fattr);
+		if (err < 0) {
+			iput(inode);
+			inode = ERR_PTR(err);
+			goto out_no_inode;
+		}
+	}
 	dprintk("NFS: nfs_fhget(%s/%Ld ct=%d)\n",
 		inode->i_sb->s_id,
 		(long long)NFS_FILEID(inode),
