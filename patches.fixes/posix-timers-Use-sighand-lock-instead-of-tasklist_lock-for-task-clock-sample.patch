From: Frederic Weisbecker <fweisbec@gmail.com>
Date: Fri, 11 Oct 2013 17:41:11 +0200
Subject: posix-timers: Use sighand lock instead of tasklist_lock for task clock sample
Git-commit: 50875788a1d4a3f662a27ed13cd05282d835939a
Patch-mainline: v3.14-rc1
References: bnc#997401

There is no need for the tasklist_lock just to take a process
wide clock sample.

All we need is to get a coherent sample that doesn't race with
exit() and exec():

* exit() may be concurrently reaping a task and flushing its time

* sighand is unstable under exit() and exec(), and the latter also
  result in group leader that can change

To protect against these, locking the target's sighand is enough.

Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
Cc: Thomas Gleixner <tglx@linutronix.de>
Cc: Ingo Molnar <mingo@kernel.org>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Oleg Nesterov <oleg@redhat.com>
Cc: Kosaki Motohiro <kosaki.motohiro@jp.fujitsu.com>
Cc: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Mike Galbraith <mgalbraith@suse.de>
---
 kernel/posix-cpu-timers.c |   30 ++++++++++++++++++++++++++----
 1 file changed, 26 insertions(+), 4 deletions(-)

--- a/kernel/posix-cpu-timers.c
+++ b/kernel/posix-cpu-timers.c
@@ -339,10 +339,21 @@ static int posix_cpu_clock_get(const clo
 			error = cpu_clock_sample(which_clock,
 						 current, &rtn);
 		} else {
-			read_lock(&tasklist_lock);
+			unsigned long flags;
+			struct sighand_struct *sighand;
+
+			/*
+			 * while_each_thread() is not yet entirely RCU safe,
+			 * keep locking the group while sampling process
+			 * clock for now.
+			 */
+			sighand = lock_task_sighand(current, &flags);
+			if (!sighand)
+				return error;
+
 			error = cpu_clock_sample_group(which_clock,
 						       current, &rtn);
-			read_unlock(&tasklist_lock);
+			unlock_task_sighand(current, &flags);
 		}
 	} else {
 		/*
@@ -359,13 +370,24 @@ static int posix_cpu_clock_get(const clo
 								 p, &rtn);
 				}
 			} else {
-				read_lock(&tasklist_lock);
+				unsigned long flags;
+				struct sighand_struct *sighand;
+
+				/*
+				 * while_each_thread() is not yet entirely RCU safe,
+				 * keep locking the group while sampling process
+				 * clock for now.
+				 */
+				sighand = lock_task_sighand(p, &flags);
+				if (!sighand)
+					return error;
+
 				if (thread_group_leader(p) && p->sighand) {
 					error =
 					    cpu_clock_sample_group(which_clock,
 							           p, &rtn);
 				}
-				read_unlock(&tasklist_lock);
+				unlock_task_sighand(p, &flags);
 			}
 		}
 		rcu_read_unlock();
