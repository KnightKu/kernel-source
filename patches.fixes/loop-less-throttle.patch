From: NeilBrown <neilb@suse.com>
Subject: Use PF_LESS_THROTTLE in loop device thread
References: bsc#1027101
Patch-mainline: Not yet, not sure if upstream needs it

If a loop device is created using a file in a filesystem,
and a second filesystem is created in that loop-back device,
when writes to the second filesystem will cause date to be written
to the second filesystem (obviously).
This results in dirty page-cache data from both filesystems.

Any dirty page-cache data can cause writes to be throttled (in
balance_dirty_pages).

If there is lots of dirty data in the second filesystem, and none in
the first, then writes by the loop thread (to the first filesystem)
might block, waiting for the total amount of dirty data to drop.
But it cannot drop because the only way data can be written out
is through that same loop-device thread.

The thread flag PF_LESS_THROTTLE was created precisely to handle this
situation.  The thread which is writing from one filesystem to another
gets this flag so that it can still write, even when other writes are throttled.
It was originally created for nfsd (when used with loop-back mounts) but
is equally appropriate for loop devices.

Suggested-by: Ales Novak <alnovak@suse.com>
Signed-off-by: NeilBrown <neilb@suse.com>


---
 drivers/block/loop.c |    1 +
 1 file changed, 1 insertion(+)

--- a/drivers/block/loop.c
+++ b/drivers/block/loop.c
@@ -499,6 +499,7 @@ static int loop_thread(void *data)
 	struct bio *bio;
 
 	set_user_nice(current, -20);
+	current->flags |= PF_LESS_THROTTLE;
 
 	while (!kthread_should_stop() || !bio_list_empty(&lo->lo_bio_list)) {
 
