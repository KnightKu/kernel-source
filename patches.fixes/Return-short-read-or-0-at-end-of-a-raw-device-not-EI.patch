From b2de525f095708b2adbadaec3f1e4017a23d1e09 Mon Sep 17 00:00:00 2001          
From: David Jeffery <djeffery@redhat.com>                                       
Date: Mon, 29 Sep 2014 10:21:10 -0400                                           
Subject: [PATCH] Return short read or 0 at end of a raw device, not EIO         
References: bsc#1039594
Patch-mainline: v3.7
Git-commit: b2de525f095708b2adbadaec3f1e4017a23d1e09

Author: David Jeffery <djeffery@redhat.com>                                     
Changes to the basic direct I/O code have broken the raw driver when reading    
to the end of a raw device.  Instead of returning a short read for a read that  
extends partially beyond the device's end or 0 when at the end of the device,   
these reads now return EIO.                                                     
                                                                                
The raw driver needs the same end of device handling as was added for normal    
block devices.  Using blkdev_read_iter, which has the needed size checks,       
prevents the EIO conditions at the end of the device.                           
                                                                                
Signed-off-by: David Jeffery <djeffery@redhat.com>                              
Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
Signed-off-by: Thomas Abraham <tabraham@suse.com>

[tabraham@suse.com: handled generic_file_aio_read -> blkdev_aio_read 
conversion in backport]
---
 drivers/char/raw.c | 2 +-
 fs/block_dev.c     | 3 ++-
 include/linux/fs.h | 2 ++
 3 files changed, 5 insertions(+), 2 deletions(-)

diff --git a/drivers/char/raw.c b/drivers/char/raw.c
index b33e8ea314ed..90862d2e6cf8 100644
--- a/drivers/char/raw.c
+++ b/drivers/char/raw.c
@@ -285,7 +285,7 @@ static long raw_ctl_compat_ioctl(struct file *file, unsigned int cmd,
 
 static const struct file_operations raw_fops = {
 	.read		= do_sync_read,
-	.aio_read	= generic_file_aio_read,
+	.aio_read	= blkdev_aio_read,
 	.write		= do_sync_write,
 	.aio_write	= blkdev_aio_write,
 	.fsync		= blkdev_fsync,
diff --git a/fs/block_dev.c b/fs/block_dev.c
index f94ab57b28a3..a6b01895eeeb 100644
--- a/fs/block_dev.c
+++ b/fs/block_dev.c
@@ -1534,7 +1534,7 @@ ssize_t blkdev_aio_write(struct kiocb *iocb, const struct iovec *iov,
 }
 EXPORT_SYMBOL_GPL(blkdev_aio_write);
 
-static ssize_t blkdev_aio_read(struct kiocb *iocb, const struct iovec *iov,
+ssize_t blkdev_aio_read(struct kiocb *iocb, const struct iovec *iov,
 			 unsigned long nr_segs, loff_t pos)
 {
 	struct file *file = iocb->ki_filp;
@@ -1549,6 +1549,7 @@ static ssize_t blkdev_aio_read(struct kiocb *iocb, const struct iovec *iov,
 		nr_segs = iov_shorten((struct iovec *)iov, nr_segs, size);
 	return generic_file_aio_read(iocb, iov, nr_segs, pos);
 }
+EXPORT_SYMBOL_GPL(blkdev_aio_read);
 
 /*
  * Try to release a page associated with block device when the system
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 89ea53dfdd8d..0c14771e8b0a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2407,6 +2407,8 @@ extern int generic_segment_checks(const struct iovec *iov,
 		unsigned long *nr_segs, size_t *count, int access_flags);
 
 /* fs/block_dev.c */
+extern ssize_t blkdev_aio_read(struct kiocb *iocb, const struct iovec *iov,
+				unsigned long nr_segs, loff_t pos);
 extern ssize_t blkdev_aio_write(struct kiocb *iocb, const struct iovec *iov,
 				unsigned long nr_segs, loff_t pos);
 extern int blkdev_fsync(struct file *filp, loff_t start, loff_t end,
-- 
2.12.0

