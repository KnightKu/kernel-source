From: Hannes Reinecke <hare@suse.de>
Date: Wed, 5 Nov 2014 11:24:14 +0100
Subject: dm: do not call dm_sync_table() when creating new devices
References: bnc#901809, bsc#1008893
Patch-Mainline: 3.19-rc1
Git-commit: 41abc4e1af369bb5438eaee398e3beee690cc8ca

When creating new devices dm_sync_table() calls
synchronize_rcu_expedited(), causing _all_ pending
RCU pointers to be flushed. This causes a latency
overhead especially noticeable when creating lots
of devices.
And all of this is pointless as there are no old
maps to be disconnected, and hence no stale pointers
which would need to be cleared up.

Signed-off-by: Hannes Reinecke <hare@suse.de>
Acked-by: NeilBrown <neilb@suse.com>
---
 drivers/md/dm.c |    9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@ -2246,7 +2246,8 @@ static struct dm_table *__bind(struct ma
 		set_bit(DMF_MERGE_IS_OPTIONAL, &md->flags);
 	else
 		clear_bit(DMF_MERGE_IS_OPTIONAL, &md->flags);
-	dm_sync_table(md);
+	if (old_map)
+		dm_sync_table(md);
 
 	return old_map;
 }
@@ -2678,7 +2679,8 @@ int dm_suspend(struct mapped_device *md,
 	 * flush_workqueue(md->wq).
 	 */
 	set_bit(DMF_BLOCK_IO_FOR_SUSPEND, &md->flags);
-	synchronize_srcu(&md->io_barrier);
+	if (map)
+		synchronize_srcu(&md->io_barrier);
 
 	/*
 	 * Stop md->queue before flushing md->wq in case request-based
@@ -2698,7 +2700,8 @@ int dm_suspend(struct mapped_device *md,
 
 	if (noflush)
 		clear_bit(DMF_NOFLUSH_SUSPENDING, &md->flags);
-	synchronize_srcu(&md->io_barrier);
+	if (map)
+		synchronize_srcu(&md->io_barrier);
 
 	/* were we interrupted ? */
 	if (r < 0) {
