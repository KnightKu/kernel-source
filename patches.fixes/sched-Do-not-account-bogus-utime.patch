From: Stanislaw Gruszka <sgruszka@redhat.com>
Date: Tue, 30 Apr 2013 11:35:05 +0200
Subject: sched: Do not account bogus utime
Git-commit: 772c808a252594692972773f6ee41c289b8e0b2a
Patch-mainline: v3.10-rc1
References: bnc#938352

Due to rounding in scale_stime(), for big numbers, scaled stime
values will grow in chunks. Since rtime grow in jiffies and we
calculate utime like below:

	prev->stime = max(prev->stime, stime);
	prev->utime = max(prev->utime, rtime - prev->stime);

we could erroneously account stime values as utime. To prevent
that only update prev->{u,s}time values when they are smaller
than current rtime.

Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
Cc: Frederic Weisbecker <fweisbec@gmail.com>
Cc: rostedt@goodmis.org
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Cc: Dave Hansen <dave@sr71.net>
Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/1367314507-9728-2-git-send-email-sgruszka@redhat.com
Signed-off-by: Ingo Molnar <mingo@kernel.org>
Signed-off-by: Mike Galbraith <mgalbraith@suse.de>
---
 kernel/sched.c |   18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -4315,6 +4315,14 @@ void task_times(struct task_struct *p, c
 	 */
 	rtime = nsecs_to_cputime(p->se.sum_exec_runtime);
 
+	/*
+	 * Update userspace visible utime/stime values only if actual execution
+	 * time is bigger than already exported. Note that can happen, that we
+	 * provided bigger values due to scaling inaccuracy on big numbers.
+	 */
+	if (cputime_add(p->prev_stime, p->prev_utime) >= rtime)
+		goto out;
+
 	if (!rtime) {
 		stime = 0;
 	} else if (!total) {
@@ -4329,6 +4337,7 @@ void task_times(struct task_struct *p, c
 	p->prev_stime = max(p->prev_stime, stime);
 	p->prev_utime = max(p->prev_utime, cputime_sub(rtime, p->prev_stime));
 
+out:
 	*ut = p->prev_utime;
 	*st = p->prev_stime;
 }
@@ -4347,6 +4356,14 @@ void thread_group_times(struct task_stru
 	total = cputime_add(cputime.utime, cputime.stime);
 	rtime = nsecs_to_cputime(cputime.sum_exec_runtime);
 
+	/*
+	 * Update userspace visible utime/stime values only if actual execution
+	 * time is bigger than already exported. Note that can happen, that we
+	 * provided bigger values due to scaling inaccuracy on big numbers.
+	 */
+	if (cputime_add(sig->prev_stime, sig->prev_utime) >= rtime)
+		goto out;
+
 	if (!rtime) {
 		stime = 0;
 	} else if (!total) {
@@ -4359,6 +4376,7 @@ void thread_group_times(struct task_stru
 	sig->prev_utime = max(sig->prev_utime,
 			      cputime_sub(rtime, sig->prev_stime));
 
+out:
 	*ut = sig->prev_utime;
 	*st = sig->prev_stime;
 }
