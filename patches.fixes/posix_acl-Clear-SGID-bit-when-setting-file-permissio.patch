From d23ea5a5f2c9b5c5bdb8fb07901872b6f3588260 Mon Sep 17 00:00:00 2001
From: Jan Kara <jack@suse.cz>
Date: Mon, 31 Oct 2016 06:42:36 -0500
Subject: [PATCH] posix_acl: Clear SGID bit when setting file permissions

References: CVE-2016-7097, bsc#995968
Git-commit: 073931017b49d9458aa351605b43a7e34598caef
Patch-mainline: v4.9-rc1

When file permissions are modified via chmod(2) and the user is not in
the owning group or capable of CAP_FSETID, the setgid bit is cleared in
inode_change_ok().  Setting a POSIX ACL via setxattr(2) sets the file
permissions as well as the new ACL, but doesn't clear the setgid bit in
a similar way; this allows to bypass the check in chmod(2).  Fix that.

Reviewed-by: Christoph Hellwig <hch@lst.de>
Reviewed-by: Jeff Layton <jlayton@redhat.com>
Signed-off-by: Jan Kara <jack@suse.cz>
Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
---
 fs/btrfs/acl.c             |  6 +++---
 fs/ext2/acl.c              | 15 +++++----------
 fs/ext4/acl.c              | 15 +++++----------
 fs/ocfs2/acl.c             | 19 +++++++------------
 fs/posix_acl.c             | 31 +++++++++++++++++++++++++++++++
 fs/reiserfs/xattr_acl.c    | 11 +++--------
 include/linux/capability.h |  1 -
 include/linux/posix_acl.h  |  1 +
 8 files changed, 55 insertions(+), 44 deletions(-)

diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c
index 34a8169..430cbc1 100644
--- a/fs/btrfs/acl.c
+++ b/fs/btrfs/acl.c
@@ -106,7 +106,7 @@ static int btrfs_set_acl(struct btrfs_trans_handle *trans,
 	int ret, size = 0;
 	const char *name;
 	char *value = NULL;
-	mode_t mode;
+	umode_t mode;
 
 	if (acl) {
 		ret = posix_acl_valid(acl);
@@ -120,8 +120,8 @@ static int btrfs_set_acl(struct btrfs_trans_handle *trans,
 		mode = inode->i_mode;
 		name = POSIX_ACL_XATTR_ACCESS;
 		if (acl) {
-			ret = posix_acl_equiv_mode(acl, &mode);
-			if (ret < 0)
+			ret = posix_acl_update_mode(inode, &mode, &acl);
+			if (ret)
 				return ret;
 			if (ret == 0)
 				acl = NULL;
diff --git a/fs/ext2/acl.c b/fs/ext2/acl.c
index abea5a1..0d80e06 100644
--- a/fs/ext2/acl.c
+++ b/fs/ext2/acl.c
@@ -194,17 +194,12 @@ ext2_set_acl(struct inode *inode, int type, struct posix_acl *acl)
 		case ACL_TYPE_ACCESS:
 			name_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;
 			if (acl) {
-				mode_t mode = inode->i_mode;
-				error = posix_acl_equiv_mode(acl, &mode);
-				if (error < 0)
+				umode_t mode;
+				error = posix_acl_update_mode(inode, &mode, &acl);
+				if (error)
 					return error;
-				else {
-					inode->i_mode = mode;
-					inode->i_ctime = CURRENT_TIME_SEC;
-					mark_inode_dirty(inode);
-					if (error == 0)
-						acl = NULL;
-				}
+				inode->i_ctime = CURRENT_TIME_SEC;
+				mark_inode_dirty(inode);
 			}
 			break;
 
diff --git a/fs/ext4/acl.c b/fs/ext4/acl.c
index 4922087..ae72133 100644
--- a/fs/ext4/acl.c
+++ b/fs/ext4/acl.c
@@ -198,17 +198,12 @@ ext4_set_acl(handle_t *handle, struct inode *inode, int type,
 	case ACL_TYPE_ACCESS:
 		name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
-			mode_t mode = inode->i_mode;
-			error = posix_acl_equiv_mode(acl, &mode);
-			if (error < 0)
+			umode_t mode = inode->i_mode;
+			error = posix_acl_update_mode(inode, &mode, &acl);
+			if (error)
 				return error;
-			else {
-				inode->i_mode = mode;
-				inode->i_ctime = ext4_current_time(inode);
-				ext4_mark_inode_dirty(handle, inode);
-				if (error == 0)
-					acl = NULL;
-			}
+			inode->i_ctime = ext4_current_time(inode);
+			ext4_mark_inode_dirty(handle, inode);
 		}
 		break;
 
diff --git a/fs/ocfs2/acl.c b/fs/ocfs2/acl.c
index e913ad1..9246a79 100644
--- a/fs/ocfs2/acl.c
+++ b/fs/ocfs2/acl.c
@@ -247,20 +247,15 @@ static int ocfs2_set_acl(handle_t *handle,
 	case ACL_TYPE_ACCESS:
 		name_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
-			mode_t mode = inode->i_mode;
-			ret = posix_acl_equiv_mode(acl, &mode);
-			if (ret < 0)
+			umode_t mode;
+			ret = posix_acl_update_mode(inode, &mode, &acl);
+			if (ret)
 				return ret;
-			else {
-				if (ret == 0)
-					acl = NULL;
-
-				ret = ocfs2_acl_set_mode(inode, di_bh,
-							 handle, mode);
-				if (ret)
-					return ret;
 
-			}
+			ret = ocfs2_acl_set_mode(inode, di_bh,
+						 handle, mode);
+			if (ret)
+				return ret;
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
diff --git a/fs/posix_acl.c b/fs/posix_acl.c
index b1cf6bf..6e7654a 100644
--- a/fs/posix_acl.c
+++ b/fs/posix_acl.c
@@ -338,6 +338,37 @@ posix_acl_create_masq(struct posix_acl *acl, mode_t *mode_p)
         return not_equiv;
 }
 
+/**
+ * posix_acl_update_mode  -  update mode in set_acl
+ *
+ * Update the file mode when setting an ACL: compute the new file permission
+ * bits based on the ACL.  In addition, if the ACL is equivalent to the new
+ * file mode, set *acl to NULL to indicate that no ACL should be set.
+ *
+ * As with chmod, clear the setgit bit if the caller is not in the owning group
+ * or capable of CAP_FSETID (see inode_change_ok).
+ *
+ * Called from set_acl inode operations.
+ */
+int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,
+                          struct posix_acl **acl)
+{
+        mode_t mode = inode->i_mode;
+        int error;
+
+        error = posix_acl_equiv_mode(*acl, &mode);
+        if (error < 0)
+                return error;
+        if (error == 0)
+                *acl = NULL;
+        if (!in_group_p(inode->i_gid) &&
+            !ns_capable(current_user_ns(), CAP_FSETID))
+                mode &= ~S_ISGID;
+        *mode_p = (umode_t) mode;
+        return 0;
+}
+EXPORT_SYMBOL(posix_acl_update_mode);
+
 /*
  * Modify the ACL for the chmod syscall.
  */
diff --git a/fs/reiserfs/xattr_acl.c b/fs/reiserfs/xattr_acl.c
index 2c4aa89d..0556dbd 100644
--- a/fs/reiserfs/xattr_acl.c
+++ b/fs/reiserfs/xattr_acl.c
@@ -274,15 +274,10 @@ reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,
 	case ACL_TYPE_ACCESS:
 		name = POSIX_ACL_XATTR_ACCESS;
 		if (acl) {
-			mode_t mode = inode->i_mode;
-			error = posix_acl_equiv_mode(acl, &mode);
-			if (error < 0)
+			umode_t mode = inode->i_mode;
+			error = posix_acl_update_mode(inode, &mode, &acl);
+			if (error)
 				return error;
-			else {
-				inode->i_mode = mode;
-				if (error == 0)
-					acl = NULL;
-			}
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
diff --git a/include/linux/capability.h b/include/linux/capability.h
index c421123..81037cf 100644
--- a/include/linux/capability.h
+++ b/include/linux/capability.h
@@ -547,7 +547,6 @@ extern bool capable(int cap);
 extern bool ns_capable(struct user_namespace *ns, int cap);
 extern bool task_ns_capable(struct task_struct *t, int cap);
 extern bool nsown_capable(int cap);
-
 /* audit system wants to get cap info from files as well */
 extern int get_vfs_caps_from_disk(const struct dentry *dentry, struct cpu_vfs_cap_data *cpu_caps);
 
diff --git a/include/linux/posix_acl.h b/include/linux/posix_acl.h
index 54211c1..2fa6511 100644
--- a/include/linux/posix_acl.h
+++ b/include/linux/posix_acl.h
@@ -79,6 +79,7 @@ extern int posix_acl_permission(struct inode *, const struct posix_acl *, int);
 extern struct posix_acl *posix_acl_from_mode(mode_t, gfp_t);
 extern int posix_acl_equiv_mode(const struct posix_acl *, mode_t *);
 extern int posix_acl_create_masq(struct posix_acl *, mode_t *);
+extern int posix_acl_update_mode(struct inode *, umode_t *, struct posix_acl **);
 extern int posix_acl_chmod_masq(struct posix_acl *, mode_t);
 
 extern struct posix_acl *get_posix_acl(struct inode *, int);
-- 
2.10.0

